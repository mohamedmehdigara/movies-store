'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var configureStore = require('@appbaseio/reactivecore');
var configureStore__default = _interopDefault(configureStore);
var constants = require('@appbaseio/reactivecore/lib/utils/constants');
var _rollupPluginBabelHelpers = require('./_rollupPluginBabelHelpers-f8b843f8.js');
var VueTypes = _interopDefault(require('vue-types'));
var helper = require('@appbaseio/reactivecore/lib/utils/helper');
require('emotion');
require('@appbaseio/vue-emotion');
require('polished');
var vueTypes = require('./vueTypes-7cfc2f98.js');
require('@appbaseio/reactivecore/lib/utils/transform');
require('redux');
var index = require('./index-de136c17.js');
var ComponentWrapper = require('./ComponentWrapper-94c50228.js');
var PreferencesConsumer = require('./PreferencesConsumer-5e6e84a2.js');
var Title = require('./Title-16042ea0.js');
require('./Flex-ddd7cb6b.js');
var hotkeys = _interopDefault(require('hotkeys-js'));
var Tags = require('./Tags-8fbad58b.js');
var CancelSvg = require('./CancelSvg-220a7cc3.js');
var Input = require('./Input-ead4cd84.js');
require('compute-scroll-into-view');
var Container = require('./Container-e699ea95.js');
require('vue-highlight-words');

var updateQuery = configureStore.Actions.updateQuery,
  setQueryOptions = configureStore.Actions.setQueryOptions,
  setCustomQuery = configureStore.Actions.setCustomQuery,
  setDefaultQuery = configureStore.Actions.setDefaultQuery,
  setCustomHighlightOptions = configureStore.Actions.setCustomHighlightOptions,
  recordSuggestionClick = configureStore.Actions.recordSuggestionClick,
  loadPopularSuggestions = configureStore.Actions.loadPopularSuggestions,
  getRecentSearches = configureStore.Actions.getRecentSearches,
  resetStoreForComponent = configureStore.Actions.resetStoreForComponent;
var debounce = configureStore.helper.debounce,
  checkValueChange = configureStore.helper.checkValueChange,
  getClassName = configureStore.helper.getClassName,
  extractQueryFromCustomQuery = configureStore.helper.extractQueryFromCustomQuery,
  getOptionsForCustomQuery = configureStore.helper.getOptionsForCustomQuery,
  isEqual = configureStore.helper.isEqual,
  getCompositeAggsQuery = configureStore.helper.getCompositeAggsQuery,
  withClickIds = configureStore.helper.withClickIds,
  getResultStats = configureStore.helper.getResultStats,
  handleOnSuggestions = configureStore.helper.handleOnSuggestions,
  getTopSuggestions = configureStore.helper.getTopSuggestions,
  normalizeDataField = configureStore.helper.normalizeDataField;
var DataSearch = {
  name: 'DataSearch',
  isTagsMode: false,
  data: function data() {
    var props = this.$props;
    this.__state = {
      currentValue: '',
      selectedTags: [],
      isOpen: false,
      normalizedSuggestions: [],
      isPending: false
    };
    this.internalComponent = props.componentId + "__internal";
    return this.__state;
  },
  inject: {
    theme: {
      from: 'theme_reactivesearch'
    }
  },
  created: function created() {
    var _this$$props = this.$props,
      enableRecentSearches = _this$$props.enableRecentSearches,
      distinctField = _this$$props.distinctField,
      distinctFieldConfig = _this$$props.distinctFieldConfig,
      index$1 = _this$$props.index,
      mode = _this$$props.mode;
    if (mode === constants.SEARCH_COMPONENTS_MODES.TAG) {
      this.$options.isTagsMode = true;
    }
    if (this.enableAppbase && this.aggregationField && this.aggregationField !== '') {
      console.warn('Warning(ReactiveSearch): The `aggregationField` prop has been marked as deprecated, please use the `distinctField` prop instead.');
    }
    if (!this.enableAppbase && (distinctField || distinctFieldConfig)) {
      console.warn('Warning(ReactiveSearch): In order to use the `distinctField` and `distinctFieldConfig` props, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
    }
    if (!this.enableAppbase && index$1) {
      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
    }
    this.currentValue = '';
    if (this.$options.isTagsMode) {
      this.currentValue = '';
    }
    var shouldFetchInitialSuggestions = this.$props.enableDefaultSuggestions || this.currentValue;
    if (shouldFetchInitialSuggestions) {
      this.loadPopularSuggestions(this.$props.componentId);
      if (enableRecentSearches) {
        this.getRecentSearches();
      }
    }
    this.handleTextChange = debounce(this.handleText, this.$props.debounce);
    this.updateDefaultQueryHandlerDebounced = debounce(this.updateDefaultQueryHandler, this.$props.debounce);
    this.updateQueryHandlerDebounced = debounce(this.updateQueryHandler, this.$props.debounce);
    // Set custom and default queries in store
    index.updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
    index.updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
    this.updateDefaultQueryHandlerDebounced(this.currentValue, this.$props, false);
  },
  computed: {
    suggestionsList: function suggestionsList() {
      var suggestionsList = [];
      if (!this.$data.currentValue && this.$props.defaultSuggestions && this.$props.defaultSuggestions.length) {
        suggestionsList = this.$props.defaultSuggestions;
      } else if (this.$data.currentValue) {
        suggestionsList = this.normalizedSuggestions;
      }
      return withClickIds(suggestionsList);
    },
    topSuggestions: function topSuggestions() {
      if (!this.currentValue) {
        return [];
      }
      return this.enablePopularSuggestions ? this.normalizedPopularSuggestions : [];
    },
    normalizedRecentSearches: function normalizedRecentSearches() {
      return this.recentSearches || [];
    },
    normalizedPopularSuggestions: function normalizedPopularSuggestions() {
      return getTopSuggestions(
      // use default popular suggestions if value is empty
      this.currentValue ? this.popularSuggestions : this.defaultPopularSuggestions || [], this.currentValue, this.showDistinctSuggestions);
    },
    defaultSearchSuggestions: function defaultSearchSuggestions() {
      var isPopularSuggestionsEnabled = this.enablePopularSuggestions;
      if (this.currentValue || !this.enableDefaultSuggestions) {
        return [];
      }
      var customDefaultPopularSuggestions = (this.defaultPopularSuggestions || []).map(function (suggestion) {
        return _rollupPluginBabelHelpers._extends({}, suggestion, {
          _popular_suggestion: true
        });
      });
      var customNormalizedRecentSearches = (this.normalizedRecentSearches || []).map(function (search) {
        return _rollupPluginBabelHelpers._extends({}, search, {
          _recent_search: true
        });
      });
      var defaultSuggestions = isPopularSuggestionsEnabled ? [].concat(customNormalizedRecentSearches, customDefaultPopularSuggestions || []) : customNormalizedRecentSearches;
      return getTopSuggestions(
      // use default popular suggestions if value is empty
      defaultSuggestions, this.currentValue, this.showDistinctSuggestions);
    },
    hasCustomRenderer: function hasCustomRenderer() {
      return index.hasCustomRenderer(this);
    },
    stats: function stats() {
      return getResultStats(this);
    }
  },
  props: {
    options: vueTypes.types.options,
    autoFocus: VueTypes.bool,
    autosuggest: VueTypes.bool.def(true),
    beforeValueChange: vueTypes.types.func,
    className: VueTypes.string.def(''),
    clearIcon: vueTypes.types.children,
    componentId: vueTypes.types.stringRequired,
    customHighlight: vueTypes.types.func,
    customQuery: vueTypes.types.func,
    defaultQuery: vueTypes.types.func,
    dataField: VueTypes.oneOfType([VueTypes.string, VueTypes.shape({
      field: VueTypes.string,
      weight: VueTypes.number
    }), VueTypes.arrayOf(VueTypes.string), VueTypes.arrayOf({
      field: VueTypes.string,
      weight: VueTypes.number
    })]),
    aggregationField: vueTypes.types.string,
    aggregationSize: VueTypes.number,
    size: VueTypes.number,
    debounce: VueTypes.number.def(0),
    defaultValue: vueTypes.types.string,
    excludeFields: vueTypes.types.excludeFields,
    value: VueTypes.oneOfType([VueTypes.arrayOf(VueTypes.string), vueTypes.types.value]),
    defaultSuggestions: vueTypes.types.suggestions,
    enableSynonyms: VueTypes.bool.def(true),
    enablePopularSuggestions: VueTypes.bool.def(false),
    enableRecentSearches: VueTypes.bool.def(false),
    fieldWeights: vueTypes.types.fieldWeights,
    filterLabel: vueTypes.types.string,
    fuzziness: vueTypes.types.fuzziness,
    highlight: VueTypes.bool,
    highlightField: vueTypes.types.stringOrArray,
    icon: vueTypes.types.children,
    iconPosition: VueTypes.oneOf(['left', 'right']).def('left'),
    includeFields: vueTypes.types.includeFields,
    innerClass: vueTypes.types.style,
    innerRef: VueTypes.string.def('searchInputField'),
    render: vueTypes.types.func,
    renderPopularSuggestions: vueTypes.types.func,
    parseSuggestion: vueTypes.types.func,
    renderNoSuggestion: vueTypes.types.title,
    renderError: vueTypes.types.title,
    placeholder: VueTypes.string.def('Search'),
    queryFormat: VueTypes.oneOf(['and', 'or']).def('or'),
    react: vueTypes.types.react,
    showClear: VueTypes.bool.def(true),
    showDistinctSuggestions: VueTypes.bool.def(true),
    showFilter: VueTypes.bool.def(true),
    showIcon: VueTypes.bool.def(true),
    title: vueTypes.types.title,
    theme: vueTypes.types.style,
    URLParams: VueTypes.bool.def(false),
    strictSelection: VueTypes.bool.def(false),
    nestedField: vueTypes.types.string,
    enablePredictiveSuggestions: VueTypes.bool.def(false),
    recentSearchesIcon: VueTypes.any,
    popularSearchesIcon: VueTypes.any,
    //	mic props
    showVoiceSearch: VueTypes.bool.def(false),
    getMicInstance: vueTypes.types.func,
    renderMic: vueTypes.types.func,
    distinctField: vueTypes.types.string,
    distinctFieldConfig: vueTypes.types.props,
    //
    focusShortcuts: VueTypes.arrayOf(VueTypes.oneOfType([VueTypes.string, VueTypes.number])).def(['/']),
    addonBefore: VueTypes.any,
    addonAfter: VueTypes.any,
    expandSuggestionsContainer: VueTypes.bool.def(true),
    index: VueTypes.string,
    enableDefaultSuggestions: VueTypes.bool.def(true),
    mode: VueTypes.oneOf(['select', 'tag']).def('select'),
    renderSelectedTags: VueTypes.any,
    endpoint: vueTypes.types.endpointConfig
  },
  beforeMount: function beforeMount() {
    if (this.$props.highlight) {
      if (this.customHighlight && typeof this.customHighlight === 'function') {
        this.setCustomHighlightOptions(this.componentId, this.customHighlight(this.$props));
      }
      var queryOptions = DataSearch.highlightQuery(this.$props) || {};
      this.queryOptions = _rollupPluginBabelHelpers._extends({}, queryOptions, this.getBasicQueryOptions());
      this.setQueryOptions(this.$props.componentId, this.queryOptions);
    } else {
      this.queryOptions = this.getBasicQueryOptions();
      this.setQueryOptions(this.$props.componentId, this.queryOptions);
    }
    if (this.selectedValue) {
      this.setValue(this.selectedValue, true, this.$props, this.$options.isTagsMode ? configureStore.causes.SUGGESTION_SELECT : undefined);
    } else if (this.$props.value) {
      this.setValue(this.$props.value, true, this.$props, this.$options.isTagsMode ? configureStore.causes.SUGGESTION_SELECT : undefined);
    } else if (this.$props.defaultValue) {
      this.setValue(this.$props.defaultValue, true, this.$props, this.$options.isTagsMode ? configureStore.causes.SUGGESTION_SELECT : undefined);
    }
  },
  mounted: function mounted() {
    this.listenForFocusShortcuts();
  },
  watch: {
    highlight: function highlight() {
      this.updateQueryOptions();
    },
    dataField: function dataField() {
      this.updateQueryOptions();
      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
    },
    highlightField: function highlightField() {
      this.updateQueryOptions();
    },
    fieldWeights: function fieldWeights() {
      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
    },
    fuzziness: function fuzziness() {
      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
    },
    queryFormat: function queryFormat() {
      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
    },
    defaultValue: function defaultValue(newVal) {
      this.setValue(newVal, true, this.$props);
    },
    value: function value(newVal, oldVal) {
      if (!isEqual(newVal, oldVal) || this.$options.isTagsMode && !isEqual(newVal, this.selectedTags)) {
        if (this.isPending && this.$options.isTagsMode && Array.isArray(newVal)) {
          this.isPending = false;
        }
        this.setValue(newVal, true, this.$props, newVal === '' ? configureStore.causes.CLEAR_VALUE : undefined, false, typeof newVal !== 'string' && this.$options.isTagsMode);
      }
    },
    defaultQuery: function defaultQuery(newVal, oldVal) {
      if (!index.isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
        this.updateDefaultQueryHandlerDebounced(this.$data.currentValue, this.$props);
      }
    },
    customQuery: function customQuery(newVal, oldVal) {
      if (!index.isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
      }
    },
    suggestions: function suggestions(newVal) {
      if (Array.isArray(newVal) && this.$data.currentValue.trim().length) {
        // shallow check allows us to set suggestions even if the next set
        // of suggestions are same as the current one
        this.$emit('suggestions', newVal);
        this.normalizedSuggestions = this.onSuggestions(newVal);
      }
    },
    selectedValue: function selectedValue(newVal, oldVal) {
      if (!isEqual(newVal, oldVal) && (this.$options.isTagsMode ? !isEqual(this.$data.selectedTags, newVal) : this.$data.currentValue !== newVal)) {
        if (!newVal && this.$data.currentValue) {
          // selected value is cleared, call onValueSelected
          this.onValueSelectedHandler('', configureStore.causes.CLEAR_VALUE);
        }
        if (this.$options.isTagsMode) {
          // handling reset of tags through SelectedFilters or URL
          this.selectedTags = [];
        }
        this.setValue(newVal || '', true, this.$props, this.$options.isTagsMode ? configureStore.causes.SUGGESTION_SELECT : undefined);
      }
    },
    focusShortcuts: function focusShortcuts() {
      this.listenForFocusShortcuts();
    }
  },
  methods: {
    handleText: function handleText(value) {
      if (this.$props.autosuggest) {
        this.updateDefaultQueryHandlerDebounced(value, this.$props);
      } else if (!this.$options.isTagsMode) {
        this.updateQueryHandlerDebounced(this.$props.componentId, value, this.$props);
      } else if (this.$options.isTagsMode) {
        this.$data.currentValue = value;
      }
    },
    validateDataField: function validateDataField() {
      var propName = 'dataField';
      var componentName = DataSearch.name;
      var props = this.$props;
      var requiredError = propName + " supplied to " + componentName + " is required. Validation failed.";
      var propValue = props[propName];
      if (!this.enableAppbase) {
        if (!propValue) {
          console.error(requiredError);
          return;
        }
        if (typeof propValue !== 'string' && typeof propValue !== 'object' && !Array.isArray(propValue)) {
          console.error("Invalid " + propName + " supplied to " + componentName + ". Validation failed.");
          return;
        }
        if (Array.isArray(propValue) && propValue.length === 0) {
          console.error(requiredError);
        }
      }
    },
    updateQueryOptions: function updateQueryOptions() {
      if (this.customHighlight && typeof this.customHighlight === 'function') {
        this.setCustomHighlightOptions(this.componentId, this.customHighlight(this.$props));
      }
      var queryOptions = DataSearch.highlightQuery(this.$props) || {};
      this.queryOptions = _rollupPluginBabelHelpers._extends({}, queryOptions, this.getBasicQueryOptions());
      this.setQueryOptions(this.$props.componentId, this.queryOptions);
    },
    getComponent: function getComponent(downshiftProps, isQuerySuggestionsRender) {
      if (downshiftProps === void 0) {
        downshiftProps = {};
      }
      if (isQuerySuggestionsRender === void 0) {
        isQuerySuggestionsRender = false;
      }
      var currentValue = this.$data.currentValue;
      var data = {
        error: this.error,
        loading: this.isLoading,
        downshiftProps: downshiftProps,
        data: this.suggestionsList,
        promotedData: this.promotedResults,
        aggregationData: this.aggregationData,
        rawData: this.rawData,
        customData: this.customData,
        value: currentValue,
        triggerClickAnalytics: this.triggerClickAnalytics,
        resultStats: this.stats,
        querySuggestions: this.normalizedPopularSuggestions,
        popularSuggestions: this.normalizedPopularSuggestions
      };
      if (isQuerySuggestionsRender) {
        return index.getQuerySuggestionsComponent({
          downshiftProps: downshiftProps,
          data: this.normalizedPopularSuggestions,
          value: currentValue,
          loading: this.isLoading,
          error: this.error
        }, this);
      }
      return index.getComponent(data, this);
    },
    // returns size and aggs property
    getBasicQueryOptions: function getBasicQueryOptions() {
      var aggregationField = this.$props.aggregationField;
      var queryOptions = helper.getQueryOptions(this.$props);
      if (aggregationField) {
        queryOptions.aggs = getCompositeAggsQuery({
          props: this.$props,
          showTopHits: true
        }).aggs;
      }
      return queryOptions;
    },
    onSuggestions: function onSuggestions(results) {
      return handleOnSuggestions(results, this.$data.currentValue, this);
    },
    handleSearchIconClick: function handleSearchIconClick() {
      var currentValue = this.currentValue;
      if (currentValue.trim()) {
        this.isPending = false;
        this.setValue(currentValue, true);
        this.onValueSelectedHandler(currentValue, configureStore.causes.SEARCH_ICON_CLICK);
      }
    },
    setValue: function setValue(value, isDefaultValue, props, cause, toggleIsOpen, isTagsMode) {
      var _this = this;
      if (isDefaultValue === void 0) {
        isDefaultValue = false;
      }
      if (props === void 0) {
        props = this.$props;
      }
      if (toggleIsOpen === void 0) {
        toggleIsOpen = true;
      }
      if (isTagsMode === void 0) {
        isTagsMode = this.$options.isTagsMode;
      }
      var performUpdate = function performUpdate() {
        if (isTagsMode && isEqual(value, _this.selectedTags)) {
          return;
        }
        // Refresh recent searches when value becomes empty
        if (!value && props.enableDefaultSuggestions === false) {
          _this.resetStoreForComponent(props.componentId);
        } else if (!value && _this.currentValue && _this.enableRecentSearches) {
          _this.getRecentSearches();
        }
        if (isTagsMode) {
          if (Array.isArray(_this.selectedTags) && _this.selectedTags.length) {
            // check if value already present in selectedTags
            if (typeof value === 'string' && _this.selectedTags.includes(value)) {
              _this.isOpen = false;
              return;
            }
            _this.selectedTags = [].concat(_this.selectedTags);
            if (typeof value === 'string' && !!value) {
              _this.selectedTags.push(value);
            } else if (Array.isArray(value) && !isEqual(_this.selectedTags, value)) {
              _this.selectedTags = value;
            }
          } else if (value) {
            _this.selectedTags = typeof value !== 'string' ? value : [].concat(value);
          }
          _this.currentValue = '';
        } else {
          _this.currentValue = value;
        }
        var queryHandlerValue = value;
        if (isTagsMode) {
          queryHandlerValue = Array.isArray(_this.selectedTags) && _this.selectedTags.length ? _this.selectedTags : undefined;
        }
        if (isDefaultValue) {
          if (_this.$props.autosuggest) {
            if (toggleIsOpen) {
              _this.isOpen = false;
            }
            if (typeof value === 'string') _this.updateDefaultQueryHandlerDebounced(value, _this.$props);
          } // in case of strict selection only SUGGESTION_SELECT should be able
          // to set the query otherwise the value should reset

          if (props.strictSelection && props.autosuggest) {
            if (cause === configureStore.causes.SUGGESTION_SELECT || props.value !== undefined) {
              _this.updateQueryHandler(props.componentId, queryHandlerValue, props);
            } else if (_this.currentValue !== '') {
              _this.setValue('', true);
            }
          } else {
            _this.updateQueryHandler(props.componentId, queryHandlerValue, props);
          }
        } else {
          // debounce for handling text while typing
          _this.handleTextChange(value);
        }
        _this.$emit('valueChange', value);
        _this.$emit('value-change', value);
        // Set the already fetched suggestions if query is same as used last to fetch the hits
        if (value === _this.lastUsedQuery) {
          _this.suggestions = _this.onSuggestions(_this.suggestions);
          // invoke on suggestions
          _this.$emit('suggestions', _this.suggestions);
        } else if (!value) {
          // reset suggestions
          _this.suggestions = [];
          // invoke on suggestions
          _this.$emit('suggestions', _this.suggestions);
        }
      };
      checkValueChange(props.componentId, value, props.beforeValueChange, performUpdate);
    },
    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props, execute) {
      if (props === void 0) {
        props = this.$props;
      }
      if (!value && props.enableDefaultSuggestions === false) {
        // clear Component data from store
        this.resetStoreForComponent(props.componentId);
        return;
      }
      var defaultQueryOptions;
      var query = DataSearch.defaultQuery(value, props);
      if (this.defaultQuery) {
        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
        var defaultQueryObj = extractQueryFromCustomQuery(defaultQueryToBeSet);
        if (defaultQueryObj) {
          query = defaultQueryObj;
        }
        defaultQueryOptions = getOptionsForCustomQuery(defaultQueryToBeSet);
        // Update calculated default query in store
        index.updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
      }
      this.setQueryOptions(this.internalComponent, _rollupPluginBabelHelpers._extends({}, this.queryOptions, defaultQueryOptions), execute);
      this.updateQuery({
        componentId: this.internalComponent,
        query: query,
        value: value,
        componentType: constants.componentTypes.dataSearch
      }, execute);
    },
    updateQueryHandler: function updateQueryHandler(componentId, value, props) {
      var customQuery = props.customQuery,
        filterLabel = props.filterLabel,
        showFilter = props.showFilter,
        URLParams = props.URLParams;
      var customQueryOptions;
      var defaultQueryTobeSet = DataSearch.defaultQuery(value, props);
      var query = defaultQueryTobeSet;
      if (customQuery) {
        var customQueryTobeSet = customQuery(value, props);
        var queryTobeSet = extractQueryFromCustomQuery(customQueryTobeSet);
        if (queryTobeSet) {
          query = queryTobeSet;
        }
        customQueryOptions = getOptionsForCustomQuery(customQueryTobeSet);
        index.updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
        this.setQueryOptions(componentId, _rollupPluginBabelHelpers._extends({}, this.queryOptions, customQueryOptions), false);
      }
      if (!this.isPending) {
        this.updateQuery({
          componentId: componentId,
          query: query,
          value: value,
          label: filterLabel,
          showFilter: showFilter,
          URLParams: URLParams,
          componentType: 'DATASEARCH'
        });
      }
    },
    // need to review
    handleFocus: function handleFocus(event) {
      this.isOpen = true;
      this.$emit('focus', event);
    },
    handleVoiceResults: function handleVoiceResults(_ref) {
      var results = _ref.results;
      if (results && results[0] && results[0].isFinal && results[0][0] && results[0][0].transcript && results[0][0].transcript.trim()) {
        this.isPending = false;
        this.setValue(results[0][0].transcript.trim(), true);
      }
    },
    triggerQuery: function triggerQuery(_temp) {
      var _ref2 = _temp === void 0 ? false : _temp,
        _ref2$isOpen = _ref2.isOpen,
        isOpen = _ref2$isOpen === void 0 ? false : _ref2$isOpen;
      var value = this.$props.value;
      if (value !== undefined) {
        this.isPending = false;
        this.setValue(this.$props.value, !isOpen);
      }
    },
    triggerClickAnalytics: function triggerClickAnalytics(searchPosition, documentId) {
      // click analytics would only work client side and after javascript loads
      var docId = documentId;
      if (!docId) {
        var hitData = this.suggestionsList.find(function (hit) {
          return hit._click_id === searchPosition;
        });
        if (hitData && hitData.source && hitData.source._id) {
          docId = hitData.source._id;
        }
      }
      this.recordSuggestionClick(searchPosition, docId);
    },
    clearValue: function clearValue() {
      this.isPending = false;
      this.setValue('', true);
      this.onValueSelectedHandler('', configureStore.causes.CLEAR_VALUE);
    },
    handleKeyDown: function handleKeyDown(event, highlightedIndex) {
      var targetValue = event.target.value;
      var _this$$props2 = this.$props,
        value = _this$$props2.value,
        strictSelection = _this$$props2.strictSelection,
        size = _this$$props2.size,
        autosuggest = _this$$props2.autosuggest;
      if (value !== undefined) {
        this.isPending = true;
      }
      // if a suggestion was selected, delegate the handling to suggestion handler
      if (event.key === 'Enter' && (highlightedIndex === null || highlightedIndex < 0 || highlightedIndex === [].concat([].concat(this.suggestionsList).slice(0, size || 10), this.defaultSearchSuggestions, this.topSuggestions).length)) {
        this.isPending = false;
        this.setValue(this.$options.isTagsMode && autosuggest && strictSelection ? '' : targetValue, true, this.$props, undefined, false);
        this.onValueSelectedHandler(targetValue, configureStore.causes.ENTER_PRESS);
      }
      // Need to review
      this.$emit('keyDown', event, this.triggerQuery);
      this.$emit('key-down', event, this.triggerQuery);
    },
    onInputChange: function onInputChange(e) {
      var _this2 = this;
      var inputValue = e.target.value;
      if (!this.$data.isOpen) {
        this.isOpen = true;
      }
      var _this$$props3 = this.$props,
        value = _this$$props3.value,
        autosuggest = _this$$props3.autosuggest;
      if (value === undefined) {
        this.setValue(inputValue, false, this.$props, undefined, true, false);
      } else {
        this.isPending = true;
        this.currentValue = inputValue;
        this.$emit('change', inputValue, function (_temp2) {
          var _ref3 = _temp2 === void 0 ? {} : _temp2,
            _ref3$isOpen = _ref3.isOpen,
            isOpen = _ref3$isOpen === void 0 ? false : _ref3$isOpen;
          if (_this2.$options.isTagsMode && autosuggest) {
            _this2.isOpen = isOpen;
            _this2.updateDefaultQueryHandlerDebounced(_this2.currentValue, _this2.$props);
            return;
          }
          _this2.triggerQuery({
            isOpen: isOpen
          });
        }, e);
      }
    },
    onSuggestionSelected: function onSuggestionSelected(suggestion) {
      var value = this.$props.value;
      // Record analytics for selected suggestions
      this.triggerClickAnalytics(suggestion._click_id);
      if (value === undefined) {
        this.setValue(suggestion.value, true, this.$props, configureStore.causes.SUGGESTION_SELECT);
      } else if (this.$options.isTagsMode) {
        var emitValue = Array.isArray(this.selectedTags) ? [].concat(this.selectedTags) : [];
        if (this.selectedTags.includes(suggestion.value)) {
          // avoid duplicates in tags array
          this.isOpen = false;
          return;
        }
        emitValue.push(suggestion.value);
        this.setValue(emitValue, true, this.$props, configureStore.causes.SUGGESTION_SELECT, true);
        this.$emit('change', emitValue, this.triggerQuery);
      } else {
        this.$emit('change', suggestion.value, this.triggerQuery);
      }
      this.isPending = false;
      this.onValueSelectedHandler(suggestion.value, configureStore.causes.SUGGESTION_SELECT, suggestion.source);
    },
    onValueSelectedHandler: function onValueSelectedHandler(currentValue) {
      if (currentValue === void 0) {
        currentValue = this.$data.currentValue;
      }
      for (var _len = arguments.length, cause = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        cause[_key - 1] = arguments[_key];
      }
      this.$emit.apply(this, ['valueSelected', currentValue].concat(cause));
      this.$emit.apply(this, ['value-selected', currentValue].concat(cause));
    },
    handleStateChange: function handleStateChange(changes) {
      var isOpen = changes.isOpen;
      this.isOpen = isOpen;
    },
    getBackgroundColor: function getBackgroundColor(highlightedIndex, index) {
      var isDark = this.themePreset === 'dark';
      if (isDark) {
        return highlightedIndex === index ? '#555' : '#424242';
      }
      return highlightedIndex === index ? '#eee' : '#fff';
    },
    renderIcon: function renderIcon() {
      var h = this.$createElement;
      if (this.$props.showIcon) {
        return this.$props.icon || h(Tags.SearchSvg);
      }
      return null;
    },
    renderErrorComponent: function renderErrorComponent() {
      var h = this.$createElement;
      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
      if (this.error && renderError && this.$data.currentValue && !this.isLoading) {
        return h(Tags.SuggestionWrapper, {
          "attrs": {
            "innerClass": this.$props.innerClass,
            "innerClassName": "error",
            "theme": this.theme,
            "themePreset": this.themePreset
          }
        }, [index.isFunction(renderError) ? renderError(this.error) : renderError]);
      }
      return null;
    },
    renderCancelIcon: function renderCancelIcon() {
      var h = this.$createElement;
      if (this.$props.showClear) {
        return this.$props.clearIcon || h(CancelSvg.CancelSvg);
      }
      return null;
    },
    renderNoSuggestions: function renderNoSuggestions(finalSuggestionsList) {
      if (finalSuggestionsList === void 0) {
        finalSuggestionsList = [];
      }
      var h = this.$createElement;
      var _this$$props4 = this.$props,
        theme = _this$$props4.theme,
        innerClass = _this$$props4.innerClass;
      var renderNoSuggestion = this.$scopedSlots.renderNoSuggestion || this.$props.renderNoSuggestion;
      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
      var _this$$data = this.$data,
        isOpen = _this$$data.isOpen,
        currentValue = _this$$data.currentValue;
      if (renderNoSuggestion && isOpen && !finalSuggestionsList.length && !this.isLoading && currentValue && !(renderError && this.error)) {
        return h(Tags.SuggestionWrapper, {
          "attrs": {
            "innerClass": innerClass,
            "themePreset": this.themePreset,
            "theme": theme,
            "innerClassName": "noSuggestion"
          },
          "scopedSlots": {
            "default": function _default() {
              return typeof renderNoSuggestion === 'function' ? renderNoSuggestion(currentValue) : renderNoSuggestion;
            }
          }
        });
      }
      return null;
    },
    renderInputAddonBefore: function renderInputAddonBefore() {
      var h = this.$createElement;
      var addonBefore = this.$scopedSlots.addonBefore;
      if (addonBefore) {
        return h(Tags.InputAddon, [addonBefore()]);
      }
      return null;
    },
    renderTag: function renderTag(item) {
      var _this3 = this;
      var h = this.$createElement;
      var innerClass = this.$props.innerClass;
      return h(Tags.TagItem, {
        "class": getClassName(innerClass, 'selected-tag') || ''
      }, [h("span", [item]), h("span", {
        "attrs": {
          "role": "img",
          "aria-label": "delete-tag"
        },
        "class": "close-icon",
        "on": {
          "click": function click() {
            return _this3.clearTag(item);
          }
        }
      }, [h(CancelSvg.CancelSvg)])]);
    },
    clearAllTags: function clearAllTags() {
      this.selectedTags = [];
      this.setValue('', true, this.$props, configureStore.causes.SUGGESTION_SELECT);
      if (this.$props.value !== undefined) {
        this.$emit('change', this.selectedTags, this.triggerQuery);
      }
    },
    clearTag: function clearTag(tagValue) {
      this.selectedTags = [].concat(this.selectedTags.filter(function (tag) {
        return tag !== tagValue;
      }));
      this.setValue('', true, this.$props, configureStore.causes.SUGGESTION_SELECT);
      if (this.$props.value !== undefined) {
        this.$emit('change', this.selectedTags, this.triggerQuery);
      }
    },
    renderTags: function renderTags() {
      var _this4 = this;
      var h = this.$createElement;
      if (!Array.isArray(this.selectedTags)) {
        return null;
      }
      var tagsList = [].concat(this.selectedTags);
      var shouldRenderClearAllTag = tagsList.length > 1;
      var renderSelectedTags = this.$scopedSlots.renderSelectedTags || this.$props.renderSelectedTags;
      return renderSelectedTags ? renderSelectedTags({
        values: this.selectedTags,
        handleClear: this.clearTag,
        handleClearAll: this.clearAllTags
      }) : h(Tags.TagsContainer, [tagsList.map(function (item) {
        return _this4.renderTag(item);
      }), shouldRenderClearAllTag && h(Tags.TagItem, {
        "class": getClassName(this.$props.innerClass, 'selected-tag') || ''
      }, [h("span", ["Clear All"]), h("span", {
        "attrs": {
          "role": "img",
          "aria-label": "delete-tag"
        },
        "class": "close-icon",
        "on": {
          "click": this.clearAllTags
        }
      }, [h(CancelSvg.CancelSvg)])])]);
    },
    renderInputAddonAfter: function renderInputAddonAfter() {
      var h = this.$createElement;
      var addonAfter = this.$scopedSlots.addonAfter;
      if (addonAfter) {
        return h(Tags.InputAddon, [addonAfter()]);
      }
      return null;
    },
    renderIcons: function renderIcons() {
      var h = this.$createElement;
      var _this$$props5 = this.$props,
        iconPosition = _this$$props5.iconPosition,
        showClear = _this$$props5.showClear,
        innerClass = _this$$props5.innerClass,
        getMicInstance = _this$$props5.getMicInstance,
        showVoiceSearch = _this$$props5.showVoiceSearch,
        showIcon = _this$$props5.showIcon;
      var renderMic = this.$scopedSlots.renderMic || this.$props.renderMic;
      var currentValue = this.$data.currentValue;
      return h("div", [h(CancelSvg.IconGroup, {
        "attrs": {
          "groupPosition": "right",
          "positionType": "absolute"
        }
      }, [currentValue && showClear && h(CancelSvg.IconWrapper, {
        "on": {
          "click": this.clearValue
        },
        "attrs": {
          "showIcon": showIcon,
          "isClearIcon": true
        }
      }, [this.renderCancelIcon()]), showVoiceSearch && h(Tags.Mic, {
        "attrs": {
          "getInstance": getMicInstance,
          "render": renderMic,
          "handleResult": this.handleVoiceResults,
          "className": getClassName(innerClass, 'mic') || null
        }
      }), iconPosition === 'right' && showIcon && h(CancelSvg.IconWrapper, {
        "on": {
          "click": this.handleSearchIconClick
        }
      }, [this.renderIcon()])]), h(CancelSvg.IconGroup, {
        "attrs": {
          "groupPosition": "left",
          "positionType": "absolute"
        }
      }, [iconPosition === 'left' && showIcon && h(CancelSvg.IconWrapper, {
        "on": {
          "click": this.handleSearchIconClick
        }
      }, [this.renderIcon()])])]);
    },
    focusSearchBox: function focusSearchBox(event) {
      var _this$$refs, _this$$refs$this$$pro;
      var elt = event.target || event.srcElement;
      var tagName = elt.tagName;
      if (elt.isContentEditable || tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA') {
        // already in an input
        return;
      }
      (_this$$refs = this.$refs) == null ? void 0 : (_this$$refs$this$$pro = _this$$refs[this.$props.innerRef]) == null ? void 0 : _this$$refs$this$$pro.focus(); // eslint-disable-line
    },
    listenForFocusShortcuts: function listenForFocusShortcuts() {
      var _this5 = this;
      var _this$$props$focusSho = this.$props.focusShortcuts,
        focusShortcuts = _this$$props$focusSho === void 0 ? ['/'] : _this$$props$focusSho;
      if (index.isEmpty(focusShortcuts)) {
        return;
      }
      var shortcutsString = index.parseFocusShortcuts(focusShortcuts).join(',');

      // handler for alphabets and other key combinations
      hotkeys(shortcutsString,
      // eslint-disable-next-line no-unused-vars
      /* eslint-disable no-shadow */
      function (event, handler) {
        // Prevent the default refresh event under WINDOWS system
        event.preventDefault();
        _this5.focusSearchBox(event);
      });

      // if one of modifier keys are used, they are handled below
      hotkeys('*', function (event) {
        var modifierKeys = index.extractModifierKeysFromFocusShortcuts(focusShortcuts);
        if (modifierKeys.length === 0) return;
        for (var index$1 = 0; index$1 < modifierKeys.length; index$1 += 1) {
          var element = modifierKeys[index$1];
          if (hotkeys[element]) {
            _this5.focusSearchBox(event);
            break;
          }
        }
      });
    }
  },
  render: function render() {
    var _this6 = this;
    var h = arguments[0];
    var _this$$props6 = this.$props,
      theme = _this$$props6.theme,
      size = _this$$props6.size,
      expandSuggestionsContainer = _this$$props6.expandSuggestionsContainer,
      enableDefaultSuggestions = _this$$props6.enableDefaultSuggestions;
    var _this$$scopedSlots = this.$scopedSlots,
      recentSearchesIcon = _this$$scopedSlots.recentSearchesIcon,
      popularSearchesIcon = _this$$scopedSlots.popularSearchesIcon;
    var hasSuggestions = this.currentValue ? this.suggestionsList.length || this.topSuggestions.length : this.defaultSearchSuggestions.length;
    if (enableDefaultSuggestions === false && !this.currentValue) {
      hasSuggestions = false;
    }
    return h(Container.Container, {
      "class": this.$props.className
    }, [this.$props.title && h(Title.Title, {
      "class": getClassName(this.$props.innerClass, 'title') || ''
    }, [this.$props.title]), this.$props.defaultSuggestions || this.$props.autosuggest ? h(CancelSvg.Downshift, {
      "attrs": {
        "id": this.$props.componentId + "-downshift",
        "handleChange": this.onSuggestionSelected,
        "handleMouseup": this.handleStateChange,
        "isOpen": this.$data.isOpen
      },
      "scopedSlots": {
        "default": function _default(_ref4) {
          var getInputEvents = _ref4.getInputEvents,
            getInputProps = _ref4.getInputProps,
            getItemProps = _ref4.getItemProps,
            getItemEvents = _ref4.getItemEvents,
            isOpen = _ref4.isOpen,
            highlightedIndex = _ref4.highlightedIndex,
            setHighlightedIndex = _ref4.setHighlightedIndex;
          var renderSuggestionsContainer = function renderSuggestionsContainer() {
            return h("div", [_this6.hasCustomRenderer && _this6.getComponent({
              isOpen: isOpen,
              getItemProps: getItemProps,
              getItemEvents: getItemEvents,
              highlightedIndex: highlightedIndex
            }), _this6.renderErrorComponent(), !_this6.hasCustomRenderer && isOpen && hasSuggestions ? h("ul", {
              "class": Input.suggestions(_this6.themePreset, theme) + " " + getClassName(_this6.$props.innerClass, 'list')
            }, [_this6.suggestionsList.slice(0, size || 10).map(function (item, index) {
              return h("li", {
                "domProps": _rollupPluginBabelHelpers._extends({}, getItemProps({
                  item: item
                })),
                "on": _rollupPluginBabelHelpers._extends({}, getItemEvents({
                  item: item
                })),
                "key": index + 1 + "-" + item.value,
                "style": {
                  backgroundColor: _this6.getBackgroundColor(highlightedIndex, index)
                }
              }, [h(Tags.SuggestionItem, {
                "attrs": {
                  "currentValue": _this6.currentValue,
                  "suggestion": item
                }
              })]);
            }), _this6.defaultSearchSuggestions.map(function (sugg, index) {
              return h("li", {
                "domProps": _rollupPluginBabelHelpers._extends({}, getItemProps({
                  item: sugg
                })),
                "on": _rollupPluginBabelHelpers._extends({}, getItemEvents({
                  item: sugg
                })),
                "key": _this6.suggestionsList.length + index + 1 + "-" + sugg.value,
                "style": {
                  backgroundColor: _this6.getBackgroundColor(highlightedIndex, _this6.suggestionsList.length + index),
                  justifyContent: 'flex-start'
                }
              }, [h("div", {
                "style": {
                  padding: '0 10px 0 0'
                }
              }, [sugg.source && sugg.source._recent_search && h(Tags.CustomSvg, {
                "attrs": {
                  "className": getClassName(_this6.$props.innerClass, 'recent-search-icon') || null,
                  "icon": recentSearchesIcon,
                  "type": "recent-search-icon"
                }
              }), sugg.source && sugg.source._popular_suggestion && h(Tags.CustomSvg, {
                "attrs": {
                  "className": getClassName(_this6.$props.innerClass, 'popular-search-icon') || null,
                  "icon": popularSearchesIcon,
                  "type": "popular-search-icon"
                }
              })]), h(Tags.SuggestionItem, {
                "attrs": {
                  "currentValue": _this6.currentValue,
                  "suggestion": sugg
                }
              })]);
            }), index.hasQuerySuggestionsRenderer(_this6) ? _this6.getComponent({
              isOpen: isOpen,
              getItemProps: getItemProps,
              getItemEvents: getItemEvents,
              highlightedIndex: highlightedIndex
            }, true) : _this6.topSuggestions.map(function (sugg, index) {
              return h("li", {
                "domProps": _rollupPluginBabelHelpers._extends({}, getItemProps({
                  item: sugg
                })),
                "on": _rollupPluginBabelHelpers._extends({}, getItemEvents({
                  item: sugg
                })),
                "key": _this6.suggestionsList.length + index + 1 + "-" + sugg.value,
                "style": {
                  backgroundColor: _this6.getBackgroundColor(highlightedIndex, _this6.suggestionsList.length + index),
                  justifyContent: 'flex-start'
                }
              }, [h("div", {
                "style": {
                  padding: '0 10px 0 0'
                }
              }, [h(Tags.CustomSvg, {
                "attrs": {
                  "className": getClassName(_this6.$props.innerClass, 'popular-search-icon') || null,
                  "icon": popularSearchesIcon,
                  "type": "popular-search-icon"
                }
              })]), h(Tags.SuggestionItem, {
                "attrs": {
                  "currentValue": _this6.currentValue,
                  "suggestion": sugg
                }
              })]);
            })]) : _this6.renderNoSuggestions(_this6.suggestionsList)]);
          };
          return h("div", {
            "class": Input.suggestionsContainer
          }, [h(Tags.InputGroup, [_this6.renderInputAddonBefore(), h(CancelSvg.InputWrapper, [h(Input.Input, {
            "attrs": {
              "id": _this6.$props.componentId + "-input",
              "showIcon": _this6.$props.showIcon,
              "showClear": _this6.$props.showClear,
              "iconPosition": _this6.$props.iconPosition,
              "placeholder": _this6.$props.placeholder,
              "autoFocus": _this6.$props.autoFocus,
              "themePreset": _this6.themePreset,
              "autocomplete": "off"
            },
            "ref": _this6.$props.innerRef,
            "class": getClassName(_this6.$props.innerClass, 'input'),
            "on": _rollupPluginBabelHelpers._extends({}, getInputEvents({
              onInput: _this6.onInputChange,
              onBlur: function onBlur(e) {
                _this6.$emit('blur', e, _this6.triggerQuery);
              },
              onFocus: _this6.handleFocus,
              onKeyPress: function onKeyPress(e) {
                _this6.$emit('keyPress', e, _this6.triggerQuery);
                _this6.$emit('key-press', e, _this6.triggerQuery);
              },
              onKeyDown: function onKeyDown(e) {
                return _this6.handleKeyDown(e, highlightedIndex);
              },
              onKeyUp: function onKeyUp(e) {
                _this6.$emit('keyUp', e, _this6.triggerQuery);
                _this6.$emit('key-up', e, _this6.triggerQuery);
              },
              onClick: function onClick() {
                setHighlightedIndex(null);
              }
            })),
            "domProps": _rollupPluginBabelHelpers._extends({}, getInputProps({
              value: _this6.$data.currentValue === null || typeof _this6.$data.currentValue !== 'string' ? '' : _this6.$data.currentValue
            }))
          }), _this6.renderIcons(), !expandSuggestionsContainer && renderSuggestionsContainer()]), ' ', _this6.renderInputAddonAfter()]), expandSuggestionsContainer && renderSuggestionsContainer(), _this6.renderTags()]);
        }
      }
    }) : h("div", {
      "class": Input.suggestionsContainer
    }, [h(Tags.InputGroup, [this.renderInputAddonBefore(), h(CancelSvg.InputWrapper, [h(Input.Input, {
      "class": getClassName(this.$props.innerClass, 'input') || '',
      "attrs": {
        "placeholder": this.$props.placeholder,
        "iconPosition": this.$props.iconPosition,
        "showIcon": this.$props.showIcon,
        "showClear": this.$props.showClear,
        "themePreset": this.themePreset
      },
      "on": _rollupPluginBabelHelpers._extends({}, {
        blur: function blur(e) {
          _this6.$emit('blur', e, _this6.triggerQuery);
        },
        keypress: function keypress(e) {
          _this6.$emit('keyPress', e, _this6.triggerQuery);
          _this6.$emit('key-press', e, _this6.triggerQuery);
        },
        input: this.onInputChange,
        focus: function focus(e) {
          _this6.$emit('focus', e, _this6.triggerQuery);
        },
        keydown: function keydown(e) {
          _this6.handleKeyDown(e, null);
        },
        keyup: function keyup(e) {
          _this6.$emit('keyUp', e, _this6.triggerQuery);
          _this6.$emit('key-up', e, _this6.triggerQuery);
        }
      }),
      "domProps": _rollupPluginBabelHelpers._extends({}, {
        autofocus: this.$props.autoFocus,
        value: this.$data.currentValue ? this.$data.currentValue : ''
      }),
      "ref": this.$props.innerRef
    }), this.renderIcons()]), this.renderInputAddonAfter()]), this.renderTags()])]);
  },
  destroyed: function destroyed() {
    document.removeEventListener('keydown', this.onKeyDown);
  }
};
DataSearch.defaultQuery = function (value, props) {
  var finalQuery = null;
  if (value) {
    var fields = normalizeDataField(props.dataField, props.fieldWeights);
    finalQuery = {
      bool: {
        should: DataSearch.shouldQuery(value, fields, props),
        minimum_should_match: '1'
      }
    };
  }
  if (value === '') {
    finalQuery = null;
  }
  if (finalQuery && props.nestedField) {
    return {
      query: {
        nested: {
          path: props.nestedField,
          query: finalQuery
        }
      }
    };
  }
  return finalQuery;
};
DataSearch.shouldQuery = function (value, dataFields, props) {
  var finalQuery = [];
  var phrasePrefixFields = [];
  var fields = dataFields.map(function (dataField) {
    var queryField = "" + dataField.field + (dataField.weight ? "^" + dataField.weight : '');
    if (!(dataField.field.endsWith('.keyword') || dataField.field.endsWith('.autosuggest') || dataField.field.endsWith('.search'))) {
      phrasePrefixFields.push(queryField);
    }
    return queryField;
  });
  if (props.searchOperators || props.queryString) {
    return {
      query: value,
      fields: fields,
      default_operator: props.queryFormat
    };
  }
  if (props.queryFormat === 'and') {
    finalQuery.push({
      multi_match: {
        query: value,
        fields: fields,
        type: 'cross_fields',
        operator: 'and'
      }
    });
    finalQuery.push({
      multi_match: {
        query: value,
        fields: fields,
        type: 'phrase',
        operator: 'and'
      }
    });
    if (phrasePrefixFields.length > 0) {
      finalQuery.push({
        multi_match: {
          query: value,
          fields: phrasePrefixFields,
          type: 'phrase_prefix',
          operator: 'and'
        }
      });
    }
    return finalQuery;
  }
  finalQuery.push({
    multi_match: {
      query: value,
      fields: fields,
      type: 'best_fields',
      operator: 'or',
      fuzziness: props.fuzziness ? props.fuzziness : 0
    }
  });
  finalQuery.push({
    multi_match: {
      query: value,
      fields: fields,
      type: 'phrase',
      operator: 'or'
    }
  });
  if (phrasePrefixFields.length > 0) {
    finalQuery.push({
      multi_match: {
        query: value,
        fields: phrasePrefixFields,
        type: 'phrase_prefix',
        operator: 'or'
      }
    });
  }
  return finalQuery;
};
DataSearch.highlightQuery = function (props) {
  if (props.customHighlight) {
    return props.customHighlight(props);
  }
  if (!props.highlight) {
    return null;
  }
  var fields = {};
  var highlightField = props.highlightField ? props.highlightField : props.dataField;
  if (typeof highlightField === 'string') {
    fields[highlightField] = {};
  } else if (Array.isArray(highlightField)) {
    highlightField.forEach(function (item) {
      fields[item] = {};
    });
  }
  return {
    highlight: _rollupPluginBabelHelpers._extends({
      pre_tags: ['<mark>'],
      post_tags: ['</mark>'],
      fields: fields
    }, props.highlightField && {
      require_field_match: false
    })
  };
};
DataSearch.hasInternalComponent = function () {
  return true;
};
var mapStateToProps = function mapStateToProps(state, props) {
  return {
    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
    suggestions: state.hits[props.componentId] && state.hits[props.componentId].hits,
    rawData: state.rawData[props.componentId],
    aggregationData: state.compositeAggregations[props.componentId] || [],
    isLoading: !!state.isLoading[props.componentId + "_active"],
    themePreset: state.config.themePreset,
    error: state.error[props.componentId],
    analytics: state.analytics,
    enableAppbase: state.config.enableAppbase,
    headers: state.appbaseRef.headers,
    promotedResults: state.promotedResults[props.componentId] || [],
    customData: state.customData[props.componentId],
    time: state.hits[props.componentId] && state.hits[props.componentId].time || 0,
    total: state.hits[props.componentId] && state.hits[props.componentId].total,
    hidden: state.hits[props.componentId] && state.hits[props.componentId].hidden,
    popularSuggestions: state.querySuggestions[props.componentId],
    defaultPopularSuggestions: state.defaultPopularSuggestions[props.componentId],
    componentProps: state.props[props.componentId],
    lastUsedQuery: state.queryToHits[props.componentId],
    recentSearches: state.recentSearches.data
  };
};
var mapDispatchToProps = {
  setQueryOptions: setQueryOptions,
  updateQuery: updateQuery,
  setCustomQuery: setCustomQuery,
  setDefaultQuery: setDefaultQuery,
  setCustomHighlightOptions: setCustomHighlightOptions,
  recordSuggestionClick: recordSuggestionClick,
  loadPopularSuggestions: loadPopularSuggestions,
  getRecentSearches: getRecentSearches,
  resetStoreForComponent: resetStoreForComponent
};
var DSConnected = PreferencesConsumer.PreferencesConsumer(ComponentWrapper.ComponentWrapper(index.connect(mapStateToProps, mapDispatchToProps)(DataSearch), {
  componentType: constants.componentTypes.dataSearch,
  internalComponent: DataSearch.hasInternalComponent()
}));
DSConnected.defaultQuery = DataSearch.defaultQuery;
DSConnected.shouldQuery = DataSearch.shouldQuery;
DSConnected.highlightQuery = DataSearch.highlightQuery;
DSConnected.hasInternalComponent = DataSearch.hasInternalComponent;
DSConnected.name = DataSearch.name;

// plugins usage
DSConnected.install = function (Vue) {
  Vue.component(DSConnected.name, DSConnected);
};
// Add componentType for SSR
DSConnected.componentType = constants.componentTypes.dataSearch;

exports.DSConnected = DSConnected;
exports.default = DSConnected;
