'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var configureStore = require('@appbaseio/reactivecore');
var configureStore__default = _interopDefault(configureStore);
var constants = require('@appbaseio/reactivecore/lib/utils/constants');
var _rollupPluginBabelHelpers = require('./_rollupPluginBabelHelpers-f8b843f8.js');
var VueTypes = _interopDefault(require('vue-types'));
require('emotion');
require('@appbaseio/vue-emotion');
require('polished');
var vueTypes = require('./vueTypes-7cfc2f98.js');
require('@appbaseio/reactivecore/lib/utils/transform');
require('redux');
var index = require('./index-de136c17.js');
var ComponentWrapper = require('./ComponentWrapper-94c50228.js');
var PreferencesConsumer = require('./PreferencesConsumer-5e6e84a2.js');
var Title = require('./Title-16042ea0.js');
var Input = require('./Input-ead4cd84.js');
var Container = require('./Container-e699ea95.js');
var suggestions = require('@appbaseio/reactivecore/lib/utils/suggestions');
var FormControlList = require('./FormControlList-bbb5cd24.js');
var utils = require('./utils-83fd01e9.js');

var updateQuery = configureStore.Actions.updateQuery,
  setQueryOptions = configureStore.Actions.setQueryOptions,
  setCustomQuery = configureStore.Actions.setCustomQuery,
  setDefaultQuery = configureStore.Actions.setDefaultQuery;
var isEqual = configureStore.helper.isEqual,
  getQueryOptions = configureStore.helper.getQueryOptions,
  checkValueChange = configureStore.helper.checkValueChange,
  getClassName = configureStore.helper.getClassName,
  extractQueryFromCustomQuery = configureStore.helper.extractQueryFromCustomQuery,
  getOptionsForCustomQuery = configureStore.helper.getOptionsForCustomQuery;
var MultiList = {
  name: 'MultiList',
  props: {
    defaultValue: vueTypes.types.stringArray,
    value: vueTypes.types.stringArray,
    queryFormat: VueTypes.oneOf(['and', 'or']).def('or'),
    showCheckbox: VueTypes.bool.def(true),
    beforeValueChange: vueTypes.types.func,
    className: VueTypes.string.def(''),
    componentId: vueTypes.types.stringRequired,
    customQuery: vueTypes.types.func,
    dataField: vueTypes.types.stringRequired,
    defaultQuery: vueTypes.types.func,
    filterLabel: vueTypes.types.string,
    innerClass: vueTypes.types.style,
    placeholder: VueTypes.string.def('Search'),
    react: vueTypes.types.react,
    render: vueTypes.types.func,
    renderItem: vueTypes.types.func,
    renderError: vueTypes.types.title,
    renderNoResults: VueTypes.any,
    transformData: vueTypes.types.func,
    selectAllLabel: vueTypes.types.string,
    showCount: VueTypes.bool.def(true),
    showFilter: VueTypes.bool.def(true),
    showSearch: VueTypes.bool.def(true),
    size: VueTypes.number,
    sortBy: VueTypes.oneOf(['asc', 'desc', 'count']).def('count'),
    title: vueTypes.types.title,
    URLParams: VueTypes.bool.def(false),
    showMissing: VueTypes.bool.def(false),
    missingLabel: VueTypes.string.def('N/A'),
    nestedField: vueTypes.types.string,
    index: VueTypes.string,
    endpoint: vueTypes.types.endpointConfig
  },
  data: function data() {
    var props = this.$props;
    this.__state = {
      currentValue: {},
      modifiedOptions: [],
      searchTerm: ''
    };
    this.internalComponent = props.componentId + "__internal";
    return this.__state;
  },
  created: function created() {
    if (!this.enableAppbase && this.$props.index) {
      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
    }
    var props = this.$props;
    this.modifiedOptions = this.options && this.options[props.dataField] ? this.options[props.dataField].buckets : [];
    // Set custom and default queries in store
    index.updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
    index.updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
  },
  beforeMount: function beforeMount() {
    this.updateQueryHandlerOptions(this.$props);
    var value = this.selectedValue || this.$props.value || this.$props.defaultValue;
    this.setValue(value, !this.selectedValue);
  },
  mounted: function mounted() {
    var currentValue = Object.keys(this.$data.currentValue);
    if (this.$props.value !== undefined && !isEqual(this.$props.value, currentValue)) {
      this.$emit('change', currentValue);
    }
  },
  watch: {
    options: function options(newVal) {
      if (newVal) {
        this.modifiedOptions = newVal[this.$props.dataField] ? newVal[this.$props.dataField].buckets : [];
      }
    },
    size: function size() {
      this.updateQueryHandlerOptions(this.$props);
    },
    sortBy: function sortBy() {
      this.updateQueryHandlerOptions(this.$props);
    },
    dataField: function dataField() {
      this.updateQueryHandlerOptions(this.$props);
      this.updateQueryHandler(this.$data.currentValue, this.$props);
    },
    value: function value(newVal, oldVal) {
      if (!isEqual(oldVal, newVal)) {
        this.setValue(newVal, true);
      }
    },
    defaultValue: function defaultValue(newVal, oldVal) {
      if (!isEqual(oldVal, newVal)) {
        this.setValue(newVal, true);
      }
    },
    selectedValue: function selectedValue(newVal) {
      var _this = this;
      var selectedValue = Object.keys(this.$data.currentValue);
      if (this.$props.selectAllLabel) {
        selectedValue = selectedValue.filter(function (val) {
          return val !== _this.$props.selectAllLabel;
        });
        if (this.$data.currentValue[this.$props.selectAllLabel]) {
          selectedValue = [this.$props.selectAllLabel];
        }
      }
      if (!isEqual(selectedValue, newVal)) {
        if (this.value === undefined) {
          this.setValue(newVal, true);
        } else {
          this.$emit('change', newVal);
        }
      }
    },
    defaultQuery: function defaultQuery(newVal, oldVal) {
      if (!index.isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
        this.updateDefaultQueryHandler(this.$data.currentValue, this.$props);
      }
    },
    customQuery: function customQuery(newVal, oldVal) {
      if (!index.isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
      }
    }
  },
  render: function render() {
    var _this2 = this;
    var h = arguments[0];
    var _this$$props = this.$props,
      selectAllLabel = _this$$props.selectAllLabel,
      renderItem = _this$$props.renderItem,
      renderError = _this$$props.renderError;
    var renderItemCalc = this.$scopedSlots.renderItem || renderItem;
    var renderErrorCalc = this.$scopedSlots.renderError || renderError;
    if (renderErrorCalc && this.error) {
      return index.isFunction(renderErrorCalc) ? renderErrorCalc(this.error) : renderErrorCalc;
    }
    if (!this.hasCustomRenderer && this.modifiedOptions.length === 0 && !this.isLoading) {
      if (this.renderNoResults) {
        this.renderNoResult();
      } else {
        return null;
      }
    }
    var itemsToRender = this.$data.modifiedOptions;
    if (this.$props.transformData) {
      itemsToRender = this.$props.transformData(itemsToRender);
    }
    var filteredItemsToRender = itemsToRender.filter(function (item) {
      if (String(item.key).length) {
        if (_this2.$props.showSearch && _this2.$data.searchTerm) {
          return suggestions.replaceDiacritics(String(item.key)).toLowerCase().includes(suggestions.replaceDiacritics(_this2.$data.searchTerm).toLowerCase());
        }
        return true;
      }
      return false;
    });
    return h(Container.Container, {
      "class": this.$props.className
    }, [this.$props.title && h(Title.Title, {
      "class": getClassName(this.$props.innerClass, 'title')
    }, [this.$props.title]), this.renderSearch(), this.hasCustomRenderer ? this.getComponent() : h(FormControlList.UL, {
      "class": getClassName(this.$props.innerClass, 'list')
    }, [selectAllLabel ? h("li", {
      "key": selectAllLabel,
      "class": "" + (this.currentValue[selectAllLabel] ? 'active' : '')
    }, [h(FormControlList.Checkbox, {
      "attrs": {
        "type": "checkbox",
        "id": this.$props.componentId + "-" + selectAllLabel,
        "name": selectAllLabel,
        "value": selectAllLabel,
        "show": this.$props.showCheckbox
      },
      "class": getClassName(this.$props.innerClass, 'checkbox'),
      "on": {
        "click": this.handleClick
      },
      "domProps": _rollupPluginBabelHelpers._extends({}, {
        checked: !!this.currentValue[selectAllLabel]
      })
    }), h("label", {
      "class": getClassName(this.$props.innerClass, 'label'),
      "attrs": {
        "for": this.$props.componentId + "-" + selectAllLabel
      }
    }, [h("span", [selectAllLabel, this.$props.showCount && h("span", {
      "class": getClassName(this.$props.innerClass, 'count')
    }, ["\xA0(", this.totalDocumentCount, ")"])])])]) : null, !this.hasCustomRenderer && filteredItemsToRender.length === 0 && !this.isLoading ? this.renderNoResult() : filteredItemsToRender.map(function (item) {
      return h("li", {
        "key": item.key,
        "class": "" + (_this2.$data.currentValue[item.key] ? 'active' : '')
      }, [h(FormControlList.Checkbox, {
        "attrs": {
          "type": "checkbox",
          "id": _this2.$props.componentId + "-" + item.key,
          "name": _this2.$props.componentId,
          "value": item.key,
          "show": _this2.$props.showCheckbox
        },
        "class": getClassName(_this2.$props.innerClass, 'checkbox'),
        "on": {
          "click": _this2.handleClick
        },
        "domProps": _rollupPluginBabelHelpers._extends({}, {
          checked: !!_this2.$data.currentValue[item.key]
        })
      }), h("label", {
        "class": getClassName(_this2.$props.innerClass, 'label'),
        "attrs": {
          "for": _this2.$props.componentId + "-" + item.key
        }
      }, [renderItemCalc ? renderItemCalc({
        label: item.key,
        count: item.doc_count,
        isChecked: !!_this2.$data.currentValue[item.key]
      }) : h("span", [item.key, _this2.$props.showCount && h("span", {
        "class": getClassName(_this2.$props.innerClass, 'count')
      }, ["\xA0(", item.doc_count, ")"])])])]);
    })])]);
  },
  methods: {
    setValue: function setValue(value, isDefaultValue, props) {
      var _this3 = this;
      if (isDefaultValue === void 0) {
        isDefaultValue = false;
      }
      if (props === void 0) {
        props = this.$props;
      }
      var selectAllLabel = this.$props.selectAllLabel;
      var currentValue = this.$data.currentValue;
      var finalValues = null;
      if (selectAllLabel && (Array.isArray(value) && value.includes(selectAllLabel) || typeof value === 'string' && value === selectAllLabel)) {
        if (currentValue[selectAllLabel]) {
          currentValue = {};
          finalValues = [];
        } else {
          this.$data.modifiedOptions.forEach(function (item) {
            currentValue[item.key] = true;
          });
          currentValue[selectAllLabel] = true;
          finalValues = [selectAllLabel];
        }
      } else if (isDefaultValue) {
        finalValues = value;
        currentValue = {};
        if (value && value.length) {
          value.forEach(function (item) {
            currentValue[item] = true;
          });
        }
        if (selectAllLabel && selectAllLabel in currentValue) {
          var _currentValue = currentValue,
            del = _currentValue[selectAllLabel],
            obj = _rollupPluginBabelHelpers._objectWithoutPropertiesLoose(_currentValue, [selectAllLabel].map(_rollupPluginBabelHelpers._toPropertyKey));
          currentValue = _rollupPluginBabelHelpers._extends({}, obj);
        }
      } else {
        if (currentValue[value]) {
          var _currentValue2 = currentValue,
            _del = _currentValue2[value],
            rest = _rollupPluginBabelHelpers._objectWithoutPropertiesLoose(_currentValue2, [value].map(_rollupPluginBabelHelpers._toPropertyKey));
          currentValue = _rollupPluginBabelHelpers._extends({}, rest);
        } else if (Array.isArray(value)) {
          value.forEach(function (val) {
            currentValue[val] = true;
          });
        } else {
          currentValue[value] = true;
        }
        if (selectAllLabel && selectAllLabel in currentValue) {
          var _currentValue3 = currentValue,
            _del2 = _currentValue3[selectAllLabel],
            _obj = _rollupPluginBabelHelpers._objectWithoutPropertiesLoose(_currentValue3, [selectAllLabel].map(_rollupPluginBabelHelpers._toPropertyKey));
          currentValue = _rollupPluginBabelHelpers._extends({}, _obj);
        }
        finalValues = Object.keys(currentValue);
      }
      var performUpdate = function performUpdate() {
        _this3.currentValue = Object.assign({}, currentValue);
        _this3.updateQueryHandler(finalValues, props);
        _this3.$emit('valueChange', finalValues);
        _this3.$emit('value-change', finalValues);
      };
      checkValueChange(props.componentId, finalValues, props.beforeValueChange, performUpdate);
    },
    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props) {
      var query = MultiList.defaultQuery(value, props);
      if (this.defaultQuery) {
        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
        var defaultQueryObj = extractQueryFromCustomQuery(defaultQueryToBeSet);
        if (defaultQueryObj) {
          query = defaultQueryObj;
        }

        // Update calculated default query in store
        index.updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
        var defaultQueryOptions = getOptionsForCustomQuery(defaultQueryToBeSet);
        this.setQueryOptions(this.internalComponent, defaultQueryOptions, false);
      }
      this.updateQuery({
        componentId: this.internalComponent,
        query: query,
        value: value,
        componentType: constants.componentTypes.multiList
      });
    },
    updateQueryHandler: function updateQueryHandler(value, props) {
      var customQuery = props.customQuery;
      var query = MultiList.defaultQuery(value, props);
      if (customQuery) {
        var customQueryCalc = customQuery(value, props);
        query = extractQueryFromCustomQuery(customQueryCalc);
        index.updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
        var customQueryOptions = getOptionsForCustomQuery(customQueryCalc);
        this.setQueryOptions(props.componentId, customQueryOptions, false);
      }
      this.updateQuery({
        componentId: props.componentId,
        query: query,
        value: value,
        label: props.filterLabel,
        showFilter: props.showFilter,
        URLParams: props.URLParams,
        componentType: constants.componentTypes.multiList
      });
    },
    generateQueryOptions: function generateQueryOptions(props) {
      var queryOptions = getQueryOptions(props);
      return utils.getAggsQuery(queryOptions, props);
    },
    updateQueryHandlerOptions: function updateQueryHandlerOptions(props) {
      var queryOptions = MultiList.generateQueryOptions(props);
      if (props.defaultQuery) {
        var value = Object.keys(this.$data.currentValue);
        var defaultQueryOptions = getOptionsForCustomQuery(props.defaultQuery(value, props));
        this.setQueryOptions(this.internalComponent, _rollupPluginBabelHelpers._extends({}, queryOptions, defaultQueryOptions));
      } else {
        this.setQueryOptions(this.internalComponent, queryOptions);
      }
    },
    handleInputChange: function handleInputChange(e) {
      var value = e.target.value;
      this.searchTerm = value;
    },
    renderSearch: function renderSearch() {
      var h = this.$createElement;
      if (this.$props.showSearch) {
        return h(Input.Input, {
          "class": getClassName(this.$props.innerClass, 'input') || '',
          "on": {
            "input": this.handleInputChange
          },
          "attrs": {
            "value": this.$data.searchTerm,
            "placeholder": this.$props.placeholder,
            "themePreset": this.$props.themePreset
          },
          "style": {
            margin: '0 0 8px'
          }
        });
      }
      return null;
    },
    handleClick: function handleClick(e) {
      var currentValue = e;
      if (index.isEvent(e)) {
        currentValue = e.target.value;
      }
      var value = this.$props.value;
      if (value === undefined) {
        this.setValue(currentValue);
      } else {
        var values = index.parseValueArray(value || [], currentValue);
        this.$emit('change', values);
      }
    },
    getComponent: function getComponent() {
      var _this$$data = this.$data,
        currentValue = _this$$data.currentValue,
        modifiedOptions = _this$$data.modifiedOptions;
      var transformData = this.$props.transformData;
      var itemsToRender = modifiedOptions;
      if (transformData) {
        itemsToRender = transformData(itemsToRender);
      }
      var data = {
        error: this.error,
        loading: this.isLoading,
        value: currentValue,
        data: itemsToRender,
        rawData: this.rawData,
        handleChange: this.handleClick
      };
      return index.getComponent(data, this);
    },
    renderNoResult: function renderNoResult() {
      var h = this.$createElement;
      var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
      return h("p", {
        "class": getClassName(this.$props.innerClass, 'noResults') || null
      }, [index.isFunction(renderNoResults) ? renderNoResults() : renderNoResults]);
    }
  },
  computed: {
    hasCustomRenderer: function hasCustomRenderer() {
      return index.hasCustomRenderer(this);
    }
  }
};
MultiList.defaultQuery = function (value, props) {
  var query = null;
  var queryFormat = props.queryFormat;
  if (queryFormat === undefined) {
    queryFormat = 'or';
  }
  var type = queryFormat === 'or' ? 'terms' : 'term';
  if (!Array.isArray(value) || value.length === 0) {
    return null;
  }
  if (props.selectAllLabel && value.includes(props.selectAllLabel)) {
    if (props.showMissing) {
      query = {
        match_all: {}
      };
    } else {
      query = {
        exists: {
          field: props.dataField
        }
      };
    }
  } else if (value) {
    var listQuery;
    if (queryFormat === 'or') {
      if (props.showMissing) {
        var _type, _ref;
        var hasMissingTerm = value.includes(props.missingLabel);
        var should = [(_ref = {}, _ref[type] = (_type = {}, _type[props.dataField] = value.filter(function (item) {
          return item !== props.missingLabel;
        }), _type), _ref)];
        if (hasMissingTerm) {
          should = should.concat({
            bool: {
              must_not: {
                exists: {
                  field: props.dataField
                }
              }
            }
          });
        }
        listQuery = {
          bool: {
            should: should
          }
        };
      } else {
        var _type2, _listQuery;
        listQuery = (_listQuery = {}, _listQuery[type] = (_type2 = {}, _type2[props.dataField] = value, _type2), _listQuery);
      }
    } else {
      // adds a sub-query with must as an array of objects for each term/value
      var queryArray = value.map(function (item) {
        var _type3, _ref2;
        return _ref2 = {}, _ref2[type] = (_type3 = {}, _type3[props.dataField] = item, _type3), _ref2;
      });
      listQuery = {
        bool: {
          must: queryArray
        }
      };
    }
    query = value.length ? listQuery : null;
  }
  if (query && props.nestedField) {
    query = {
      query: {
        nested: {
          path: props.nestedField,
          query: query
        }
      }
    };
  }
  return query;
};
MultiList.generateQueryOptions = function (props) {
  var queryOptions = getQueryOptions(props);
  return utils.getAggsQuery(queryOptions, props);
};
var mapStateToProps = function mapStateToProps(state, props) {
  return {
    options: props.nestedField && state.aggregations[props.componentId] ? state.aggregations[props.componentId].reactivesearch_nested : state.aggregations[props.componentId],
    rawData: state.rawData[props.componentId],
    isLoading: state.isLoading[props.componentId],
    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
    themePreset: state.config.themePreset,
    totalDocumentCount: state.hits[props.componentId] && state.hits[props.componentId].total,
    error: state.error[props.componentId],
    componentProps: state.props[props.componentId],
    enableAppbase: state.config.enableAppbase
  };
};
var mapDispatchtoProps = {
  setQueryOptions: setQueryOptions,
  updateQuery: updateQuery,
  setCustomQuery: setCustomQuery,
  setDefaultQuery: setDefaultQuery
};
MultiList.hasInternalComponent = function () {
  return true;
};
var ListConnected = PreferencesConsumer.PreferencesConsumer(ComponentWrapper.ComponentWrapper(index.connect(mapStateToProps, mapDispatchtoProps)(MultiList), {
  componentType: constants.componentTypes.multiList,
  internalComponent: MultiList.hasInternalComponent()
}));
ListConnected.name = MultiList.name;
ListConnected.defaultQuery = MultiList.defaultQuery;
ListConnected.generateQueryOptions = MultiList.generateQueryOptions;
ListConnected.hasInternalComponent = MultiList.hasInternalComponent;
// Add componentType for SSR
ListConnected.componentType = constants.componentTypes.multiList;
ListConnected.install = function (Vue) {
  Vue.component(ListConnected.name, ListConnected);
};

exports.ListConnected = ListConnected;
exports.default = ListConnected;
