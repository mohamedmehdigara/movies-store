import { Actions, helper } from '@appbaseio/reactivecore';
import { componentTypes } from '@appbaseio/reactivecore/lib/utils/constants';
import './_rollupPluginBabelHelpers-ded08042.js';
import VueTypes from 'vue-types';
import 'emotion';
import '@appbaseio/vue-emotion';
import 'polished';
import { t as types } from './vueTypes-8986b709.js';
import '@appbaseio/reactivecore/lib/utils/transform';
import 'redux';
import { f as updateCustomQuery, i as isQueryIdentical, c as connect } from './index-5509c0bc.js';
import { C as ComponentWrapper } from './ComponentWrapper-edaeaceb.js';
import { P as PreferencesConsumer } from './PreferencesConsumer-86a676c8.js';
import { T as Title } from './Title-863dfa42.js';
import { C as Container } from './Container-d00219f7.js';
import { U as UL, R as Radio } from './FormControlList-99797d0a.js';

var updateQuery = Actions.updateQuery,
  setQueryOptions = Actions.setQueryOptions,
  setCustomQuery = Actions.setCustomQuery;
var isEqual = helper.isEqual,
  checkValueChange = helper.checkValueChange,
  getClassName = helper.getClassName,
  getOptionsFromQuery = helper.getOptionsFromQuery;
var SingleRange = {
  name: 'SingleRange',
  data: function data() {
    this.__state = {
      currentValue: null
    };
    this.type = 'range';
    return this.__state;
  },
  props: {
    beforeValueChange: types.func,
    className: VueTypes.string.def(''),
    componentId: types.stringRequired,
    customQuery: types.func,
    data: types.data,
    dataField: types.stringRequired,
    defaultValue: types.string,
    value: types.value,
    filterLabel: types.string,
    innerClass: types.style,
    react: types.react,
    showFilter: VueTypes.bool.def(true),
    showRadio: VueTypes.bool.def(true),
    title: types.title,
    URLParams: VueTypes.bool.def(false),
    nestedField: types.string,
    index: VueTypes.string,
    endpoint: types.endpointConfig
  },
  created: function created() {
    if (!this.enableAppbase && this.$props.index) {
      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
    }
    // Set custom query in store
    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
  },
  beforeMount: function beforeMount() {
    if (this.selectedValue) {
      this.setValue(this.selectedValue);
    } else if (this.$props.value) {
      this.setValue(this.$props.value);
    } else if (this.$props.defaultValue) {
      this.setValue(this.$props.defaultValue);
    }
  },
  watch: {
    dataField: function dataField() {
      this.updateQueryHandler(this.$data.currentValue, this.$props);
    },
    defaultValue: function defaultValue(newVal) {
      this.setValue(newVal);
    },
    value: function value(newVal, oldVal) {
      if (!isEqual(newVal, oldVal)) {
        this.setValue(newVal);
      }
    },
    selectedValue: function selectedValue(newVal) {
      if (!isEqual(this.$data.currentValue, newVal)) {
        this.setValue(newVal);
      }
    },
    customQuery: function customQuery(newVal, oldVal) {
      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
        this.updateQueryHandler(this.$data.currentValue, this.$props);
      }
    }
  },
  render: function render() {
    var _this = this;
    var h = arguments[0];
    return h(Container, {
      "class": this.$props.className
    }, [this.$props.title && h(Title, {
      "class": getClassName(this.$props.innerClass, 'title')
    }, [this.$props.title]), h(UL, {
      "class": getClassName(this.$props.innerClass, 'list')
    }, [this.$props.data.map(function (item) {
      var selected = !!_this.$data.currentValue && _this.$data.currentValue.label === item.label;
      return h("li", {
        "key": item.label,
        "class": "" + (selected ? 'active' : '')
      }, [h(Radio, {
        "class": getClassName(_this.$props.innerClass, 'radio'),
        "attrs": {
          "id": _this.$props.componentId + "-" + item.label,
          "name": _this.$props.componentId,
          "value": item.label,
          "type": "radio",
          "checked": selected,
          "show": _this.$props.showRadio
        },
        "on": {
          "change": _this.handleChange
        }
      }), h("label", {
        "class": getClassName(_this.$props.innerClass, 'label'),
        "attrs": {
          "for": _this.$props.componentId + "-" + item.label
        }
      }, [item.label])]);
    })])]);
  },
  methods: {
    setValue: function setValue(value, props) {
      var _this2 = this;
      if (props === void 0) {
        props = this.$props;
      }
      var currentValue = typeof value === 'string' ? SingleRange.parseValue(value, props) : value;
      var performUpdate = function performUpdate() {
        _this2.currentValue = currentValue;
        _this2.updateQueryHandler(currentValue, props);
        _this2.$emit('valueChange', currentValue);
        _this2.$emit('value-change', currentValue);
      };
      checkValueChange(props.componentId, currentValue, props.beforeValueChange, performUpdate);
    },
    updateQueryHandler: function updateQueryHandler(value, props) {
      var customQuery = props.customQuery;
      var query = SingleRange.defaultQuery(value, props);
      if (customQuery) {
        var _ref = customQuery(value, props) || {};
        query = _ref.query;
        var customQueryOptions = getOptionsFromQuery(customQuery(value, props));
        updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
        this.setQueryOptions(props.componentId, customQueryOptions, false);
      }
      this.updateQuery({
        componentId: props.componentId,
        query: query,
        value: value,
        label: props.filterLabel,
        showFilter: props.showFilter,
        URLParams: props.URLParams,
        componentType: componentTypes.singleRange
      });
    },
    handleChange: function handleChange(e) {
      var value = this.$props.value;
      if (value === undefined) {
        this.setValue(e.target.value);
      } else {
        this.$emit('change', e.target.value);
      }
    }
  }
};
SingleRange.parseValue = function (value, props) {
  return props.data.find(function (item) {
    return item.label === value;
  }) || null;
};
SingleRange.defaultQuery = function (value, props) {
  var query = null;
  if (value) {
    var _range;
    query = {
      range: (_range = {}, _range[props.dataField] = {
        gte: value.start,
        lte: value.end,
        boost: 2.0
      }, _range)
    };
  }
  if (query && props.nestedField) {
    return {
      query: {
        nested: {
          path: props.nestedField,
          query: query
        }
      }
    };
  }
  return query;
};
var mapStateToProps = function mapStateToProps(state, props) {
  return {
    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
    componentProps: state.props[props.componentId],
    enableAppbase: state.config.enableAppbase
  };
};
var mapDispatchtoProps = {
  updateQuery: updateQuery,
  setQueryOptions: setQueryOptions,
  setCustomQuery: setCustomQuery
};
var RangeConnected = PreferencesConsumer(ComponentWrapper(connect(mapStateToProps, mapDispatchtoProps)(SingleRange), {
  componentType: componentTypes.singleRange
}));
RangeConnected.name = SingleRange.name;
RangeConnected.defaultQuery = SingleRange.defaultQuery;
RangeConnected.parseValue = SingleRange.parseValue;
RangeConnected.hasInternalComponent = SingleRange.hasInternalComponent;
RangeConnected.install = function (Vue) {
  Vue.component(RangeConnected.name, RangeConnected);
};
// Add componentType for SSR
RangeConnected.componentType = componentTypes.singleRange;

export default RangeConnected;
export { RangeConnected };
