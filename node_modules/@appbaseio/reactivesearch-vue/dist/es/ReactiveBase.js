import configureStore, { Actions, helper } from '@appbaseio/reactivecore';
import '@appbaseio/reactivecore/lib/utils/constants';
import { _ as _taggedTemplateLiteralLoose, a as _extends } from './_rollupPluginBabelHelpers-ded08042.js';
import VueTypes from 'vue-types';
import { isEqual as isEqual$1, transformRequestUsingEndpoint } from '@appbaseio/reactivecore/lib/utils/helper';
import styled from '@appbaseio/vue-emotion';
import { t as types } from './vueTypes-8986b709.js';
import 'redux';
import { c as connect, e as composeThemeObject, X as X_SEARCH_CLIENT } from './index-5509c0bc.js';
import _mergeJSXProps from '@vue/babel-helper-vue-jsx-merge-props';
import { updateAnalyticsConfig } from '@appbaseio/reactivecore/lib/actions/analytics';
import Appbase from 'appbase-js';
import AppbaseAnalytics from '@appbaseio/analytics';
import 'url-search-params-polyfill';

var Provider = {
  name: 'Provider',
  props: {
    store: {
      type: Object,
      required: true,
      validator: function validator(store) {
        if (!store.dispatch && !store.subscribe && !store.getState) {
          throw new Error('[reactivesearch-vue] - store provided is not a valid redux store');
        }
        return true;
      }
    },
    analyticsRef: {
      type: Object,
      required: false
    }
  },
  provide: function provide() {
    return {
      $$store: this.store,
      $analytics: this.analyticsRef
    };
  },
  render: function render(h) {
    if (this.$slots["default"].length > 1) {
      return h('div', this.$slots["default"]);
    }
    return this.$slots["default"][0];
  }
};

var _templateObject;
var Base = {
  functional: true,
  render: function render(h, _ref) {
    var _ref$data$attrs$as = _ref.data.attrs.as,
      T = _ref$data$attrs$as === void 0 ? 'div' : _ref$data$attrs$as,
      props = _ref.data,
      children = _ref.children;
    delete props.attrs.as;
    return h(T, _mergeJSXProps([{}, props]), [children]);
  }
};
var Base$1 = styled(Base)(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n\tfont-family: ", ";\n\tfont-size: ", ";\n\tcolor: ", ";\n\twidth: 100%;\n\n\tinput,\n\tbutton,\n\ttextarea,\n\tselect {\n\t\tfont-family: ", ";\n\t}\n\n\t*,\n\t*:before,\n\t*:after {\n\t\tbox-sizing: border-box;\n\t}\n"])), function (_ref2) {
  var theme = _ref2.theme;
  return theme.typography.fontFamily;
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.typography.fontSize;
}, function (_ref4) {
  var theme = _ref4.theme;
  return theme.colors.textColor;
}, function (_ref5) {
  var theme = _ref5.theme;
  return theme.typography.fontFamily;
});

var setHeaders = Actions.setHeaders,
  setValue = Actions.setValue;
var isEqual = helper.isEqual;
var URLParamsProvider = {
  name: 'URLParamsProvider',
  props: {
    className: types.string,
    headers: types.headers,
    getSearchParams: types.func,
    setSearchParams: types.func,
    as: VueTypes.string.def('div')
  },
  mounted: function mounted() {
    var _this = this;
    this.init();
    window.onpopstate = function () {
      _this.init();
      var activeComponents = Array.from(_this.params.keys());
      // remove inactive components from selectedValues
      Object.keys(_this.currentSelectedState).filter(function (item) {
        return !activeComponents.includes(item);
      }).forEach(function (component) {
        _this.setValue(component, null, undefined, undefined, undefined, undefined, undefined, undefined, 'URL');
      });
      // update active components in selectedValues
      Array.from(_this.params.entries()).forEach(function (item) {
        try {
          var component = item[0],
            value = item[1];
          var _ref = _this.selectedValues[component] || {
              label: component
            },
            label = _ref.label,
            showFilter = _ref.showFilter,
            URLParams = _ref.URLParams;
          _this.setValue(component, JSON.parse(value), label, showFilter, URLParams, undefined, undefined, undefined, 'URL');
        } catch (e) {
          // Do not set value if JSON parsing fails.
          console.error(e);
        }
      });
    };
  },
  watch: {
    $route: function $route() {
      // this ensures the url params change are handled
      // when the url changes, which enables us to
      // make `onpopstate` event handler work with history.pushState updates
      this.checkForURLParamsChange();
    },
    selectedValues: function selectedValues(newVal, oldVal) {
      var _this2 = this;
      if (!isEqual(newVal, oldVal)) {
        this.searchString = this.$props.getSearchParams ? this.$props.getSearchParams() : window.location.search;
        this.params = new URLSearchParams(this.searchString);
        var currentComponents = Object.keys(newVal);
        var urlComponents = Array.from(this.params.keys());
        var shouldPushHistory = false;
        currentComponents.filter(function (component) {
          return newVal[component].URLParams;
        }).forEach(function (component) {
          var selectedValues = newVal[component];
          // prevents empty history pollution on initial load
          if (_this2.hasValidValue(newVal[component]) || _this2.hasValidValue(oldVal[component])) {
            if (selectedValues.URLParams) {
              if (selectedValues.category) {
                var shouldUpdateHistory = _this2.setURL(component, _this2.getValue({
                  category: selectedValues.category,
                  value: selectedValues.value
                }));
                if (shouldUpdateHistory) {
                  shouldPushHistory = true;
                }
              } else {
                var _shouldUpdateHistory = _this2.setURL(component, _this2.getValue(selectedValues.value));
                if (_shouldUpdateHistory) {
                  shouldPushHistory = true;
                }
              }
            } else {
              _this2.params["delete"](component);
              shouldPushHistory = true;
            }
          } else if (!_this2.hasValidValue(newVal[component]) && urlComponents.includes(component)) {
            // doesn't have a valid value, but the url has a (stale) valid value set
            _this2.params["delete"](component);
            shouldPushHistory = true;
          }
        });

        // remove unmounted components
        Object.keys(newVal).filter(function (component) {
          return !currentComponents.includes(component);
        }).forEach(function (component) {
          _this2.params["delete"](component);
          shouldPushHistory = true;
        });
        if (!currentComponents.length) {
          Array.from(this.params.keys()).forEach(function (item) {
            if (_this2.searchComponents && _this2.searchComponents.includes(item)) {
              _this2.params["delete"](item);
              shouldPushHistory = true;
            }
          });
        }
        if (shouldPushHistory) {
          this.pushToHistory();
        }
      }
    },
    headers: function headers(newVal, oldVal) {
      if (!isEqual(oldVal, newVal)) {
        this.setHeaders(newVal);
      }
    }
  },
  methods: {
    init: function init() {
      this.searchString = this.$props.getSearchParams ? this.$props.getSearchParams() : window.location.search;
      this.params = new URLSearchParams(this.searchString);
      this.currentSelectedState = this.selectedValues || {};
    },
    checkForURLParamsChange: function checkForURLParamsChange() {
      // we only compare the search string (window.location.search by default)
      // to see if the route has changed (or) not. This handles the following usecase:
      // search on homepage -> route changes -> search results page with same search query
      if (window) {
        var searchString = this.$props.getSearchParams ? this.$props.getSearchParams() : window.location.search;
        if (searchString !== this.searchString) {
          var event;
          if (typeof Event === 'function') {
            event = new Event('popstate');
          } else {
            // Correctly fire popstate event on IE11 to prevent app crash.
            event = document.createEvent('Event');
            event.initEvent('popstate', true, true);
          }
          window.dispatchEvent(event);
        }
      }
    },
    hasValidValue: function hasValidValue(component) {
      if (!component) return false;
      if (Array.isArray(component.value)) return !!component.value.length;
      return !!component.value;
    },
    getValue: function getValue(value) {
      var _this3 = this;
      if (Array.isArray(value) && value.length) {
        return value.map(function (item) {
          return _this3.getValue(item);
        });
      }
      if (value && typeof value === 'object') {
        // TODO: support for NestedList
        if (value.location) return value;
        if (value.category) return value;
        return value.label || value.key || null;
      }
      return value;
    },
    setURL: function setURL(component, value) {
      if (!value || typeof value === 'string' && value.trim() === '' || Array.isArray(value) && value.length === 0) {
        this.params["delete"](component);
        return true;
      }
      var data = JSON.stringify(value);
      if (data !== this.params.get(component)) {
        this.params.set(component, data);
        return true;
      }
      return false;
    },
    pushToHistory: function pushToHistory() {
      var paramsSting = this.params.toString() ? "?" + this.params.toString() : '';
      var base = window.location.href.split('?')[0];
      var newURL = "" + base + paramsSting;
      if (this.$props.setSearchParams) {
        this.$props.setSearchParams(newURL);
      } else if (window.history.pushState) {
        window.history.pushState({
          path: newURL
        }, '', newURL);
      }
      this.init();
    }
  },
  render: function render() {
    var h = arguments[0];
    var children = this.$slots["default"];
    return h(Base$1, {
      "attrs": {
        "as": this.$props.as
      },
      "class": this.$props.className
    }, [children]);
  }
};
var mapStateToProps = function mapStateToProps(state) {
  return {
    selectedValues: state.selectedValues,
    searchComponents: state.components
  };
};
var mapDispatchtoProps = {
  setHeaders: setHeaders,
  setValue: setValue
};
URLParamsProvider.install = function (Vue) {
  Vue.component(URLParamsProvider.name, URLParamsProvider);
};
var URLParamsProvider$1 = connect(mapStateToProps, mapDispatchtoProps)(URLParamsProvider);

var typography = {
  fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Noto Sans", "Ubuntu", "Droid Sans", "Helvetica Neue", sans-serif',
  fontSize: '16px'
};
var light = {
  typography: typography,
  colors: {
    textColor: '#424242',
    primaryTextColor: '#fff',
    primaryColor: '#0B6AFF',
    titleColor: '#424242',
    alertColor: '#d9534f',
    borderColor: '#595959'
  }
};
var dark = {
  typography: typography,
  colors: {
    textColor: '#fff',
    backgroundColor: '#212121',
    primaryTextColor: '#fff',
    primaryColor: '#2196F3',
    titleColor: '#fff',
    alertColor: '#d9534f',
    borderColor: '#666'
  }
};
function getTheme(preset) {
  if (preset === 'light') {
    return light;
  }
  return dark;
}

var ReactiveBase = {
  name: 'ReactiveBase',
  data: function data() {
    this.state = {
      key: '__REACTIVE_BASE__'
    };
    return this.state;
  },
  created: function created() {
    this.setStore(this.$props);
  },
  mounted: function mounted() {
    var enableAppbase = this.enableAppbase,
      endpoint = this.endpoint;
    if (!enableAppbase && endpoint) {
      console.warn('Warning(ReactiveSearch): The `endpoint` prop works only when `enableAppbase` prop is set to true.');
    }
  },
  props: {
    app: types.string,
    analytics: VueTypes.bool,
    appbaseConfig: types.appbaseConfig,
    enableAppbase: VueTypes.bool.def(false),
    credentials: types.string,
    headers: types.headers,
    queryParams: types.string,
    theme: VueTypes.object.def({}),
    themePreset: VueTypes.string.def('light'),
    type: types.string,
    url: types.string,
    mapKey: types.string,
    initialQueriesSyncTime: types.number,
    className: types.string,
    initialState: VueTypes.object.def({}),
    transformRequest: types.func,
    transformResponse: types.func,
    as: VueTypes.string.def('div'),
    getSearchParams: types.func,
    setSearchParams: types.func,
    mongodb: types.mongodb,
    endpoint: types.endpointConfig,
    preferences: VueTypes.object
  },
  provide: function provide() {
    return {
      theme_reactivesearch: composeThemeObject(getTheme(this.$props.themePreset), this.$props.theme),
      store: this.store,
      $searchPreferences: this.preferences
    };
  },
  watch: {
    app: function app() {
      this.updateState(this.$props);
    },
    url: function url() {
      this.updateState(this.$props);
    },
    type: function type() {
      this.updateState(this.$props);
    },
    credentials: function credentials() {
      this.updateState(this.$props);
    },
    mapKey: function mapKey() {
      this.updateState(this.$props);
    },
    headers: function headers() {
      this.updateState(this.$props);
    },
    appbaseConfig: function appbaseConfig(newVal, oldVal) {
      if (!isEqual$1(newVal, oldVal)) {
        if (this.store) {
          this.store.dispatch(updateAnalyticsConfig(newVal));
        }
      }
    },
    mongodb: function mongodb() {
      this.updateState(this.$props);
    }
  },
  computed: {
    getHeaders: function getHeaders() {
      var _this$$props = this.$props,
        enableAppbase = _this$$props.enableAppbase,
        headers = _this$$props.headers,
        appbaseConfig = _this$$props.appbaseConfig,
        mongodb = _this$$props.mongodb,
        endpoint = _this$$props.endpoint;
      var _ref = appbaseConfig || {},
        enableTelemetry = _ref.enableTelemetry;
      return _extends({}, enableAppbase && !mongodb && _extends({
        'X-Search-Client': X_SEARCH_CLIENT
      }, enableTelemetry === false && {
        'X-Enable-Telemetry': false
      }), headers, enableAppbase && endpoint && endpoint.headers && _extends({}, endpoint.headers));
    }
  },
  methods: {
    updateState: function updateState(props) {
      this.setStore(props);
      this.key = this.state.key + "-0";
    },
    setStore: function setStore(props) {
      var credentials = props.url && props.url.trim() !== '' && !props.credentials ? null : props.credentials;
      var url = props.url && props.url.trim() !== '' ? props.url : '';
      if (props.enableAppbase && props.endpoint) {
        if (props.endpoint.url) {
          // eslint-disable-next-line prefer-destructuring
          url = props.endpoint.url;
        } else {
          throw Error('Error(ReactiveSearch): The `endpoint` prop object requires `url` property.');
        }
      }
      var config = {
        url: url,
        app: props.app,
        credentials: credentials,
        type: props.type ? props.type : '*',
        transformRequest: props.transformRequest,
        transformResponse: props.transformResponse,
        enableAppbase: props.enableAppbase,
        analytics: props.appbaseConfig ? props.appbaseConfig.recordAnalytics : props.analytics,
        analyticsConfig: props.appbaseConfig,
        mongodb: props.mongodb,
        endpoint: props.endpoint
      };
      var queryParams = '';
      if (typeof window !== 'undefined') {
        queryParams = window.location.search;
      } else {
        queryParams = props.queryParams || '';
      }
      var params = new URLSearchParams(queryParams);
      var selectedValues = {};
      var urlValues = {};
      Array.from(params.keys()).forEach(function (key) {
        try {
          var _extends2, _extends3;
          var parsedParams = JSON.parse(params.get(key));
          var selectedValue = {};
          if (parsedParams.value) {
            selectedValue.value = parsedParams.value;
          } else {
            selectedValue.value = parsedParams;
          }
          if (parsedParams.category) selectedValue.category = parsedParams.category;
          selectedValue.reference = 'URL';
          selectedValues = _extends({}, selectedValues, (_extends2 = {}, _extends2[key] = selectedValue, _extends2));
          urlValues = _extends({}, urlValues, (_extends3 = {}, _extends3[key] = selectedValue.value, _extends3));
        } catch (e) {
          // Do not add to selectedValues if JSON parsing fails.
        }
      });
      var themePreset = props.themePreset,
        enableAppbase = props.enableAppbase,
        endpoint = props.endpoint;
      var appbaseRef = Appbase(config);
      appbaseRef.transformRequest = function (request) {
        var modifiedRequest = enableAppbase ? transformRequestUsingEndpoint(request, endpoint) : request;
        if (props.transformRequest) return props.transformRequest(modifiedRequest);
        return modifiedRequest;
      };
      if (this.$props.transformResponse) {
        appbaseRef.transformResponse = this.$props.transformResponse;
      }
      var analyticsInitConfig = {
        url: url && url.replace(/\/\/.*@/, '//'),
        credentials: appbaseRef.credentials,
        // When endpoint prop is used index is not defined, so we use _default
        index: appbaseRef.app || '_default',
        globalCustomEvents: this.$props.appbaseConfig && this.$props.appbaseConfig.customEvents
      };
      try {
        if (this.$props.endpoint && this.$props.endpoint.url) {
          // Remove parts between '//' and first '/' in the url
          analyticsInitConfig.url = this.$props.endpoint.url.replace(/\/\/(.*?)\/.*/, '//$1');
          var headerCredentials = this.$props.endpoint.headers && this.$props.endpoint.headers.Authorization;
          analyticsInitConfig.credentials = headerCredentials && headerCredentials.replace('Basic ', '');
          // Decode the credentials
          analyticsInitConfig.credentials = analyticsInitConfig.credentials && atob(analyticsInitConfig.credentials);
        }
      } catch (e) {
        console.error('Endpoint not set correctly for analytics');
        console.error(e);
      }
      var analyticsRef = null;
      if (config.analytics) {
        analyticsRef = AppbaseAnalytics.init(analyticsInitConfig);
      }
      var initialState = _extends({
        config: _extends({}, config, {
          initialQueriesSyncTime: props.initialQueriesSyncTime,
          initialTimestamp: new Date().getTime(),
          mapKey: props.mapKey,
          themePreset: themePreset
        }),
        appbaseRef: appbaseRef,
        analyticsRef: analyticsRef,
        selectedValues: selectedValues,
        urlValues: urlValues,
        headers: this.getHeaders
      }, this.$props.initialState);
      this.store = configureStore(initialState);
      this.analyticsRef = analyticsRef;
    }
  },
  render: function render() {
    var h = arguments[0];
    var children = this.$slots["default"];
    var _this$$props2 = this.$props,
      style = _this$$props2.style,
      className = _this$$props2.className;
    return h(Provider, {
      "attrs": {
        "store": this.store,
        "analyticsRef": this.analyticsRef
      }
    }, [h(URLParamsProvider$1, {
      "attrs": {
        "as": this.$props.as,
        "headers": this.getHeaders,
        "className": className,
        "getSearchParams": this.getSearchParams,
        "setSearchParams": this.setSearchParams
      },
      "style": style
    }, [children])]);
  }
};
ReactiveBase.install = function (Vue) {
  Vue.component(ReactiveBase.name, ReactiveBase);
};

export default ReactiveBase;
