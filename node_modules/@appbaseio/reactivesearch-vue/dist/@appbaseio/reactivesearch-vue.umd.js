(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
	typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
	(global = global || self, factory(global.ReactiveSearchVue = {}, global.Vue));
}(this, (function (exports, Vue) { 'use strict';

	Vue = Vue && Object.prototype.hasOwnProperty.call(Vue, 'default') ? Vue['default'] : Vue;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}
	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }
	  return target;
	}

	// Inlined version of the `symbol-observable` polyfill
	var $$observable = function () {
	  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
	}();

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var randomString = function randomString() {
	  return Math.random().toString(36).substring(7).split('').join('.');
	};
	var ActionTypes = {
	  INIT: "@@redux/INIT" + randomString(),
	  REPLACE: "@@redux/REPLACE" + randomString(),
	  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
	    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
	  }
	};

	/**
	 * @param {any} obj The object to inspect.
	 * @returns {boolean} True if the argument appears to be a plain object.
	 */
	function isPlainObject(obj) {
	  if (typeof obj !== 'object' || obj === null) return false;
	  var proto = obj;
	  while (Object.getPrototypeOf(proto) !== null) {
	    proto = Object.getPrototypeOf(proto);
	  }
	  return Object.getPrototypeOf(obj) === proto;
	}

	// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
	function miniKindOf(val) {
	  if (val === void 0) return 'undefined';
	  if (val === null) return 'null';
	  var type = typeof val;
	  switch (type) {
	    case 'boolean':
	    case 'string':
	    case 'number':
	    case 'symbol':
	    case 'function':
	      {
	        return type;
	      }
	  }
	  if (Array.isArray(val)) return 'array';
	  if (isDate(val)) return 'date';
	  if (isError(val)) return 'error';
	  var constructorName = ctorName(val);
	  switch (constructorName) {
	    case 'Symbol':
	    case 'Promise':
	    case 'WeakMap':
	    case 'WeakSet':
	    case 'Map':
	    case 'Set':
	      return constructorName;
	  } // other

	  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
	}
	function ctorName(val) {
	  return typeof val.constructor === 'function' ? val.constructor.name : null;
	}
	function isError(val) {
	  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
	}
	function isDate(val) {
	  if (val instanceof Date) return true;
	  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
	}
	function kindOf(val) {
	  var typeOfVal = typeof val;
	  {
	    typeOfVal = miniKindOf(val);
	  }
	  return typeOfVal;
	}

	/**
	 * @deprecated
	 *
	 * **We recommend using the `configureStore` method
	 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
	 *
	 * Redux Toolkit is our recommended approach for writing Redux logic today,
	 * including store setup, reducers, data fetching, and more.
	 *
	 * **For more details, please read this Redux docs page:**
	 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
	 *
	 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
	 * simplifies setup and helps avoid common bugs.
	 *
	 * You should not be using the `redux` core package by itself today, except for learning purposes.
	 * The `createStore` method from the core `redux` package will not be removed, but we encourage
	 * all users to migrate to using Redux Toolkit for all Redux code.
	 *
	 * If you want to use `createStore` without this visual deprecation warning, use
	 * the `legacy_createStore` import instead:
	 *
	 * `import { legacy_createStore as createStore} from 'redux'`
	 *
	 */

	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
	    throw new Error( 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');
	  }
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error( "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
	    }
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	  if (typeof reducer !== 'function') {
	    throw new Error( "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
	  }
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	  /**
	   * This makes a shallow copy of currentListeners so we can use
	   * nextListeners as a temporary list while dispatching.
	   *
	   * This prevents any bugs around consumers calling
	   * subscribe/unsubscribe in the middle of a dispatch.
	   */

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */

	  function getState() {
	    if (isDispatching) {
	      throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
	    }
	    return currentState;
	  }
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */

	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error( "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
	    }
	    if (isDispatching) {
	      throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
	    }
	    var isSubscribed = true;
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	      if (isDispatching) {
	        throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
	      }
	      isSubscribed = false;
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	      currentListeners = null;
	    };
	  }
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */

	  function dispatch(action) {
	    if (!isPlainObject(action)) {
	      throw new Error( "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
	    }
	    if (typeof action.type === 'undefined') {
	      throw new Error( 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
	    }
	    if (isDispatching) {
	      throw new Error( 'Reducers may not dispatch actions.');
	    }
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }
	    return action;
	  }
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */

	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error( "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
	    }
	    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
	    // Any reducers that existed in both the new and old rootReducer
	    // will receive the previous state. This effectively populates
	    // the new state tree with any relevant data from the old one.

	    dispatch({
	      type: ActionTypes.REPLACE
	    });
	  }
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */

	  function observable() {
	    var _ref;
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object' || observer === null) {
	          throw new Error( "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
	        }
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return {
	          unsubscribe: unsubscribe
	        };
	      }
	    }, _ref[$$observable] = function () {
	      return this;
	    }, _ref;
	  } // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.

	  dispatch({
	    type: ActionTypes.INIT
	  });
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[$$observable] = observable, _ref2;
	}
	/**
	 * Creates a Redux store that holds the state tree.
	 *
	 * **We recommend using `configureStore` from the
	 * `@reduxjs/toolkit` package**, which replaces `createStore`:
	 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
	 *
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */

	var legacy_createStore = createStore;

	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */

	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	  } catch (e) {} // eslint-disable-line no-empty
	}

	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	  if (!isPlainObject(inputState)) {
	    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
	  }
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
	  });
	  unexpectedKeys.forEach(function (key) {
	    unexpectedKeyCache[key] = true;
	  });
	  if (action && action.type === ActionTypes.REPLACE) return;
	  if (unexpectedKeys.length > 0) {
	    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
	  }
	}
	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, {
	      type: ActionTypes.INIT
	    });
	    if (typeof initialState === 'undefined') {
	      throw new Error( "The slice reducer for key \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
	    }
	    if (typeof reducer(undefined, {
	      type: ActionTypes.PROBE_UNKNOWN_ACTION()
	    }) === 'undefined') {
	      throw new Error( "The slice reducer for key \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle '" + ActionTypes.INIT + "' or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
	    }
	  });
	}
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */

	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    {
	      if (typeof reducers[key] === 'undefined') {
	        warning("No reducer provided for key \"" + key + "\"");
	      }
	    }
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
	  // keys multiple times.

	  var unexpectedKeyCache;
	  {
	    unexpectedKeyCache = {};
	  }
	  var shapeAssertionError;
	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }
	  return function combination(state, action) {
	    if (state === void 0) {
	      state = {};
	    }
	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }
	    {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
	      if (warningMessage) {
	        warning(warningMessage);
	      }
	    }
	    var hasChanged = false;
	    var nextState = {};
	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
	      var _key = finalReducerKeys[_i];
	      var reducer = finalReducers[_key];
	      var previousStateForKey = state[_key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var actionType = action && action.type;
	        throw new Error( "When called with an action of type " + (actionType ? "\"" + String(actionType) + "\"" : '(unknown type)') + ", the slice reducer for key \"" + _key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.");
	      }
	      nextState[_key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
	    return hasChanged ? nextState : state;
	  };
	}
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(this, arguments));
	  };
	}
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass an action creator as the first argument,
	 * and get a dispatch wrapped function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */

	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error( "bindActionCreators expected an object or a function, but instead received: '" + kindOf(actionCreators) + "'. " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
	  }
	  var boundActionCreators = {};
	  for (var key in actionCreators) {
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	function compose() {
	  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(void 0, arguments));
	    };
	  });
	}

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */

	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	  return function (createStore) {
	    return function () {
	      var store = createStore.apply(void 0, arguments);
	      var _dispatch = function dispatch() {
	        throw new Error( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
	      };
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch() {
	          return _dispatch.apply(void 0, arguments);
	        }
	      };
	      var chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = compose.apply(void 0, chain)(store.dispatch);
	      return _objectSpread2(_objectSpread2({}, store), {}, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

	/*
	 * This is a dummy function to check if the function name has been altered by minification.
	 * If the function has been minified and NODE_ENV !== 'production', warn the user.
	 */

	function isCrushed() {}
	if ( typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
	}

	var redux = /*#__PURE__*/Object.freeze({
		__proto__: null,
		__DO_NOT_USE__ActionTypes: ActionTypes,
		applyMiddleware: applyMiddleware,
		bindActionCreators: bindActionCreators,
		combineReducers: combineReducers,
		compose: compose,
		createStore: createStore,
		legacy_createStore: legacy_createStore
	});

	/** A function that accepts a potential "extra argument" value to be injected later,
	 * and returns an instance of the thunk middleware that uses that value
	 */
	function createThunkMiddleware(extraArgument) {
	  // Standard Redux middleware definition pattern:
	  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
	  var middleware = function middleware(_ref) {
	    var dispatch = _ref.dispatch,
	      getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // The thunk middleware looks for any functions that were passed to `store.dispatch`.
	        // If this "action" is really a function, call it and return the result.
	        if (typeof action === 'function') {
	          // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
	          return action(dispatch, getState, extraArgument);
	        } // Otherwise, pass the action down the middleware chain as usual

	        return next(action);
	      };
	    };
	  };
	  return middleware;
	}
	var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
	// with whatever "extra arg" they want to inject into their thunks

	thunk.withExtraArgument = createThunkMiddleware;

	var constants = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var ADD_COMPONENT = exports.ADD_COMPONENT = 'ADD_COMPONENT';
	  var REMOVE_COMPONENT = exports.REMOVE_COMPONENT = 'REMOVE_COMPONENT';
	  var WATCH_COMPONENT = exports.WATCH_COMPONENT = 'WATCH_COMPONENT';
	  var SET_QUERY = exports.SET_QUERY = 'SET_QUERY';
	  var SET_APPBASE_QUERY = exports.SET_APPBASE_QUERY = 'SET_APPBASE_QUERY';
	  var SET_QUERY_OPTIONS = exports.SET_QUERY_OPTIONS = 'SET_QUERY_OPTIONS';
	  var EXECUTE_QUERY = exports.EXECUTE_QUERY = 'EXECUTE_QUERY';
	  var UPDATE_HITS = exports.UPDATE_HITS = 'UPDATE_HITS';
	  var UPDATE_AGGS = exports.UPDATE_AGGS = 'UPDATE_AGGS';
	  var UPDATE_COMPOSITE_AGGS = exports.UPDATE_COMPOSITE_AGGS = 'UPDATE_COMPOSITE_AGGS';
	  var ADD_CONFIG = exports.ADD_CONFIG = 'ADD_CONFIG';
	  var UPDATE_CONFIG = exports.UPDATE_CONFIG = 'UPDATE_CONFIG';
	  var ADD_APPBASE_REF = exports.ADD_APPBASE_REF = 'ADD_APPBASE_REF';
	  var ADD_ANALYTICS_REF = exports.ADD_ANALYTICS_REF = 'ADD_ANALYTICS_REF';
	  var LOG_QUERY = exports.LOG_QUERY = 'LOG_QUERY';
	  var LOG_COMBINED_QUERY = exports.LOG_COMBINED_QUERY = 'LOG_COMBINED_QUERY';
	  var SET_INTERNAL_VALUE = exports.SET_INTERNAL_VALUE = 'SET_INTERNAL_VALUE';
	  var PATCH_VALUE = exports.PATCH_VALUE = 'PATCH_VALUE';
	  var CLEAR_VALUES = exports.CLEAR_VALUES = 'CLEAR_VALUES';
	  var SET_LOADING = exports.SET_LOADING = 'SET_LOADING';
	  var SET_ERROR = exports.SET_ERROR = 'SET_ERROR';
	  var SET_TIMESTAMP = exports.SET_TIMESTAMP = 'SET_TIMESTAMP';
	  var SET_HEADERS = exports.SET_HEADERS = 'SET_HEADERS';
	  var SET_MAP_DATA = exports.SET_MAP_DATA = 'SET_MAP_DATA';
	  var SET_MAP_RESULTS = exports.SET_MAP_RESULTS = 'SET_MAP_RESULTS';
	  var SET_QUERY_LISTENER = exports.SET_QUERY_LISTENER = 'SET_QUERY_LISTENER';
	  var STORE_KEY = exports.STORE_KEY = '__REACTIVESEARCH__';
	  var SET_SEARCH_ID = exports.SET_SEARCH_ID = 'SET_SEARCH_ID';
	  var SET_PROMOTED_RESULTS = exports.SET_PROMOTED_RESULTS = 'SET_PROMOTED_RESULTS';
	  var SET_DEFAULT_QUERY = exports.SET_DEFAULT_QUERY = 'SET_DEFAULT_QUERY';
	  var SET_CUSTOM_QUERY = exports.SET_CUSTOM_QUERY = 'SET_CUSTOM_QUERY';
	  var SET_CUSTOM_HIGHLIGHT_OPTIONS = exports.SET_CUSTOM_HIGHLIGHT_OPTIONS = 'SET_CUSTOM_HIGHLIGHT_OPTIONS';
	  var SET_CUSTOM_DATA = exports.SET_CUSTOM_DATA = 'SET_CUSTOM_DATA';
	  var SET_APPLIED_SETTINGS = exports.SET_APPLIED_SETTINGS = 'SET_APPLIED_SETTINGS';
	  var SET_PROPS = exports.SET_PROPS = 'SET_PROPS';
	  var UPDATE_PROPS = exports.UPDATE_PROPS = 'UPDATE_PROPS';
	  var REMOVE_PROPS = exports.REMOVE_PROPS = 'REMOVE_PROPS';
	  var SET_SUGGESTIONS_SEARCH_VALUE = exports.SET_SUGGESTIONS_SEARCH_VALUE = 'SET_SUGGESTIONS_SEARCH_VALUE';
	  var CLEAR_SUGGESTIONS_SEARCH_VALUE = exports.CLEAR_SUGGESTIONS_SEARCH_VALUE = 'CLEAR_SUGGESTIONS_SEARCH_VALUE';
	  var SET_SUGGESTIONS_SEARCH_ID = exports.SET_SUGGESTIONS_SEARCH_ID = 'SET_SUGGESTIONS_SEARCH_ID';
	  var UPDATE_ANALYTICS_CONFIG = exports.UPDATE_ANALYTICS_CONFIG = 'UPDATE_ANALYTICS_CONFIG';
	  var SET_RAW_DATA = exports.SET_RAW_DATA = 'SET_RAW_DATA';
	  var SET_POPULAR_SUGGESTIONS = exports.SET_POPULAR_SUGGESTIONS = 'SET_POPULAR_SUGGESTIONS';
	  var SET_DEFAULT_POPULAR_SUGGESTIONS = exports.SET_DEFAULT_POPULAR_SUGGESTIONS = 'SET_DEFAULT_POPULAR_SUGGESTIONS';
	  var SET_QUERY_TO_HITS = exports.SET_QUERY_TO_HITS = 'SET_QUERY_TO_HITS';
	  var RECENT_SEARCHES_SUCCESS = exports.RECENT_SEARCHES_SUCCESS = 'RECENT_SEARCHES_SUCCESS';
	  var RECENT_SEARCHES_ERROR = exports.RECENT_SEARCHES_ERROR = 'RECENT_SEARCHES_ERROR';
	  var SET_VALUE = exports.SET_VALUE = 'SET_VALUE';
	  var SET_VALUES = exports.SET_VALUES = 'SET_VALUES';
	  var RESET_TO_DEFAULT = exports.RESET_TO_DEFAULT = 'RESET_TO_DEFAULT';
	  var SET_GOOGLE_MAP_SCRIPT_LOADING = exports.SET_GOOGLE_MAP_SCRIPT_LOADING = 'SET_GOOGLE_MAP_SCRIPT_LOADING';
	  var SET_GOOGLE_MAP_SCRIPT_LOADED = exports.SET_GOOGLE_MAP_SCRIPT_LOADED = 'SET_GOOGLE_MAP_SCRIPT_LOADED';
	  var SET_GOOGLE_MAP_SCRIPT_ERROR = exports.SET_GOOGLE_MAP_SCRIPT_ERROR = 'SET_GOOGLE_MAP_SCRIPT_ERROR';
	  var SET_REGISTERED_COMPONENT_TIMESTAMP = exports.SET_REGISTERED_COMPONENT_TIMESTAMP = 'SET_REGISTERED_COMPONENT_TIMESTAMP';
	  var REMOVE_REGISTERED_COMPONENT_TIMESTAMP = exports.REMOVE_REGISTERED_COMPONENT_TIMESTAMP = 'REMOVE_REGISTERED_COMPONENT_TIMESTAMP';
	});
	unwrapExports(constants);
	var constants_1 = constants.ADD_COMPONENT;
	var constants_2 = constants.REMOVE_COMPONENT;
	var constants_3 = constants.WATCH_COMPONENT;
	var constants_4 = constants.SET_QUERY;
	var constants_5 = constants.SET_APPBASE_QUERY;
	var constants_6 = constants.SET_QUERY_OPTIONS;
	var constants_7 = constants.EXECUTE_QUERY;
	var constants_8 = constants.UPDATE_HITS;
	var constants_9 = constants.UPDATE_AGGS;
	var constants_10 = constants.UPDATE_COMPOSITE_AGGS;
	var constants_11 = constants.ADD_CONFIG;
	var constants_12 = constants.UPDATE_CONFIG;
	var constants_13 = constants.ADD_APPBASE_REF;
	var constants_14 = constants.ADD_ANALYTICS_REF;
	var constants_15 = constants.LOG_QUERY;
	var constants_16 = constants.LOG_COMBINED_QUERY;
	var constants_17 = constants.SET_INTERNAL_VALUE;
	var constants_18 = constants.PATCH_VALUE;
	var constants_19 = constants.CLEAR_VALUES;
	var constants_20 = constants.SET_LOADING;
	var constants_21 = constants.SET_ERROR;
	var constants_22 = constants.SET_TIMESTAMP;
	var constants_23 = constants.SET_HEADERS;
	var constants_24 = constants.SET_MAP_DATA;
	var constants_25 = constants.SET_MAP_RESULTS;
	var constants_26 = constants.SET_QUERY_LISTENER;
	var constants_27 = constants.STORE_KEY;
	var constants_28 = constants.SET_SEARCH_ID;
	var constants_29 = constants.SET_PROMOTED_RESULTS;
	var constants_30 = constants.SET_DEFAULT_QUERY;
	var constants_31 = constants.SET_CUSTOM_QUERY;
	var constants_32 = constants.SET_CUSTOM_HIGHLIGHT_OPTIONS;
	var constants_33 = constants.SET_CUSTOM_DATA;
	var constants_34 = constants.SET_APPLIED_SETTINGS;
	var constants_35 = constants.SET_PROPS;
	var constants_36 = constants.UPDATE_PROPS;
	var constants_37 = constants.REMOVE_PROPS;
	var constants_38 = constants.SET_SUGGESTIONS_SEARCH_VALUE;
	var constants_39 = constants.CLEAR_SUGGESTIONS_SEARCH_VALUE;
	var constants_40 = constants.SET_SUGGESTIONS_SEARCH_ID;
	var constants_41 = constants.UPDATE_ANALYTICS_CONFIG;
	var constants_42 = constants.SET_RAW_DATA;
	var constants_43 = constants.SET_POPULAR_SUGGESTIONS;
	var constants_44 = constants.SET_DEFAULT_POPULAR_SUGGESTIONS;
	var constants_45 = constants.SET_QUERY_TO_HITS;
	var constants_46 = constants.RECENT_SEARCHES_SUCCESS;
	var constants_47 = constants.RECENT_SEARCHES_ERROR;
	var constants_48 = constants.SET_VALUE;
	var constants_49 = constants.SET_VALUES;
	var constants_50 = constants.RESET_TO_DEFAULT;
	var constants_51 = constants.SET_GOOGLE_MAP_SCRIPT_LOADING;
	var constants_52 = constants.SET_GOOGLE_MAP_SCRIPT_LOADED;
	var constants_53 = constants.SET_GOOGLE_MAP_SCRIPT_ERROR;
	var constants_54 = constants.SET_REGISTERED_COMPONENT_TIMESTAMP;
	var constants_55 = constants.REMOVE_REGISTERED_COMPONENT_TIMESTAMP;

	var componentsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = componentsReducer;
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function componentsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var action = arguments[1];
	    if (action.type === constants.ADD_COMPONENT) {
	      return [].concat(_toConsumableArray(state), [action.component]);
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      return state.filter(function (element) {
	        return element !== action.component;
	      });
	    }
	    return state;
	  }
	});
	unwrapExports(componentsReducer_1);

	var watchManReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = watchManReducer;
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function getWatchList(depTree) {
	    var list = Object.values(depTree);
	    var components = [];
	    list.forEach(function (item) {
	      if (typeof item === 'string') {
	        components.push(item);
	      } else if (Array.isArray(item)) {
	        item.forEach(function (component) {
	          if (typeof component === 'string') {
	            components.push(component);
	          } else {
	            components.push.apply(components, _toConsumableArray(getWatchList(component)));
	          }
	        });
	      } else if (typeof item === 'object' && item !== null) {
	        components.push.apply(components, _toConsumableArray(getWatchList(item)));
	      }
	    });
	    return components.filter(function (value, index, array) {
	      return array.indexOf(value) === index;
	    });
	  }
	  function watchManReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.WATCH_COMPONENT) {
	      var watchList = getWatchList(action.react);
	      var newState = _extends({}, state);
	      Object.keys(newState).forEach(function (key) {
	        newState[key] = newState[key].filter(function (value) {
	          return value !== action.component;
	        });
	      });
	      watchList.forEach(function (item) {
	        if (Array.isArray(newState[item])) {
	          newState[item] = [].concat(_toConsumableArray(newState[item]), [action.component]);
	        } else {
	          newState[item] = [action.component];
	        }
	      });
	      return newState;
	    }
	    return state;
	  }
	});
	unwrapExports(watchManReducer_1);

	var dependencyTreeReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = dependencyTreeReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function dependencyTreeReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.WATCH_COMPONENT) {
	      return _extends({}, state, _defineProperty({}, action.component, action.react));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	var dependencyTreeReducer = unwrapExports(dependencyTreeReducer_1);

	var queryReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = queryReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function queryReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_QUERY) {
	      return _extends({}, state, _defineProperty({}, action.component, action.query));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	var queryReducer = unwrapExports(queryReducer_1);

	var appbaseQueryReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = appbaseQueryReducer;
	  function appbaseQueryReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_APPBASE_QUERY) {
	      return _extends({}, state, action.query);
	    }
	    return state;
	  }
	});
	unwrapExports(appbaseQueryReducer_1);

	var queryOptionsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = queryOptionsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function queryOptionsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_QUERY_OPTIONS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.options));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	var queryOptionsReducer = unwrapExports(queryOptionsReducer_1);

	var constants$1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var componentTypes = exports.componentTypes = {
	    reactiveList: 'REACTIVELIST',
	    dataSearch: 'DATASEARCH',
	    categorySearch: 'CATEGORYSEARCH',
	    searchBox: 'SEARCHBOX',
	    singleList: 'SINGLELIST',
	    multiList: 'MULTILIST',
	    singleDataList: 'SINGLEDATALIST',
	    tabDataList: 'TABDATALIST',
	    singleDropdownList: 'SINGLEDROPDOWNLIST',
	    multiDataList: 'MULTIDATALIST',
	    multiDropdownList: 'MULTIDROPDOWNLIST',
	    singleDropdownRange: 'SINGLEDROPDOWNRANGE',
	    treeList: 'TREELIST',
	    numberBox: 'NUMBERBOX',
	    tagCloud: 'TAGCLOUD',
	    toggleButton: 'TOGGLEBUTTON',
	    reactiveComponent: 'REACTIVECOMPONENT',
	    datePicker: 'DATEPICKER',
	    dateRange: 'DATERANGE',
	    dynamicRangeSlider: 'DYNAMICRANGESLIDER',
	    multiDropdownRange: 'MULTIDROPDOWNRANGE',
	    singleRange: 'SINGLERANGE',
	    multiRange: 'MULTIRANGE',
	    rangeSlider: 'RANGESLIDER',
	    ratingsFilter: 'RATINGSFILTER',
	    rangeInput: 'RANGEINPUT',
	    geoDistanceDropdown: 'GEO_DISTANCE_DROPDOWN',
	    geoDistanceSlider: 'GEO_DISTANCE_SLIDER',
	    reactiveMap: 'REACTIVE_MAP',
	    reactiveChart: 'REACTIVE_CHART'
	  };
	  var queryTypes = exports.queryTypes = {
	    search: 'search',
	    term: 'term',
	    range: 'range',
	    geo: 'geo',
	    suggestion: 'suggestion'
	  };
	  var validProps = exports.validProps = ['type', 'componentType', 'aggregationField', 'aggregationSize', 'distinctField', 'distinctFieldConfig', 'index', 'aggregations', 'dataField', 'includeFields', 'excludeFields', 'size', 'from', 'sortBy', 'sortOptions', 'pagination', 'autoFocus', 'autosuggest', 'debounce', 'defaultValue', 'defaultSuggestions', 'fieldWeights', 'filterLabel', 'fuzziness', 'highlight', 'highlightConfig', 'highlightField', 'nestedField', 'placeholder', 'queryFormat', 'searchOperators', 'enableSynonyms', 'enableQuerySuggestions', 'queryString', 'categoryField', 'strictSelection', 'selectAllLabel', 'showCheckbox', 'showFilter', 'showSearch', 'showCount', 'showLoadMore', 'loadMoreLabel', 'showMissing', 'missingLabel', 'data', 'showRadio', 'multiSelect', 'includeNullValues', 'interval', 'showHistogram', 'snap', 'stepValue', 'range', 'showSlider', 'parseDate', 'calendarInterval', 'unit', 'enablePopularSuggestions', 'enableRecentSuggestions', 'popularSuggestionsConfig', 'recentSuggestionsConfig', 'indexSuggestionsConfig', 'featuredSuggestionsConfig', 'enablePredictiveSuggestions', 'applyStopwords', 'customStopwords', 'enableIndexSuggestions', 'enableFeaturedSuggestions', 'searchboxId', 'endpoint', 'enableEndpointSuggestions'];
	  var CLEAR_ALL = exports.CLEAR_ALL = {
	    NEVER: 'never',
	    ALWAYS: 'always',
	    DEFAULT: 'default'
	  };
	  var SEARCH_COMPONENTS_MODES = exports.SEARCH_COMPONENTS_MODES = {
	    SELECT: 'select',
	    TAG: 'tag'
	  };
	  var TREELIST_VALUES_PATH_SEPARATOR = exports.TREELIST_VALUES_PATH_SEPARATOR = '◐◑◒◓';
	});
	unwrapExports(constants$1);
	var constants_1$1 = constants$1.componentTypes;
	var constants_2$1 = constants$1.queryTypes;
	var constants_3$1 = constants$1.validProps;
	var constants_4$1 = constants$1.CLEAR_ALL;
	var constants_5$1 = constants$1.SEARCH_COMPONENTS_MODES;
	var constants_6$1 = constants$1.TREELIST_VALUES_PATH_SEPARATOR;

	var analytics = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.parseCustomEvents = exports.parseRangeObject = exports.parseFilterValue = exports.rangeObjectComponents = exports.rangeComponents = exports.filterComponents = exports.defaultAnalyticsConfig = undefined;
	  var _slicedToArray = function () {
	    function sliceIterator(arr, i) {
	      var _arr = [];
	      var _n = true;
	      var _d = false;
	      var _e = undefined;
	      try {
	        for (var _i = arr[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	          _arr.push(_s.value);
	          if (i && _arr.length === i) break;
	        }
	      } catch (err) {
	        _d = true;
	        _e = err;
	      } finally {
	        try {
	          if (!_n && _i["return"]) _i["return"]();
	        } finally {
	          if (_d) throw _e;
	        }
	      }
	      return _arr;
	    }
	    return function (arr, i) {
	      if (Array.isArray(arr)) {
	        return arr;
	      } else if ((typeof Symbol === 'function' ? Symbol.iterator : '@@iterator') in Object(arr)) {
	        return sliceIterator(arr, i);
	      } else {
	        throw new TypeError("Invalid attempt to destructure non-iterable instance");
	      }
	    };
	  }();
	  var filterComponents = [constants$1.componentTypes.numberBox, constants$1.componentTypes.tagCloud, constants$1.componentTypes.toggleButton, constants$1.componentTypes.datePicker, constants$1.componentTypes.dateRange, constants$1.componentTypes.multiDataList, constants$1.componentTypes.multiDropdownList, constants$1.componentTypes.multiList, constants$1.componentTypes.singleDataList, constants$1.componentTypes.singleDropdownList, constants$1.componentTypes.singleList, constants$1.componentTypes.dynamicRangeSlider, constants$1.componentTypes.multiDropdownRange, constants$1.componentTypes.multiRange, constants$1.componentTypes.rangeSlider, constants$1.componentTypes.ratingsFilter, constants$1.componentTypes.singleDropdownRange, constants$1.componentTypes.singleRange, constants$1.componentTypes.treeList];
	  var rangeComponents = [constants$1.componentTypes.dateRange, constants$1.componentTypes.dynamicRangeSlider, constants$1.componentTypes.rangeSlider, constants$1.componentTypes.rangeInput, constants$1.componentTypes.ratingsFilter];
	  var rangeObjectComponents = [constants$1.componentTypes.singleRange, constants$1.componentTypes.singleDropdownRange, constants$1.componentTypes.multiRange, constants$1.componentTypes.multiDropdownRange];
	  function parseRangeObject(filterKey, rangeObject) {
	    return filterKey + '=' + rangeObject.start + '~' + rangeObject.end;
	  }
	  function parseFilterValue(componentId, componentValues) {
	    var label = componentValues.label,
	      value = componentValues.value,
	      componentType = componentValues.componentType;
	    var filterKey = label || componentId;
	    if (rangeComponents.includes(componentType)) {
	      return filterKey + '=' + value[0] + '~' + value[1];
	    } else if (rangeObjectComponents.includes(componentType)) {
	      if (Array.isArray(value)) {
	        return value.map(function (item) {
	          return parseRangeObject(filterKey, item);
	        }).join();
	      }
	      return parseRangeObject(filterKey, value);
	    } else if (Array.isArray(value)) {
	      var isObject = typeof value[0] === 'object' && value[0] !== null;
	      return isObject ? value.map(function (item) {
	        return filterKey + '=' + item.value;
	      }).join() : value.map(function (item) {
	        return filterKey + '=' + item;
	      }).join();
	    }
	    return filterKey + '=' + value;
	  }
	  function getFilterString(selectedValues) {
	    if (selectedValues && Object.keys(selectedValues).length) {
	      return Object.entries(selectedValues).filter(function (_ref) {
	        var _ref2 = _slicedToArray(_ref, 2),
	          componentValues = _ref2[1];
	        return filterComponents.includes(componentValues.componentType) && (componentValues.value && componentValues.value.length || componentValues.value && componentValues.value.start || componentValues.value && componentValues.value.end);
	      }).map(function (_ref3) {
	        var _ref4 = _slicedToArray(_ref3, 2),
	          componentId = _ref4[0],
	          componentValues = _ref4[1];
	        return parseFilterValue(componentId, componentValues);
	      }).join();
	    }
	    return null;
	  }
	  function parseCustomEvents(customEvents) {
	    var finalStr = '';
	    Object.keys(customEvents).forEach(function (key, index) {
	      finalStr += key + '=' + customEvents[key];
	      if (index < Object.keys(customEvents).length - 1) {
	        finalStr += ',';
	      }
	    });
	    return finalStr;
	  }
	  var defaultAnalyticsConfig = exports.defaultAnalyticsConfig = {
	    emptyQuery: true,
	    suggestionAnalytics: true,
	    userId: null,
	    customEvents: null,
	    enableQueryRules: true
	  };
	  exports.filterComponents = filterComponents;
	  exports.rangeComponents = rangeComponents;
	  exports.rangeObjectComponents = rangeObjectComponents;
	  exports.parseFilterValue = parseFilterValue;
	  exports.parseRangeObject = parseRangeObject;
	  exports.parseCustomEvents = parseCustomEvents;
	  exports["default"] = getFilterString;
	});
	unwrapExports(analytics);
	var analytics_1 = analytics.parseCustomEvents;
	var analytics_2 = analytics.parseRangeObject;
	var analytics_3 = analytics.parseFilterValue;
	var analytics_4 = analytics.rangeObjectComponents;
	var analytics_5 = analytics.rangeComponents;
	var analytics_6 = analytics.filterComponents;
	var analytics_7 = analytics.defaultAnalyticsConfig;

	var configReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = configReducer;
	  function configReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	      analyticsConfig: analytics.defaultAnalyticsConfig,
	      lock: false
	    };
	    var action = arguments[1];
	    if (action.type === constants.ADD_CONFIG) {
	      return _extends({}, state, {
	        analyticsConfig: _extends({}, analytics.defaultAnalyticsConfig, action.analyticsConfig)
	      });
	    } else if (action.type === constants.UPDATE_ANALYTICS_CONFIG) {
	      return _extends({}, state, {
	        analyticsConfig: _extends({}, state.analyticsConfig, action.analyticsConfig)
	      });
	    } else if (action.type === constants.UPDATE_CONFIG) {
	      return _extends({}, state, action.config);
	    }
	    return state;
	  }
	});
	unwrapExports(configReducer_1);

	var appbaseRefReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = appbaseRefReducer;
	  function appbaseRefReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.ADD_APPBASE_REF) {
	      return action.appbaseRef;
	    }
	    return state;
	  }
	});
	unwrapExports(appbaseRefReducer_1);

	var hitsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = hitsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function hitsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.UPDATE_HITS) {
	      if (action.append) {
	        return _extends({}, state, _defineProperty({}, action.component, {
	          hits: [].concat(_toConsumableArray(state[action.component].hits), _toConsumableArray(action.hits)),
	          total: action.total,
	          time: action.time,
	          hidden: action.hidden || 0
	        }));
	      }
	      return _extends({}, state, _defineProperty({}, action.component, {
	        hits: action.hits,
	        total: action.total,
	        time: action.time,
	        hidden: action.hidden || 0
	      }));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(hitsReducer_1);

	var logsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = logsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function logsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.LOG_QUERY) {
	      return _extends({}, state, _defineProperty({}, action.component, action.query));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(logsReducer_1);

	var combinedLogsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = combinedLogsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function combinedLogsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.LOG_COMBINED_QUERY) {
	      return _extends({}, state, _defineProperty({}, action.component, action.query));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(combinedLogsReducer_1);

	var valueReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = valueReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function valueReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    switch (action.type) {
	      case constants.SET_VALUE:
	        {
	          var newState = {};
	          Object.keys(action.componentsToReset || {}).forEach(function (id) {
	            newState[id] = _extends({}, state[id], {
	              value: action.componentsToReset[id]
	            });
	          });
	          return _extends({}, state, newState, _defineProperty({}, action.component, {
	            value: action.value,
	            label: action.label || action.component,
	            showFilter: action.showFilter,
	            URLParams: action.URLParams,
	            componentType: action.componentType,
	            category: action.category,
	            meta: action.meta,
	            reference: action.reference
	          }));
	        }
	      case constants.SET_VALUES:
	        {
	          var componentKeys = action.componentsValues ? Object.keys(action.componentsValues) : [];
	          if (componentKeys.length) {
	            var _newState = {};
	            componentKeys.forEach(function (component) {
	              var _action$componentsVal = action.componentsValues[component],
	                value = _action$componentsVal.value,
	                rest = _objectWithoutProperties(_action$componentsVal, ['value']);
	              _newState[component] = _extends({}, state[component], {
	                value: value
	              }, rest);
	            });
	            return _extends({}, state, _newState);
	          }
	          return state;
	        }
	      case constants.PATCH_VALUE:
	        return _extends({}, state, _defineProperty({}, action.component, _extends({}, state[action.component], action.payload)));
	      case constants.CLEAR_VALUES:
	        {
	          var nextState = {};
	          if (action.resetValues) {
	            Object.keys(action.resetValues).forEach(function (componentId) {
	              nextState[componentId] = _extends({}, state[componentId], {
	                value: action.resetValues[componentId]
	              });
	            });
	          }
	          if (Array.isArray(action.clearAllBlacklistComponents)) {
	            Object.keys(state).forEach(function (componentId) {
	              if (action.clearAllBlacklistComponents.includes(componentId)) {
	                nextState[componentId] = state[componentId];
	              }
	            });
	          }
	          return nextState;
	        }
	      case constants.REMOVE_COMPONENT:
	        {
	          var del = state[action.component],
	            obj = _objectWithoutProperties(state, [action.component]);
	          return obj;
	        }
	      case constants.RESET_TO_DEFAULT:
	        return _extends({}, state, action.defaultValues);
	      default:
	        return state;
	    }
	  }
	});
	var valueReducer = unwrapExports(valueReducer_1);

	var internalValueReducer = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = valueReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function valueReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    switch (action.type) {
	      case constants.SET_INTERNAL_VALUE:
	        return _extends({}, state, _defineProperty({}, action.component, {
	          value: action.value,
	          componentType: action.componentType,
	          category: action.category,
	          meta: action.meta
	        }));
	      case constants.CLEAR_VALUES:
	        {
	          var nextState = {};
	          if (action.resetValues) {
	            Object.keys(action.resetValues).forEach(function (componentId) {
	              nextState[componentId] = _extends({}, state[componentId], {
	                value: action.resetValues[componentId]
	              });
	            });
	          }
	          if (Array.isArray(action.clearAllBlacklistComponents)) {
	            Object.keys(state).forEach(function (componentId) {
	              if (action.clearAllBlacklistComponents.includes(componentId)) {
	                nextState[componentId] = state[componentId];
	              }
	            });
	          }
	          return nextState;
	        }
	      case constants.RESET_TO_DEFAULT:
	        return _extends({}, state, action.defaultValues);
	      case constants.REMOVE_COMPONENT:
	        {
	          var del = state[action.component],
	            obj = _objectWithoutProperties(state, [action.component]);
	          return obj;
	        }
	      default:
	        return state;
	    }
	  }
	});
	unwrapExports(internalValueReducer);

	var loadingReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = loadingReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function loadingReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_LOADING) {
	      var _extends2;
	      var requestCount = state[action.component + '_active'] || 0;
	      if (action.isLoading) {
	        requestCount += 1;
	      } else if (requestCount) {
	        requestCount -= 1;
	      }
	      return _extends({}, state, (_extends2 = {}, _defineProperty(_extends2, action.component, action.isLoading), _defineProperty(_extends2, action.component + '_active', requestCount), _extends2), action.isLoading ? _defineProperty({}, action.component + '_timestamp', new Date().getTime()) : null);
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        del2 = state[action.component + '_active'],
	        obj = _objectWithoutProperties(state, [action.component, action.component + '_active']);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(loadingReducer_1);

	var errorReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = errorReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function errorReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_ERROR) {
	      return _extends({}, state, _defineProperty({}, action.component, action.error));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(errorReducer_1);

	var timestampReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = timestampReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function timestampReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_TIMESTAMP) {
	      return _extends({}, state, _defineProperty({}, action.component, action.timestamp));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(timestampReducer_1);

	var headersReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = headersReducer;
	  function headersReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_HEADERS) {
	      return action.headers;
	    }
	    return state;
	  }
	});
	unwrapExports(headersReducer_1);

	var mapDataReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = mapDataReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function mapDataReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_MAP_DATA) {
	      return _extends({}, state, _defineProperty({}, action.componentId, {
	        query: action.query,
	        persistMapQuery: action.persistMapQuery
	      }));
	    } else if (action.type === constants.SET_MAP_RESULTS) {
	      return _extends({}, state, _defineProperty({}, action.componentId, _extends({}, state[action.componentId], action.payload)));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(mapDataReducer_1);

	var queryListenerReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = queryListenerReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function queryListenerReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_QUERY_LISTENER) {
	      return _extends({}, state, _defineProperty({}, action.component, {
	        onQueryChange: action.onQueryChange,
	        onError: action.onError
	      }));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(queryListenerReducer_1);

	var analyticsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = analyticsReducer;
	  var initialState = {
	    searchValue: null,
	    searchId: null,
	    suggestionsSearchId: null,
	    suggestionsSearchValue: null
	  };
	  var searchComponents = [constants$1.componentTypes.dataSearch, constants$1.componentTypes.categorySearch];
	  function analyticsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	    var action = arguments[1];
	    switch (action.type) {
	      case constants.SET_VALUE:
	        if (searchComponents.includes(action.componentType)) {
	          return {
	            searchValue: action.value,
	            searchId: null
	          };
	        }
	        return state;
	      case constants.SET_SEARCH_ID:
	        return _extends({}, state, {
	          searchId: action.searchId
	        });
	      case constants.SET_SUGGESTIONS_SEARCH_VALUE:
	        return _extends({}, state, {
	          suggestionsSearchValue: action.value,
	          suggestionsSearchId: null
	        });
	      case constants.SET_SUGGESTIONS_SEARCH_ID:
	        return _extends({}, state, {
	          suggestionsSearchId: action.searchId
	        });
	      case constants.CLEAR_SUGGESTIONS_SEARCH_VALUE:
	        return _extends({}, state, {
	          suggestionsSearchValue: null,
	          suggestionsSearchId: null
	        });
	      default:
	        return state;
	    }
	  }
	});
	unwrapExports(analyticsReducer_1);

	var promotedResultsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = promotedResultsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function promotedResultsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_PROMOTED_RESULTS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.results.map(function (item) {
	        return _extends({}, item, {
	          _promoted: true
	        });
	      })));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(promotedResultsReducer_1);

	var customDataReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = customDataReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function customDataReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_CUSTOM_DATA) {
	      return _extends({}, state, _defineProperty({}, action.component, action.data));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(customDataReducer_1);

	var defaultQueryReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = defaultQueryReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function defaultQueryReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_DEFAULT_QUERY) {
	      return _extends({}, state, _defineProperty({}, action.component, action.query));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(defaultQueryReducer_1);

	var customQueryReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = customQueryReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function customQueryReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_CUSTOM_QUERY) {
	      return _extends({}, state, _defineProperty({}, action.component, action.query));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(customQueryReducer_1);

	var propsReducer = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = queryOptionsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function queryOptionsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    switch (action.type) {
	      case constants.SET_PROPS:
	        return _extends({}, state, _defineProperty({}, action.component, action.options));
	      case constants.UPDATE_PROPS:
	        return _extends({}, state, _defineProperty({}, action.component, _extends({}, state[action.component], action.options)));
	      case constants.REMOVE_PROPS:
	      case constants.REMOVE_COMPONENT:
	        {
	          var del = state[action.component],
	            obj = _objectWithoutProperties(state, [action.component]);
	          return obj;
	        }
	      default:
	        return state;
	    }
	  }
	});
	unwrapExports(propsReducer);

	var aggsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = aggsReducer;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function aggsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.UPDATE_AGGS) {
	      if (action.append) {
	        var field = Object.keys(state[action.component])[0];
	        var _action$aggregations$ = action.aggregations[field],
	          newBuckets = _action$aggregations$.buckets,
	          aggsData = _objectWithoutProperties(_action$aggregations$, ['buckets']);
	        return _extends({}, state, _defineProperty({}, action.component, _defineProperty({}, field, _extends({
	          buckets: [].concat(_toConsumableArray(state[action.component][field].buckets), _toConsumableArray(newBuckets))
	        }, aggsData))));
	      }
	      return _extends({}, state, _defineProperty({}, action.component, action.aggregations));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(aggsReducer_1);

	var compositeAggsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = compositeAggsReducer;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function compositeAggsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.UPDATE_COMPOSITE_AGGS) {
	      var aggsResponse = Object.values(action.aggregations) && Object.values(action.aggregations)[0];
	      var fieldName = Object.keys(action.aggregations)[0];
	      if (!aggsResponse) return state;
	      var buckets = [];
	      if (aggsResponse.buckets && Array.isArray(aggsResponse.buckets)) {
	        buckets = aggsResponse.buckets;
	      }
	      var parsedAggs = buckets.map(function (bucket) {
	        var doc_count = bucket.doc_count,
	          key = bucket.key,
	          hitsData = bucket[fieldName];
	        var flatData = {};
	        var _source = {};
	        if (hitsData && hitsData.hits) {
	          var _hitsData$hits$hits$ = hitsData.hits.hits[0];
	          _source = _hitsData$hits$hits$._source;
	          flatData = _objectWithoutProperties(_hitsData$hits$hits$, ['_source']);
	        }
	        return _extends({
	          _doc_count: doc_count,
	          _key: typeof key === 'string' ? key : key[fieldName],
	          top_hits: hitsData
	        }, flatData, _source);
	      });
	      return _extends({}, state, _defineProperty({}, action.component, action.append ? [].concat(_toConsumableArray(state[action.component]), _toConsumableArray(parsedAggs)) : parsedAggs));
	    }
	    return state;
	  }
	});
	var compositeAggsReducer = unwrapExports(compositeAggsReducer_1);

	var appliedSettingsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = appliedSettingsReducer;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function appliedSettingsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_APPLIED_SETTINGS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.data));
	    }
	    return state;
	  }
	});
	unwrapExports(appliedSettingsReducer_1);

	var customHighlightReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = customHighlightReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function customHighlightReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_CUSTOM_HIGHLIGHT_OPTIONS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.data));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(customHighlightReducer_1);

	var rawDataReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = rawDataReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function rawDataReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_RAW_DATA) {
	      return _extends({}, state, _defineProperty({}, action.component, action.response));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(rawDataReducer_1);

	var querySuggestionsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = querySuggestionsReducer;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function querySuggestionsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_POPULAR_SUGGESTIONS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.suggestions));
	    }
	    return state;
	  }
	});
	unwrapExports(querySuggestionsReducer_1);

	var defaultPopularSuggestions_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = defaultPopularSuggestions;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function defaultPopularSuggestions() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_DEFAULT_POPULAR_SUGGESTIONS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.suggestions));
	    }
	    return state;
	  }
	});
	unwrapExports(defaultPopularSuggestions_1);

	var queryToHitsReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = queryToHitsReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function queryToHitsReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_QUERY_TO_HITS) {
	      return _extends({}, state, _defineProperty({}, action.component, action.query));
	    } else if (action.type === constants.REMOVE_COMPONENT) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(queryToHitsReducer_1);

	var recentSearches = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = recentSearchesReducer;
	  function recentSearchesReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.RECENT_SEARCHES_SUCCESS) {
	      return {
	        error: null,
	        data: action.data
	      };
	    } else if (action.type === constants.RECENT_SEARCHES_ERROR) {
	      return {
	        error: action.error
	      };
	    }
	    return state;
	  }
	});
	unwrapExports(recentSearches);

	var googleMapScriptReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = googleMapScriptReducer;
	  var INITIAL_STATE = {
	    loading: false,
	    loaded: false,
	    error: null
	  };
	  function googleMapScriptReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;
	    var action = arguments[1];
	    var type = action.type,
	      loading = action.loading,
	      loaded = action.loaded,
	      error = action.error;
	    if (type === constants.SET_GOOGLE_MAP_SCRIPT_LOADING) {
	      return _extends({}, INITIAL_STATE, {
	        loading: loading
	      });
	    } else if (type === constants.SET_GOOGLE_MAP_SCRIPT_LOADED) {
	      return _extends({}, INITIAL_STATE, {
	        loaded: loaded
	      });
	    } else if (type === constants.SET_GOOGLE_MAP_SCRIPT_ERROR) {
	      return _extends({}, INITIAL_STATE, {
	        error: error
	      });
	    }
	    return state;
	  }
	});
	unwrapExports(googleMapScriptReducer_1);

	var analyticsRefReducer_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports["default"] = analyticsRefReducer;
	  function analyticsRefReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.ADD_ANALYTICS_REF) {
	      return action.analyticsRef;
	    }
	    return state;
	  }
	});
	unwrapExports(analyticsRefReducer_1);

	var registeredComponentReducer = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = timestampReducer;
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function timestampReducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (action.type === constants.SET_REGISTERED_COMPONENT_TIMESTAMP) {
	      return _extends({}, state, _defineProperty({}, action.component, action.timestamp));
	    } else if (action.type === constants.REMOVE_REGISTERED_COMPONENT_TIMESTAMP) {
	      var del = state[action.component],
	        obj = _objectWithoutProperties(state, [action.component]);
	      return obj;
	    }
	    return state;
	  }
	});
	unwrapExports(registeredComponentReducer);

	var reducers = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _componentsReducer2 = _interopRequireDefault(componentsReducer_1);
	  var _watchManReducer2 = _interopRequireDefault(watchManReducer_1);
	  var _dependencyTreeReducer2 = _interopRequireDefault(dependencyTreeReducer_1);
	  var _queryReducer2 = _interopRequireDefault(queryReducer_1);
	  var _appbaseQueryReducer2 = _interopRequireDefault(appbaseQueryReducer_1);
	  var _queryOptionsReducer2 = _interopRequireDefault(queryOptionsReducer_1);
	  var _configReducer2 = _interopRequireDefault(configReducer_1);
	  var _appbaseRefReducer2 = _interopRequireDefault(appbaseRefReducer_1);
	  var _hitsReducer2 = _interopRequireDefault(hitsReducer_1);
	  var _logsReducer2 = _interopRequireDefault(logsReducer_1);
	  var _combinedLogsReducer2 = _interopRequireDefault(combinedLogsReducer_1);
	  var _valueReducer2 = _interopRequireDefault(valueReducer_1);
	  var _internalValueReducer2 = _interopRequireDefault(internalValueReducer);
	  var _loadingReducer2 = _interopRequireDefault(loadingReducer_1);
	  var _errorReducer2 = _interopRequireDefault(errorReducer_1);
	  var _timestampReducer2 = _interopRequireDefault(timestampReducer_1);
	  var _headersReducer2 = _interopRequireDefault(headersReducer_1);
	  var _mapDataReducer2 = _interopRequireDefault(mapDataReducer_1);
	  var _queryListenerReducer2 = _interopRequireDefault(queryListenerReducer_1);
	  var _analyticsReducer2 = _interopRequireDefault(analyticsReducer_1);
	  var _promotedResultsReducer2 = _interopRequireDefault(promotedResultsReducer_1);
	  var _customDataReducer2 = _interopRequireDefault(customDataReducer_1);
	  var _defaultQueryReducer2 = _interopRequireDefault(defaultQueryReducer_1);
	  var _customQueryReducer2 = _interopRequireDefault(customQueryReducer_1);
	  var _propsReducer2 = _interopRequireDefault(propsReducer);
	  var _aggsReducer2 = _interopRequireDefault(aggsReducer_1);
	  var _compositeAggsReducer2 = _interopRequireDefault(compositeAggsReducer_1);
	  var _appliedSettingsReducer2 = _interopRequireDefault(appliedSettingsReducer_1);
	  var _customHighlightReducer2 = _interopRequireDefault(customHighlightReducer_1);
	  var _rawDataReducer2 = _interopRequireDefault(rawDataReducer_1);
	  var _querySuggestionsReducer2 = _interopRequireDefault(querySuggestionsReducer_1);
	  var _defaultPopularSuggestions2 = _interopRequireDefault(defaultPopularSuggestions_1);
	  var _queryToHitsReducer2 = _interopRequireDefault(queryToHitsReducer_1);
	  var _recentSearches2 = _interopRequireDefault(recentSearches);
	  var _googleMapScriptReducer2 = _interopRequireDefault(googleMapScriptReducer_1);
	  var _analyticsRefReducer2 = _interopRequireDefault(analyticsRefReducer_1);
	  var _registeredComponentReducer2 = _interopRequireDefault(registeredComponentReducer);
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  exports["default"] = (0, redux.combineReducers)({
	    components: _componentsReducer2["default"],
	    customQueries: _customQueryReducer2["default"],
	    defaultQueries: _defaultQueryReducer2["default"],
	    customHighlightOptions: _customHighlightReducer2["default"],
	    settings: _appliedSettingsReducer2["default"],
	    watchMan: _watchManReducer2["default"],
	    queryList: _queryReducer2["default"],
	    queryOptions: _queryOptionsReducer2["default"],
	    dependencyTree: _dependencyTreeReducer2["default"],
	    appbaseRef: _appbaseRefReducer2["default"],
	    analyticsRef: _analyticsRefReducer2["default"],
	    config: _configReducer2["default"],
	    hits: _hitsReducer2["default"],
	    promotedResults: _promotedResultsReducer2["default"],
	    customData: _customDataReducer2["default"],
	    aggregations: _aggsReducer2["default"],
	    compositeAggregations: _compositeAggsReducer2["default"],
	    queryLog: _logsReducer2["default"],
	    combinedLog: _combinedLogsReducer2["default"],
	    selectedValues: _valueReducer2["default"],
	    internalValues: _internalValueReducer2["default"],
	    isLoading: _loadingReducer2["default"],
	    error: _errorReducer2["default"],
	    timestamp: _timestampReducer2["default"],
	    headers: _headersReducer2["default"],
	    mapData: _mapDataReducer2["default"],
	    queryListener: _queryListenerReducer2["default"],
	    analytics: _analyticsReducer2["default"],
	    props: _propsReducer2["default"],
	    rawData: _rawDataReducer2["default"],
	    querySuggestions: _querySuggestionsReducer2["default"],
	    defaultPopularSuggestions: _defaultPopularSuggestions2["default"],
	    queryToHits: _queryToHitsReducer2["default"],
	    recentSearches: _recentSearches2["default"],
	    urlValues: function urlValues() {
	      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      return state;
	    },
	    googleMapScriptStatus: _googleMapScriptReducer2["default"],
	    lastUsedAppbaseQuery: _appbaseQueryReducer2["default"],
	    registeredComponentsTimestamps: _registeredComponentReducer2["default"]
	  });
	});
	unwrapExports(reducers);

	var dateFormats_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var dateFormats = {
	    date: 'YYYY-MM-DD',
	    basic_date: 'YYYYMMDD',
	    basic_date_time: 'YYYYMMDD[T]HHmmss.SSSZ',
	    basic_date_time_no_millis: 'YYYYMMDD[T]HHmmssZ',
	    date_time_no_millis: 'YYYY-MM-DD[T]HH:mm:ssZ',
	    basic_time: 'HHmmss.SSSZ',
	    basic_time_no_millis: 'HHmmssZ',
	    epoch_millis: 'epoch_millis',
	    epoch_second: 'epoch_second'
	  };
	  exports["default"] = dateFormats;
	});
	unwrapExports(dateFormats_1);

	var diacritics_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var diacritics = {
	    '«': '"',
	    '²': '2',
	    '³': '3',
	    '¹': '1',
	    '»': '"',
	    À: 'A',
	    Á: 'A',
	    Â: 'A',
	    Ã: 'A',
	    Ä: 'A',
	    Å: 'A',
	    Æ: 'AE',
	    Ç: 'C',
	    È: 'E',
	    É: 'E',
	    Ê: 'E',
	    Ë: 'E',
	    Ì: 'I',
	    Í: 'I',
	    Î: 'I',
	    Ï: 'I',
	    Ð: 'D',
	    Ñ: 'N',
	    Ò: 'O',
	    Ó: 'O',
	    Ô: 'O',
	    Õ: 'O',
	    Ö: 'O',
	    Ø: 'O',
	    Ù: 'U',
	    Ú: 'U',
	    Û: 'U',
	    Ü: 'U',
	    Ý: 'Y',
	    Þ: 'TH',
	    ß: 'ss',
	    à: 'a',
	    á: 'a',
	    â: 'a',
	    ã: 'a',
	    ä: 'a',
	    å: 'a',
	    æ: 'ae',
	    ç: 'c',
	    è: 'e',
	    é: 'e',
	    ê: 'e',
	    ë: 'e',
	    ì: 'i',
	    í: 'i',
	    î: 'i',
	    ï: 'i',
	    ð: 'd',
	    ñ: 'n',
	    ò: 'o',
	    ó: 'o',
	    ô: 'o',
	    õ: 'o',
	    ö: 'o',
	    ø: 'o',
	    ù: 'u',
	    ú: 'u',
	    û: 'u',
	    ü: 'u',
	    ý: 'y',
	    þ: 'th',
	    ÿ: 'y',
	    Ā: 'A',
	    ā: 'a',
	    Ă: 'A',
	    ă: 'a',
	    Ą: 'A',
	    ą: 'a',
	    Ć: 'C',
	    ć: 'c',
	    Ĉ: 'C',
	    ĉ: 'c',
	    Ċ: 'C',
	    ċ: 'c',
	    Č: 'C',
	    č: 'c',
	    Ď: 'D',
	    ď: 'd',
	    Đ: 'D',
	    đ: 'd',
	    Ē: 'E',
	    ē: 'e',
	    Ĕ: 'E',
	    ĕ: 'e',
	    Ė: 'E',
	    ė: 'e',
	    Ę: 'E',
	    ę: 'e',
	    Ě: 'E',
	    ě: 'e',
	    Ĝ: 'G',
	    ĝ: 'g',
	    Ğ: 'G',
	    ğ: 'g',
	    Ġ: 'G',
	    ġ: 'g',
	    Ģ: 'G',
	    ģ: 'g',
	    Ĥ: 'H',
	    ĥ: 'h',
	    Ħ: 'H',
	    ħ: 'h',
	    Ĩ: 'I',
	    ĩ: 'i',
	    Ī: 'I',
	    ī: 'i',
	    Ĭ: 'I',
	    ĭ: 'i',
	    Į: 'I',
	    į: 'i',
	    İ: 'I',
	    ı: 'i',
	    Ĳ: 'IJ',
	    ĳ: 'ij',
	    Ĵ: 'J',
	    ĵ: 'j',
	    Ķ: 'K',
	    ķ: 'k',
	    ĸ: 'q',
	    Ĺ: 'L',
	    ĺ: 'l',
	    Ļ: 'L',
	    ļ: 'l',
	    Ľ: 'L',
	    ľ: 'l',
	    Ŀ: 'L',
	    ŀ: 'l',
	    Ł: 'L',
	    ł: 'l',
	    Ń: 'N',
	    ń: 'n',
	    Ņ: 'N',
	    ņ: 'n',
	    Ň: 'N',
	    ň: 'n',
	    ŉ: 'n',
	    Ŋ: 'N',
	    ŋ: 'n',
	    Ō: 'O',
	    ō: 'o',
	    Ŏ: 'O',
	    ŏ: 'o',
	    Ő: 'O',
	    ő: 'o',
	    Œ: 'OE',
	    œ: 'oe',
	    Ŕ: 'R',
	    ŕ: 'r',
	    Ŗ: 'R',
	    ŗ: 'r',
	    Ř: 'R',
	    ř: 'r',
	    Ś: 'S',
	    ś: 's',
	    Ŝ: 'S',
	    ŝ: 's',
	    Ş: 'S',
	    ş: 's',
	    Š: 'S',
	    š: 's',
	    Ţ: 'T',
	    ţ: 't',
	    Ť: 'T',
	    ť: 't',
	    Ŧ: 'T',
	    ŧ: 't',
	    Ũ: 'U',
	    ũ: 'u',
	    Ū: 'U',
	    ū: 'u',
	    Ŭ: 'U',
	    ŭ: 'u',
	    Ů: 'U',
	    ů: 'u',
	    Ű: 'U',
	    ű: 'u',
	    Ų: 'U',
	    ų: 'u',
	    Ŵ: 'W',
	    ŵ: 'w',
	    Ŷ: 'Y',
	    ŷ: 'y',
	    Ÿ: 'Y',
	    Ź: 'Z',
	    ź: 'z',
	    Ż: 'Z',
	    ż: 'z',
	    Ž: 'Z',
	    ž: 'z',
	    ſ: 's',
	    ƀ: 'b',
	    Ɓ: 'B',
	    Ƃ: 'B',
	    ƃ: 'b',
	    Ɔ: 'O',
	    Ƈ: 'C',
	    ƈ: 'c',
	    Ɖ: 'D',
	    Ɗ: 'D',
	    Ƌ: 'D',
	    ƌ: 'd',
	    Ǝ: 'E',
	    Ə: 'A',
	    Ɛ: 'E',
	    Ƒ: 'F',
	    ƒ: 'f',
	    Ɠ: 'G',
	    ƕ: 'hv',
	    Ɩ: 'I',
	    Ɨ: 'I',
	    Ƙ: 'K',
	    ƙ: 'k',
	    ƚ: 'l',
	    Ɯ: 'M',
	    Ɲ: 'N',
	    ƞ: 'n',
	    Ɵ: 'O',
	    Ơ: 'O',
	    ơ: 'o',
	    Ƥ: 'P',
	    ƥ: 'p',
	    ƫ: 't',
	    Ƭ: 'T',
	    ƭ: 't',
	    Ʈ: 'T',
	    Ư: 'U',
	    ư: 'u',
	    Ʋ: 'V',
	    Ƴ: 'Y',
	    ƴ: 'y',
	    Ƶ: 'Z',
	    ƶ: 'z',
	    ƿ: 'w',
	    Ǆ: 'DZ',
	    ǅ: 'Dz',
	    ǆ: 'dz',
	    Ǉ: 'LJ',
	    ǈ: 'Lj',
	    ǉ: 'lj',
	    Ǌ: 'NJ',
	    ǋ: 'Nj',
	    ǌ: 'nj',
	    Ǎ: 'A',
	    ǎ: 'a',
	    Ǐ: 'I',
	    ǐ: 'i',
	    Ǒ: 'O',
	    ǒ: 'o',
	    Ǔ: 'U',
	    ǔ: 'u',
	    Ǖ: 'U',
	    ǖ: 'u',
	    Ǘ: 'U',
	    ǘ: 'u',
	    Ǚ: 'U',
	    ǚ: 'u',
	    Ǜ: 'U',
	    ǜ: 'u',
	    ǝ: 'e',
	    Ǟ: 'A',
	    ǟ: 'a',
	    Ǡ: 'A',
	    ǡ: 'a',
	    Ǣ: 'AE',
	    ǣ: 'ae',
	    Ǥ: 'G',
	    ǥ: 'G',
	    Ǧ: 'G',
	    ǧ: 'G',
	    Ǩ: 'K',
	    ǩ: 'k',
	    Ǫ: 'O',
	    ǫ: 'o',
	    Ǭ: 'O',
	    ǭ: 'o',
	    ǰ: 'j',
	    Ǳ: 'DZ',
	    ǲ: 'Dz',
	    ǳ: 'dz',
	    Ǵ: 'G',
	    ǵ: 'g',
	    Ƕ: 'HV',
	    Ƿ: 'W',
	    Ǹ: 'N',
	    ǹ: 'n',
	    Ǻ: 'A',
	    ǻ: 'a',
	    Ǽ: 'AE',
	    ǽ: 'ae',
	    Ǿ: 'O',
	    ǿ: 'o',
	    Ȁ: 'A',
	    ȁ: 'a',
	    Ȃ: 'A',
	    ȃ: 'a',
	    Ȅ: 'E',
	    ȅ: 'e',
	    Ȇ: 'E',
	    ȇ: 'e',
	    Ȉ: 'I',
	    ȉ: 'i',
	    Ȋ: 'I',
	    ȋ: 'i',
	    Ȍ: 'O',
	    ȍ: 'o',
	    Ȏ: 'O',
	    ȏ: 'o',
	    Ȑ: 'R',
	    ȑ: 'r',
	    Ȓ: 'R',
	    ȓ: 'r',
	    Ȕ: 'U',
	    ȕ: 'u',
	    Ȗ: 'U',
	    ȗ: 'u',
	    Ș: 'S',
	    ș: 's',
	    Ț: 'T',
	    ț: 't',
	    Ȝ: 'Z',
	    ȝ: 'z',
	    Ȟ: 'H',
	    ȟ: 'h',
	    Ƞ: 'N',
	    ȡ: 'd',
	    Ȣ: 'OU',
	    ȣ: 'ou',
	    Ȥ: 'Z',
	    ȥ: 'z',
	    Ȧ: 'A',
	    ȧ: 'a',
	    Ȩ: 'E',
	    ȩ: 'e',
	    Ȫ: 'O',
	    ȫ: 'o',
	    Ȭ: 'O',
	    ȭ: 'o',
	    Ȯ: 'O',
	    ȯ: 'o',
	    Ȱ: 'O',
	    ȱ: 'o',
	    Ȳ: 'Y',
	    ȳ: 'y',
	    ȴ: 'l',
	    ȵ: 'n',
	    ȶ: 't',
	    ȷ: 'j',
	    ȸ: 'db',
	    ȹ: 'qp',
	    Ⱥ: 'A',
	    Ȼ: 'C',
	    ȼ: 'c',
	    Ƚ: 'L',
	    Ⱦ: 'T',
	    ȿ: 's',
	    ɀ: 'z',
	    Ƀ: 'B',
	    Ʉ: 'U',
	    Ʌ: 'V',
	    Ɇ: 'E',
	    ɇ: 'e',
	    Ɉ: 'J',
	    ɉ: 'j',
	    Ɋ: 'Q',
	    ɋ: 'q',
	    Ɍ: 'R',
	    ɍ: 'r',
	    Ɏ: 'Y',
	    ɏ: 'y',
	    ɐ: 'a',
	    ɓ: 'b',
	    ɔ: 'o',
	    ɕ: 'c',
	    ɖ: 'd',
	    ɗ: 'd',
	    ɘ: 'e',
	    ə: 'a',
	    ɚ: 'a',
	    ɛ: 'e',
	    ɜ: 'e',
	    ɝ: 'e',
	    ɞ: 'e',
	    ɟ: 'j',
	    ɠ: 'g',
	    ɡ: 'g',
	    ɢ: 'G',
	    ɥ: 'h',
	    ɦ: 'h',
	    ɨ: 'i',
	    ɪ: 'I',
	    ɫ: 'l',
	    ɬ: 'l',
	    ɭ: 'l',
	    ɯ: 'm',
	    ɰ: 'm',
	    ɱ: 'm',
	    ɲ: 'n',
	    ɳ: 'n',
	    ɴ: 'N',
	    ɵ: 'o',
	    ɶ: 'OE',
	    ɼ: 'r',
	    ɽ: 'r',
	    ɾ: 'r',
	    ɿ: 'r',
	    ʀ: 'R',
	    ʁ: 'R',
	    ʂ: 's',
	    ʄ: 'j',
	    ʇ: 't',
	    ʈ: 't',
	    ʉ: 'u',
	    ʋ: 'v',
	    ʌ: 'v',
	    ʍ: 'w',
	    ʎ: 'y',
	    ʏ: 'Y',
	    ʐ: 'z',
	    ʑ: 'z',
	    ʗ: 'C',
	    ʙ: 'B',
	    ʚ: 'e',
	    ʛ: 'G',
	    ʜ: 'H',
	    ʝ: 'j',
	    ʞ: 'k',
	    ʟ: 'L',
	    ʠ: 'q',
	    ʣ: 'dz',
	    ʥ: 'dz',
	    ʦ: 'ts',
	    ʨ: 'tc',
	    ʪ: 'ls',
	    ʫ: 'lz',
	    ʮ: 'h',
	    ʯ: 'h',
	    ᴀ: 'A',
	    ᴁ: 'AE',
	    ᴂ: 'ae',
	    ᴃ: 'B',
	    ᴄ: 'C',
	    ᴅ: 'D',
	    ᴆ: 'D',
	    ᴇ: 'E',
	    ᴈ: 'e',
	    ᴉ: 'i',
	    ᴊ: 'J',
	    ᴋ: 'K',
	    ᴌ: 'L',
	    ᴍ: 'M',
	    ᴎ: 'N',
	    ᴏ: 'O',
	    ᴐ: 'O',
	    ᴔ: 'oe',
	    ᴕ: 'OU',
	    ᴖ: 'o',
	    ᴗ: 'o',
	    ᴘ: 'P',
	    ᴙ: 'R',
	    ᴚ: 'R',
	    ᴛ: 'T',
	    ᴜ: 'U',
	    ᴠ: 'V',
	    ᴡ: 'W',
	    ᴢ: 'Z',
	    ᵢ: 'i',
	    ᵣ: 'r',
	    ᵤ: 'u',
	    ᵥ: 'v',
	    ᵫ: 'ue',
	    ᵬ: 'b',
	    ᵭ: 'd',
	    ᵮ: 'f',
	    ᵯ: 'm',
	    ᵰ: 'n',
	    ᵱ: 'p',
	    ᵲ: 'r',
	    ᵳ: 'r',
	    ᵴ: 's',
	    ᵵ: 't',
	    ᵶ: 'z',
	    ᵷ: 'g',
	    ᵹ: 'g',
	    ᵺ: 'th',
	    ᵻ: 'I',
	    ᵼ: 'i',
	    ᵽ: 'p',
	    ᵾ: 'U',
	    ᶀ: 'b',
	    ᶁ: 'd',
	    ᶂ: 'f',
	    ᶃ: 'g',
	    ᶄ: 'k',
	    ᶅ: 'l',
	    ᶆ: 'm',
	    ᶇ: 'n',
	    ᶈ: 'p',
	    ᶉ: 'r',
	    ᶊ: 's',
	    ᶌ: 'v',
	    ᶍ: 'x',
	    ᶎ: 'z',
	    ᶏ: 'a',
	    ᶑ: 'd',
	    ᶒ: 'e',
	    ᶓ: 'e',
	    ᶔ: 'e',
	    ᶕ: 'a',
	    ᶖ: 'i',
	    ᶗ: 'o',
	    ᶙ: 'u',
	    Ḁ: 'A',
	    ḁ: 'a',
	    Ḃ: 'B',
	    ḃ: 'b',
	    Ḅ: 'B',
	    ḅ: 'b',
	    Ḇ: 'B',
	    ḇ: 'b',
	    Ḉ: 'C',
	    ḉ: 'c',
	    Ḋ: 'D',
	    ḋ: 'd',
	    Ḍ: 'D',
	    ḍ: 'd',
	    Ḏ: 'D',
	    ḏ: 'd',
	    Ḑ: 'D',
	    ḑ: 'd',
	    Ḓ: 'D',
	    ḓ: 'd',
	    Ḕ: 'E',
	    ḕ: 'e',
	    Ḗ: 'E',
	    ḗ: 'e',
	    Ḙ: 'E',
	    ḙ: 'e',
	    Ḛ: 'E',
	    ḛ: 'e',
	    Ḝ: 'E',
	    ḝ: 'e',
	    Ḟ: 'F',
	    ḟ: 'f',
	    Ḡ: 'G',
	    ḡ: 'g',
	    Ḣ: 'H',
	    ḣ: 'h',
	    Ḥ: 'H',
	    ḥ: 'h',
	    Ḧ: 'H',
	    ḧ: 'h',
	    Ḩ: 'H',
	    ḩ: 'h',
	    Ḫ: 'H',
	    ḫ: 'h',
	    Ḭ: 'I',
	    ḭ: 'i',
	    Ḯ: 'I',
	    ḯ: 'i',
	    Ḱ: 'K',
	    ḱ: 'k',
	    Ḳ: 'K',
	    ḳ: 'k',
	    Ḵ: 'K',
	    ḵ: 'k',
	    Ḷ: 'L',
	    ḷ: 'l',
	    Ḹ: 'L',
	    ḹ: 'l',
	    Ḻ: 'L',
	    ḻ: 'l',
	    Ḽ: 'L',
	    ḽ: 'l',
	    Ḿ: 'M',
	    ḿ: 'm',
	    Ṁ: 'M',
	    ṁ: 'm',
	    Ṃ: 'M',
	    ṃ: 'm',
	    Ṅ: 'N',
	    ṅ: 'n',
	    Ṇ: 'N',
	    ṇ: 'n',
	    Ṉ: 'N',
	    ṉ: 'n',
	    Ṋ: 'N',
	    ṋ: 'n',
	    Ṍ: 'O',
	    ṍ: 'o',
	    Ṏ: 'O',
	    ṏ: 'o',
	    Ṑ: 'O',
	    ṑ: 'o',
	    Ṓ: 'O',
	    ṓ: 'o',
	    Ṕ: 'P',
	    ṕ: 'p',
	    Ṗ: 'P',
	    ṗ: 'p',
	    Ṙ: 'R',
	    ṙ: 'r',
	    Ṛ: 'R',
	    ṛ: 'r',
	    Ṝ: 'R',
	    ṝ: 'r',
	    Ṟ: 'R',
	    ṟ: 'r',
	    Ṡ: 'S',
	    ṡ: 's',
	    Ṣ: 'S',
	    ṣ: 's',
	    Ṥ: 'S',
	    ṥ: 's',
	    Ṧ: 'S',
	    ṧ: 's',
	    Ṩ: 'S',
	    ṩ: 's',
	    Ṫ: 'T',
	    ṫ: 't',
	    Ṭ: 'T',
	    ṭ: 't',
	    Ṯ: 'T',
	    ṯ: 't',
	    Ṱ: 'T',
	    ṱ: 't',
	    Ṳ: 'U',
	    ṳ: 'u',
	    Ṵ: 'U',
	    ṵ: 'u',
	    Ṷ: 'U',
	    ṷ: 'u',
	    Ṹ: 'U',
	    ṹ: 'u',
	    Ṻ: 'U',
	    ṻ: 'u',
	    Ṽ: 'V',
	    ṽ: 'v',
	    Ṿ: 'V',
	    ṿ: 'v',
	    Ẁ: 'W',
	    ẁ: 'w',
	    Ẃ: 'W',
	    ẃ: 'w',
	    Ẅ: 'W',
	    ẅ: 'w',
	    Ẇ: 'W',
	    ẇ: 'w',
	    Ẉ: 'W',
	    ẉ: 'w',
	    Ẋ: 'X',
	    ẋ: 'x',
	    Ẍ: 'X',
	    ẍ: 'x',
	    Ẏ: 'Y',
	    ẏ: 'y',
	    Ẑ: 'Z',
	    ẑ: 'z',
	    Ẓ: 'Z',
	    ẓ: 'z',
	    Ẕ: 'Z',
	    ẕ: 'z',
	    ẖ: 'h',
	    ẗ: 't',
	    ẘ: 'w',
	    ẙ: 'y',
	    ẚ: 'a',
	    ẛ: 'f',
	    ẜ: 's',
	    ẝ: 's',
	    ẞ: 'SS',
	    Ạ: 'A',
	    ạ: 'a',
	    Ả: 'A',
	    ả: 'a',
	    Ấ: 'A',
	    ấ: 'a',
	    Ầ: 'A',
	    ầ: 'a',
	    Ẩ: 'A',
	    ẩ: 'a',
	    Ẫ: 'A',
	    ẫ: 'a',
	    Ậ: 'A',
	    ậ: 'a',
	    Ắ: 'A',
	    ắ: 'a',
	    Ằ: 'A',
	    ằ: 'a',
	    Ẳ: 'A',
	    ẳ: 'a',
	    Ẵ: 'A',
	    ẵ: 'a',
	    Ặ: 'A',
	    ặ: 'a',
	    Ẹ: 'E',
	    ẹ: 'e',
	    Ẻ: 'E',
	    ẻ: 'e',
	    Ẽ: 'E',
	    ẽ: 'e',
	    Ế: 'E',
	    ế: 'e',
	    Ề: 'E',
	    ề: 'e',
	    Ể: 'E',
	    ể: 'e',
	    Ễ: 'E',
	    ễ: 'e',
	    Ệ: 'E',
	    ệ: 'e',
	    Ỉ: 'I',
	    ỉ: 'i',
	    Ị: 'I',
	    ị: 'i',
	    Ọ: 'O',
	    ọ: 'o',
	    Ỏ: 'O',
	    ỏ: 'o',
	    Ố: 'O',
	    ố: 'o',
	    Ồ: 'O',
	    ồ: 'o',
	    Ổ: 'O',
	    ổ: 'o',
	    Ỗ: 'O',
	    ỗ: 'o',
	    Ộ: 'O',
	    ộ: 'o',
	    Ớ: 'O',
	    ớ: 'o',
	    Ờ: 'O',
	    ờ: 'o',
	    Ở: 'O',
	    ở: 'o',
	    Ỡ: 'O',
	    ỡ: 'o',
	    Ợ: 'O',
	    ợ: 'o',
	    Ụ: 'U',
	    ụ: 'u',
	    Ủ: 'U',
	    ủ: 'u',
	    Ứ: 'U',
	    ứ: 'u',
	    Ừ: 'U',
	    ừ: 'u',
	    Ử: 'U',
	    ử: 'u',
	    Ữ: 'U',
	    ữ: 'u',
	    Ự: 'U',
	    ự: 'u',
	    Ỳ: 'Y',
	    ỳ: 'y',
	    Ỵ: 'Y',
	    ỵ: 'y',
	    Ỷ: 'Y',
	    ỷ: 'y',
	    Ỹ: 'Y',
	    ỹ: 'y',
	    Ỻ: 'LL',
	    ỻ: 'll',
	    Ỽ: 'V',
	    Ỿ: 'Y',
	    ỿ: 'y',
	    '‐': '-',
	    '‑': '-',
	    '‒': '-',
	    '–': '-',
	    '—': '-',
	    '‘': '"',
	    '’': '"',
	    '‚': '"',
	    '‛': '"',
	    '“': '"',
	    '”': '"',
	    '„': '"',
	    '′': '"',
	    '″': '"',
	    '‵': '"',
	    '‶': '"',
	    '‸': '^',
	    '‹': '"',
	    '›': '"',
	    '‼': '!!',
	    '⁄': '/',
	    '⁅': '[',
	    '⁆': ']',
	    '⁇': '??',
	    '⁈': '?!',
	    '⁉': '!?',
	    '⁎': '*',
	    '⁏': ';',
	    '⁒': '%',
	    '⁓': '~',
	    '⁰': '0',
	    ⁱ: 'i',
	    '⁴': '4',
	    '⁵': '5',
	    '⁶': '6',
	    '⁷': '7',
	    '⁸': '8',
	    '⁹': '9',
	    '⁺': '+',
	    '⁻': '-',
	    '⁼': '=',
	    '⁽': '(',
	    '⁾': ')',
	    ⁿ: 'n',
	    '₀': '0',
	    '₁': '1',
	    '₂': '2',
	    '₃': '3',
	    '₄': '4',
	    '₅': '5',
	    '₆': '6',
	    '₇': '7',
	    '₈': '8',
	    '₉': '9',
	    '₊': '+',
	    '₋': '-',
	    '₌': '=',
	    '₍': '(',
	    '₎': ')',
	    ₐ: 'a',
	    ₑ: 'e',
	    ₒ: 'o',
	    ₓ: 'x',
	    ₔ: 'a',
	    ↄ: 'c',
	    '①': '1',
	    '②': '2',
	    '③': '3',
	    '④': '4',
	    '⑤': '5',
	    '⑥': '6',
	    '⑦': '7',
	    '⑧': '8',
	    '⑨': '9',
	    '⑩': '10',
	    '⑪': '11',
	    '⑫': '12',
	    '⑬': '13',
	    '⑭': '14',
	    '⑮': '15',
	    '⑯': '16',
	    '⑰': '17',
	    '⑱': '18',
	    '⑲': '19',
	    '⑳': '20',
	    '⑴': '(1)',
	    '⑵': '(2)',
	    '⑶': '(3)',
	    '⑷': '(4)',
	    '⑸': '(5)',
	    '⑹': '(6)',
	    '⑺': '(7)',
	    '⑻': '(8)',
	    '⑼': '(9)',
	    '⑽': '(10)',
	    '⑾': '(11)',
	    '⑿': '(12)',
	    '⒀': '(13)',
	    '⒁': '(14)',
	    '⒂': '(15)',
	    '⒃': '(16)',
	    '⒄': '(17)',
	    '⒅': '(18)',
	    '⒆': '(19)',
	    '⒇': '(20)',
	    '⒈': '1.',
	    '⒉': '2.',
	    '⒊': '3.',
	    '⒋': '4.',
	    '⒌': '5.',
	    '⒍': '6.',
	    '⒎': '7.',
	    '⒏': '8.',
	    '⒐': '9.',
	    '⒑': '10.',
	    '⒒': '11.',
	    '⒓': '12.',
	    '⒔': '13.',
	    '⒕': '14.',
	    '⒖': '15.',
	    '⒗': '16.',
	    '⒘': '17.',
	    '⒙': '18.',
	    '⒚': '19.',
	    '⒛': '20.',
	    '⒜': '(a)',
	    '⒝': '(b)',
	    '⒞': '(c)',
	    '⒟': '(d)',
	    '⒠': '(e)',
	    '⒡': '(f)',
	    '⒢': '(g)',
	    '⒣': '(h)',
	    '⒤': '(i)',
	    '⒥': '(j)',
	    '⒦': '(k)',
	    '⒧': '(l)',
	    '⒨': '(m)',
	    '⒩': '(n)',
	    '⒪': '(o)',
	    '⒫': '(p)',
	    '⒬': '(q)',
	    '⒭': '(r)',
	    '⒮': '(s)',
	    '⒯': '(t)',
	    '⒰': '(u)',
	    '⒱': '(v)',
	    '⒲': '(w)',
	    '⒳': '(x)',
	    '⒴': '(y)',
	    '⒵': '(z)',
	    'Ⓐ': 'A',
	    'Ⓑ': 'B',
	    'Ⓒ': 'C',
	    'Ⓓ': 'D',
	    'Ⓔ': 'E',
	    'Ⓕ': 'F',
	    'Ⓖ': 'G',
	    'Ⓗ': 'H',
	    'Ⓘ': 'I',
	    'Ⓙ': 'J',
	    'Ⓚ': 'K',
	    'Ⓛ': 'L',
	    'Ⓜ': 'M',
	    'Ⓝ': 'N',
	    'Ⓞ': 'O',
	    'Ⓟ': 'P',
	    'Ⓠ': 'Q',
	    'Ⓡ': 'R',
	    'Ⓢ': 'S',
	    'Ⓣ': 'T',
	    'Ⓤ': 'U',
	    'Ⓥ': 'V',
	    'Ⓦ': 'W',
	    'Ⓧ': 'X',
	    'Ⓨ': 'Y',
	    'Ⓩ': 'Z',
	    'ⓐ': 'a',
	    'ⓑ': 'b',
	    'ⓒ': 'c',
	    'ⓓ': 'd',
	    'ⓔ': 'e',
	    'ⓕ': 'f',
	    'ⓖ': 'g',
	    'ⓗ': 'h',
	    'ⓘ': 'i',
	    'ⓙ': 'j',
	    'ⓚ': 'k',
	    'ⓛ': 'l',
	    'ⓜ': 'm',
	    'ⓝ': 'n',
	    'ⓞ': 'o',
	    'ⓟ': 'p',
	    'ⓠ': 'q',
	    'ⓡ': 'r',
	    'ⓢ': 's',
	    'ⓣ': 't',
	    'ⓤ': 'u',
	    'ⓥ': 'v',
	    'ⓦ': 'w',
	    'ⓧ': 'x',
	    'ⓨ': 'y',
	    'ⓩ': 'z',
	    '⓪': '0',
	    '⓫': '11',
	    '⓬': '12',
	    '⓭': '13',
	    '⓮': '14',
	    '⓯': '15',
	    '⓰': '16',
	    '⓱': '17',
	    '⓲': '18',
	    '⓳': '19',
	    '⓴': '20',
	    '⓵': '1',
	    '⓶': '2',
	    '⓷': '3',
	    '⓸': '4',
	    '⓹': '5',
	    '⓺': '6',
	    '⓻': '7',
	    '⓼': '8',
	    '⓽': '9',
	    '⓾': '10',
	    '⓿': '0',
	    '❛': '"',
	    '❜': '"',
	    '❝': '"',
	    '❞': '"',
	    '❨': '(',
	    '❩': ')',
	    '❪': '(',
	    '❫': ')',
	    '❬': '<',
	    '❭': '>',
	    '❮': '"',
	    '❯': '"',
	    '❰': '<',
	    '❱': '>',
	    '❲': '[',
	    '❳': ']',
	    '❴': '{',
	    '❵': '}',
	    '❶': '1',
	    '❷': '2',
	    '❸': '3',
	    '❹': '4',
	    '❺': '5',
	    '❻': '6',
	    '❼': '7',
	    '❽': '8',
	    '❾': '9',
	    '❿': '10',
	    '➀': '1',
	    '➁': '2',
	    '➂': '3',
	    '➃': '4',
	    '➄': '5',
	    '➅': '6',
	    '➆': '7',
	    '➇': '8',
	    '➈': '9',
	    '➉': '10',
	    '➊': '1',
	    '➋': '2',
	    '➌': '3',
	    '➍': '4',
	    '➎': '5',
	    '➏': '6',
	    '➐': '7',
	    '➑': '8',
	    '➒': '9',
	    '➓': '10',
	    Ⱡ: 'L',
	    ⱡ: 'l',
	    Ɫ: 'L',
	    Ᵽ: 'P',
	    Ɽ: 'R',
	    ⱥ: 'a',
	    ⱦ: 't',
	    Ⱨ: 'H',
	    ⱨ: 'h',
	    Ⱪ: 'K',
	    ⱪ: 'k',
	    Ⱬ: 'Z',
	    ⱬ: 'z',
	    Ɱ: 'M',
	    Ɐ: 'a',
	    ⱱ: 'v',
	    Ⱳ: 'W',
	    ⱳ: 'w',
	    ⱴ: 'v',
	    Ⱶ: 'H',
	    ⱶ: 'h',
	    ⱸ: 'e',
	    ⱺ: 'o',
	    ⱻ: 'E',
	    ⱼ: 'j',
	    '⸨': '((',
	    '⸩': '))',
	    Ꜩ: 'TZ',
	    ꜩ: 'tz',
	    ꜰ: 'F',
	    ꜱ: 'S',
	    Ꜳ: 'AA',
	    ꜳ: 'aa',
	    Ꜵ: 'AO',
	    ꜵ: 'ao',
	    Ꜷ: 'AU',
	    ꜷ: 'au',
	    Ꜹ: 'AV',
	    ꜹ: 'av',
	    Ꜻ: 'AV',
	    ꜻ: 'av',
	    Ꜽ: 'AY',
	    ꜽ: 'ay',
	    Ꜿ: 'c',
	    ꜿ: 'c',
	    Ꝁ: 'K',
	    ꝁ: 'k',
	    Ꝃ: 'K',
	    ꝃ: 'k',
	    Ꝅ: 'K',
	    ꝅ: 'k',
	    Ꝇ: 'L',
	    ꝇ: 'l',
	    Ꝉ: 'L',
	    ꝉ: 'l',
	    Ꝋ: 'O',
	    ꝋ: 'o',
	    Ꝍ: 'O',
	    ꝍ: 'o',
	    Ꝏ: 'OO',
	    ꝏ: 'oo',
	    Ꝑ: 'P',
	    ꝑ: 'p',
	    Ꝓ: 'P',
	    ꝓ: 'p',
	    Ꝕ: 'P',
	    ꝕ: 'p',
	    Ꝗ: 'Q',
	    ꝗ: 'q',
	    Ꝙ: 'Q',
	    ꝙ: 'q',
	    Ꝛ: 'R',
	    ꝛ: 'r',
	    Ꝟ: 'V',
	    ꝟ: 'v',
	    Ꝡ: 'VY',
	    ꝡ: 'vy',
	    Ꝣ: 'Z',
	    ꝣ: 'z',
	    Ꝧ: 'TH',
	    ꝧ: 'th',
	    Ꝩ: 'V',
	    Ꝺ: 'D',
	    ꝺ: 'd',
	    Ꝼ: 'F',
	    ꝼ: 'f',
	    Ᵹ: 'G',
	    Ꝿ: 'G',
	    ꝿ: 'g',
	    Ꞁ: 'L',
	    ꞁ: 'l',
	    Ꞃ: 'R',
	    ꞃ: 'r',
	    Ꞅ: 's',
	    ꞅ: 'S',
	    Ꞇ: 'T',
	    ꟻ: 'F',
	    ꟼ: 'p',
	    ꟽ: 'M',
	    ꟾ: 'I',
	    ꟿ: 'M',
	    ﬀ: 'ff',
	    ﬁ: 'fi',
	    ﬂ: 'fl',
	    ﬃ: 'ffi',
	    ﬄ: 'ffl',
	    ﬆ: 'st',
	    '！': '!',
	    '＂': '"',
	    '＃': '#',
	    '＄': '$',
	    '％': '%',
	    '＆': '&',
	    '＇': '"',
	    '（': '(',
	    '）': ')',
	    '＊': '*',
	    '＋': '+',
	    '，': ',',
	    '－': '-',
	    '．': '.',
	    '／': '/',
	    '０': '0',
	    '１': '1',
	    '２': '2',
	    '３': '3',
	    '４': '4',
	    '５': '5',
	    '６': '6',
	    '７': '7',
	    '８': '8',
	    '９': '9',
	    '：': ':',
	    '；': ';',
	    '＜': '<',
	    '＝': '=',
	    '＞': '>',
	    '？': '?',
	    '＠': '@',
	    Ａ: 'A',
	    Ｂ: 'B',
	    Ｃ: 'C',
	    Ｄ: 'D',
	    Ｅ: 'E',
	    Ｆ: 'F',
	    Ｇ: 'G',
	    Ｈ: 'H',
	    Ｉ: 'I',
	    Ｊ: 'J',
	    Ｋ: 'K',
	    Ｌ: 'L',
	    Ｍ: 'M',
	    Ｎ: 'N',
	    Ｏ: 'O',
	    Ｐ: 'P',
	    Ｑ: 'Q',
	    Ｒ: 'R',
	    Ｓ: 'S',
	    Ｔ: 'T',
	    Ｕ: 'U',
	    Ｖ: 'V',
	    Ｗ: 'W',
	    Ｘ: 'X',
	    Ｙ: 'Y',
	    Ｚ: 'Z',
	    '［': '[',
	    '＼': '\\',
	    '］': ']',
	    '＾': '^',
	    '＿': '_',
	    ａ: 'a',
	    ｂ: 'b',
	    ｃ: 'c',
	    ｄ: 'd',
	    ｅ: 'e',
	    ｆ: 'f',
	    ｇ: 'g',
	    ｈ: 'h',
	    ｉ: 'i',
	    ｊ: 'j',
	    ｋ: 'k',
	    ｌ: 'l',
	    ｍ: 'm',
	    ｎ: 'n',
	    ｏ: 'o',
	    ｐ: 'p',
	    ｑ: 'q',
	    ｒ: 'r',
	    ｓ: 's',
	    ｔ: 't',
	    ｕ: 'u',
	    ｖ: 'v',
	    ｗ: 'w',
	    ｘ: 'x',
	    ｙ: 'y',
	    ｚ: 'z',
	    '｛': '{',
	    '｝': '}',
	    '～': '~'
	  };
	  exports["default"] = diacritics;
	});
	unwrapExports(diacritics_1);

	var suggestions = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.replaceDiacritics = replaceDiacritics;
	  var _diacritics2 = _interopRequireDefault(diacritics_1);
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  var flatten = function flatten(arr) {
	    return arr.reduce(function (flat, toFlatten) {
	      return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
	    }, []);
	  };
	  var extractSuggestion = function extractSuggestion(val) {
	    switch (typeof val) {
	      case 'string':
	        return val;
	      case 'object':
	        if (Array.isArray(val)) {
	          return flatten(val);
	        }
	        return null;
	      default:
	        return val;
	    }
	  };
	  function replaceDiacritics(s) {
	    var str = s ? String(s) : '';
	    for (var i = 0; i < str.length; i++) {
	      var currentChar = str.charAt(i);
	      if (_diacritics2["default"][currentChar]) {
	        str = str.replaceAll(currentChar, _diacritics2["default"][currentChar]);
	      }
	    }
	    return str;
	  }
	  function escapeRegExp() {
	    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	  }
	  var getPredictiveSuggestions = function getPredictiveSuggestions(_ref) {
	    var suggestions = _ref.suggestions,
	      currentValue = _ref.currentValue,
	      wordsToShowAfterHighlight = _ref.wordsToShowAfterHighlight;
	    var suggestionMap = {};
	    if (currentValue) {
	      var currentValueTrimmed = currentValue.trim();
	      var parsedSuggestion = suggestions.reduce(function (agg, _ref2) {
	        var label = _ref2.label,
	          rest = _objectWithoutProperties(_ref2, ['label']);
	        var parsedContent = new DOMParser().parseFromString(label, 'text/html').documentElement.textContent;
	        var regexString = '^(' + escapeRegExp(currentValueTrimmed) + ')\\w+';
	        var regex = new RegExp(regexString, 'i');
	        var regexExecution = regex.exec(parsedContent);
	        if (!regexExecution) {
	          regexString = '^(' + escapeRegExp(currentValueTrimmed) + ')';
	          regex = new RegExp(regexString, 'i');
	          regexExecution = regex.exec(parsedContent);
	        }
	        if (regexExecution) {
	          var matchedString = parsedContent.slice(regexExecution.index, parsedContent.length);
	          var highlightedWord = matchedString.slice(currentValueTrimmed.length).split(' ').slice(0, wordsToShowAfterHighlight + 1).join(' ');
	          var suggestionPhrase = currentValueTrimmed + '<mark class="highlight">' + highlightedWord + '</mark>';
	          var suggestionValue = '' + currentValueTrimmed + highlightedWord;
	          if (!suggestionMap[suggestionPhrase]) {
	            suggestionMap[suggestionPhrase] = 1;
	            return [].concat(_toConsumableArray(agg), [_extends({}, rest, {
	              label: suggestionPhrase,
	              value: suggestionValue,
	              isPredictiveSuggestion: true
	            })]);
	          }
	          return agg;
	        }
	        return agg;
	      }, []);
	      return parsedSuggestion;
	    }
	    return [];
	  };
	  var getSuggestions = function getSuggestions(_ref3) {
	    var fields = _ref3.fields,
	      suggestions = _ref3.suggestions,
	      currentValue = _ref3.currentValue,
	      _ref3$suggestionPrope = _ref3.suggestionProperties,
	      suggestionProperties = _ref3$suggestionPrope === undefined ? [] : _ref3$suggestionPrope,
	      _ref3$showDistinctSug = _ref3.showDistinctSuggestions,
	      showDistinctSuggestions = _ref3$showDistinctSug === undefined ? false : _ref3$showDistinctSug,
	      _ref3$enablePredictiv = _ref3.enablePredictiveSuggestions,
	      enablePredictiveSuggestions = _ref3$enablePredictiv === undefined ? false : _ref3$enablePredictiv,
	      _ref3$wordsToShowAfte = _ref3.wordsToShowAfterHighlight,
	      wordsToShowAfterHighlight = _ref3$wordsToShowAfte === undefined ? 2 : _ref3$wordsToShowAfte,
	      enableSynonyms = _ref3.enableSynonyms;
	    var suggestionsList = [];
	    var labelsList = [];
	    var skipWordMatch = false;
	    var populateSuggestionsList = function populateSuggestionsList(val, parsedSource, source) {
	      var isWordMatch = skipWordMatch || currentValue.trim().split(' ').some(function (term) {
	        return replaceDiacritics(val).toLowerCase().includes(replaceDiacritics(term));
	      });
	      if (isWordMatch && !labelsList.includes(val) || source._promoted) {
	        var defaultOption = {
	          label: val,
	          value: val,
	          source: source
	        };
	        var additionalKeys = {};
	        if (Array.isArray(suggestionProperties) && suggestionProperties.length > 0) {
	          suggestionProperties.forEach(function (prop) {
	            if (parsedSource.hasOwnProperty(prop)) {
	              additionalKeys = _extends({}, additionalKeys, _defineProperty({}, prop, parsedSource[prop]));
	            }
	          });
	        }
	        var option = _extends({}, defaultOption, additionalKeys);
	        labelsList = [].concat(_toConsumableArray(labelsList), [val]);
	        suggestionsList = [].concat(_toConsumableArray(suggestionsList), [option]);
	        if (showDistinctSuggestions) {
	          return true;
	        }
	      }
	      return false;
	    };
	    var parseField = function parseField(parsedSource) {
	      var field = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parsedSource;
	      if (typeof parsedSource === 'object') {
	        var fieldNodes = field.split('.');
	        var label = parsedSource[fieldNodes[0]];
	        if (parsedSource[field]) {
	          var topLabel = parsedSource[field];
	          var val = extractSuggestion(topLabel);
	          if (val && typeof val === 'string') {
	            return populateSuggestionsList(val, parsedSource, source);
	          }
	        }
	        if (Array.isArray(label)) {
	          if (label.length > 1) {
	            label = label.filter(function (i) {
	              return i && i.toString().toLowerCase().includes(currentValue.toString().toLowerCase());
	            });
	          }
	          label = label[0];
	        }
	        if (label) {
	          if (fieldNodes.length > 1) {
	            var children = field.substring(fieldNodes[0].length + 1);
	            parseField(label, children, source);
	          } else {
	            var _val = extractSuggestion(label);
	            if (_val) {
	              return populateSuggestionsList(_val, parsedSource, source);
	            }
	          }
	        }
	      }
	      return false;
	    };
	    var traverseSuggestions = function traverseSuggestions() {
	      suggestions.forEach(function (item) {
	        fields.forEach(function (field) {
	          parseField(item, field);
	        });
	      });
	    };
	    traverseSuggestions();
	    if (suggestionsList.length < suggestions.length && !skipWordMatch && enableSynonyms) {
	      skipWordMatch = true;
	      traverseSuggestions();
	    }
	    if (enablePredictiveSuggestions) {
	      var predictiveSuggestions = getPredictiveSuggestions({
	        suggestions: suggestionsList,
	        currentValue: currentValue,
	        wordsToShowAfterHighlight: wordsToShowAfterHighlight
	      });
	      suggestionsList = predictiveSuggestions;
	    }
	    if (showDistinctSuggestions) {
	      var idMap = {};
	      var filteredSuggestions = [];
	      suggestionsList.forEach(function (suggestion) {
	        if (suggestion.source && suggestion.source._id) {
	          if (!idMap[suggestion.source._id]) {
	            filteredSuggestions.push(suggestion);
	            idMap[suggestion.source._id] = true;
	          }
	        }
	      });
	      return filteredSuggestions;
	    }
	    return suggestionsList;
	  };
	  exports["default"] = getSuggestions;
	});
	unwrapExports(suggestions);
	var suggestions_1 = suggestions.replaceDiacritics;

	var helper = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.transformRequestUsingEndpoint = exports.flatten = exports.saveDataAsFile = exports.transformTreeListLocalStateIntoQueryComptaibleFormat = exports.transformRawTreeListData = exports.recLookup = exports.hasCustomRenderer = exports.getComponent = exports.isFunction = exports.getCalendarIntervalErrorMessage = exports.queryFormatMillisecondsMap = exports.featuredSuggestionsActionTypes = exports.suggestionTypes = exports.getTopSuggestions = exports.withClickIds = exports.getCompositeAggsQuery = exports.getAggsQuery = exports.extractQueryFromDefaultQuery = exports.updateInternalQuery = exports.getSearchState = exports.componentTypeToDefaultValue = exports.extractQueryFromCustomQuery = exports.getOptionsForCustomQuery = exports.getOptionsFromQuery = exports.parseHits = exports.handleA11yAction = exports.getInnerKey = exports.getClassName = exports.checkSomePropChange = exports.checkPropChange = exports.updateDefaultQuery = exports.updateCustomQuery = undefined;
	  var _componentTypeToDefau;
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.isEqual = isEqual;
	  exports.compareQueries = compareQueries;
	  exports.debounce = debounce;
	  exports.getQueryOptions = getQueryOptions;
	  exports.buildQuery = buildQuery;
	  exports.pushToAndClause = pushToAndClause;
	  exports.checkValueChange = checkValueChange;
	  exports.getAggsOrder = getAggsOrder;
	  exports.formatDate = formatDate;
	  exports.unwrapToNativeDate = unwrapToNativeDate;
	  exports.getResultStats = getResultStats;
	  exports.extractFieldsFromSource = extractFieldsFromSource;
	  exports.normalizeDataField = normalizeDataField;
	  exports.handleOnSuggestions = handleOnSuggestions;
	  exports.isValidDateRangeQueryFormat = isValidDateRangeQueryFormat;
	  exports.setDeep = setDeep;
	  var _dateFormats2 = _interopRequireDefault(dateFormats_1);
	  var _suggestions2 = _interopRequireDefault(suggestions);
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  function _objectWithoutProperties(obj, keys) {
	    var target = {};
	    for (var i in obj) {
	      if (keys.indexOf(i) >= 0) continue;
	      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	      target[i] = obj[i];
	    }
	    return target;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  var updateCustomQuery = exports.updateCustomQuery = function updateCustomQuery(componentId, props, value) {
	    if (props.customQuery && typeof props.customQuery === 'function') {
	      props.setCustomQuery(componentId, props.customQuery(value, props));
	    }
	  };
	  var updateDefaultQuery = exports.updateDefaultQuery = function updateDefaultQuery(componentId, props, value) {
	    if (props.defaultQuery && typeof props.defaultQuery === 'function') {
	      props.setDefaultQuery(componentId, props.defaultQuery(value, props));
	    }
	  };
	  function isEqual(x, y) {
	    if (x === y) return true;
	    if (!(x instanceof Object) || !(y instanceof Object)) return false;
	    if (x.constructor !== y.constructor) return false;
	    for (var p in x) {
	      if (!x.hasOwnProperty(p)) continue;
	      if (!y.hasOwnProperty(p)) return false;
	      if (x[p] === y[p]) continue;
	      if (typeof x[p] !== 'object') return false;
	      if (!isEqual(x[p], y[p])) return false;
	    }
	    for (var _p in y) {
	      if (y.hasOwnProperty(_p) && !x.hasOwnProperty(_p)) return false;
	    }
	    return true;
	  }
	  function compareQueries(x, y) {
	    try {
	      return isEqual(JSON.parse(JSON.stringify(x)), JSON.parse(JSON.stringify(y)));
	    } catch (e) {
	      return false;
	    }
	  }
	  function debounce(callback, wait) {
	    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this;
	    if (!wait) {
	      return callback;
	    }
	    var timeout = null;
	    var callbackArgs = null;
	    var later = function later() {
	      return callback.apply(context, callbackArgs);
	    };
	    return function debouncedFunction() {
	      callbackArgs = arguments;
	      clearTimeout(timeout);
	      timeout = setTimeout(later, wait);
	    };
	  }
	  function getQueryOptions(props) {
	    var options = {};
	    if (props.size !== undefined) {
	      options.size = props.size;
	    }
	    if (props.includeFields || props.excludeFields) {
	      var source = {};
	      if (props.includeFields) {
	        source.includes = props.includeFields;
	      }
	      if (props.excludeFields) {
	        source.excludes = props.excludeFields;
	      }
	      options._source = source;
	    }
	    return options;
	  }
	  function getOperation(conjunction) {
	    if (conjunction === 'and') {
	      return 'must';
	    }
	    if (conjunction === 'or') {
	      return 'should';
	    }
	    return 'must_not';
	  }
	  function createBoolQuery(operation, query) {
	    var resultQuery = null;
	    if (Array.isArray(query) && query.length || !Array.isArray(query) && query) {
	      resultQuery = {
	        bool: _defineProperty({}, operation, query)
	      };
	    }
	    if (operation === 'should' && resultQuery) {
	      resultQuery = {
	        bool: _extends({}, resultQuery.bool, {
	          minimum_should_match: 1
	        })
	      };
	    }
	    return resultQuery;
	  }
	  function getQuery(react, queryList) {
	    var query = [];
	    Object.keys(react).forEach(function (conjunction) {
	      if (Array.isArray(react[conjunction])) {
	        var operation = getOperation(conjunction);
	        var queryArr = react[conjunction].map(function (comp) {
	          if (typeof comp !== 'string') {
	            return getQuery(comp, queryList);
	          } else if (comp in queryList) {
	            if (queryList[comp] && Object.keys(queryList[comp]).length) {
	              return queryList[comp];
	            }
	          }
	          return null;
	        }).filter(function (item) {
	          return !!item;
	        });
	        var boolQuery = createBoolQuery(operation, queryArr);
	        if (boolQuery && Object.keys(boolQuery).length) {
	          query = [].concat(_toConsumableArray(query), [boolQuery]);
	        }
	      } else if (typeof react[conjunction] === 'string') {
	        var _operation = getOperation(conjunction);
	        var _boolQuery = createBoolQuery(_operation, queryList[react[conjunction]]);
	        if (_boolQuery && Object.keys(_boolQuery).length) {
	          query = [].concat(_toConsumableArray(query), [_boolQuery]);
	        }
	      } else if (typeof react[conjunction] === 'object' && react[conjunction] !== null) {
	        var _boolQuery2 = getQuery(react[conjunction], queryList);
	        if (_boolQuery2 && Object.keys(_boolQuery2).length) {
	          query = [].concat(_toConsumableArray(query), [_boolQuery2]);
	        }
	      }
	    });
	    if (Array.isArray(query) && query.length) {
	      return {
	        bool: {
	          must: query
	        }
	      };
	    }
	    if (query && Object.keys(query).length) {
	      return query;
	    }
	    return null;
	  }
	  function getExternalQueryOptions(react, options, component) {
	    var queryOptions = {};
	    Object.keys(react).forEach(function (conjunction) {
	      if (Array.isArray(react[conjunction])) {
	        react[conjunction].forEach(function (comp) {
	          if (options[comp]) {
	            queryOptions = _extends({}, queryOptions, options[comp]);
	          }
	        });
	      } else if (typeof react[conjunction] === 'string') {
	        if (options[react[conjunction]]) {
	          queryOptions = _extends({}, queryOptions, options[react[conjunction]]);
	        }
	      } else if (typeof react[conjunction] === 'object' && react[conjunction] !== null && !Array.isArray(react[conjunction])) {
	        queryOptions = _extends({}, queryOptions, getExternalQueryOptions(react[conjunction], options));
	      }
	    });
	    if (options[component]) {
	      queryOptions = _extends({}, queryOptions, options[component]);
	    }
	    return queryOptions;
	  }
	  function buildQuery(component, dependencyTree, queryList, queryOptions) {
	    var queryObj = null;
	    var options = null;
	    if (component in dependencyTree) {
	      queryObj = getQuery(dependencyTree[component], queryList);
	      options = getExternalQueryOptions(dependencyTree[component], queryOptions, component);
	    }
	    return {
	      queryObj: queryObj,
	      options: options
	    };
	  }
	  function pushToAndClause(reactProp, component) {
	    var react = _extends({}, reactProp);
	    if (react.and) {
	      if (Array.isArray(react.and)) {
	        react.and = [].concat(_toConsumableArray(react.and), [component]);
	        return react;
	      } else if (typeof react.and === 'string') {
	        react.and = [react.and, component];
	        return react;
	      }
	      react.and = pushToAndClause(react.and, component);
	      return react;
	    }
	    return _extends({}, react, {
	      and: component
	    });
	  }
	  function checkValueChange(componentId, value, beforeValueChange, performUpdate) {
	    var selectedValue = value;
	    if (Array.isArray(value) && !value.length) {
	      selectedValue = null;
	    }
	    var handleError = function handleError(e) {
	      console.warn(componentId + ' - beforeValueChange rejected the promise with ', e);
	    };
	    if (beforeValueChange) {
	      try {
	        var promise = beforeValueChange(selectedValue);
	        if (promise instanceof Promise) {
	          promise.then(performUpdate)["catch"](handleError);
	        } else {
	          performUpdate();
	        }
	      } catch (e) {
	        handleError(e);
	      }
	    } else {
	      performUpdate();
	    }
	  }
	  function getAggsOrder(sortBy) {
	    if (sortBy === 'count') {
	      return {
	        _count: 'desc'
	      };
	    }
	    return {
	      _key: sortBy
	    };
	  }
	  var checkPropChange = exports.checkPropChange = function checkPropChange(prevProp, nextProp, callback) {
	    if (!isEqual(prevProp, nextProp)) {
	      callback();
	      return true;
	    }
	    return false;
	  };
	  var checkSomePropChange = exports.checkSomePropChange = function checkSomePropChange() {
	    var prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var nextProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var propsList = arguments[2];
	    var callback = arguments[3];
	    propsList.some(function (prop) {
	      return checkPropChange(prevProps[prop], nextProps[prop], callback);
	    });
	  };
	  var getClassName = exports.getClassName = function getClassName(classMap, component) {
	    return classMap && classMap[component] || '';
	  };
	  var getInnerKey = exports.getInnerKey = function getInnerKey(obj, key) {
	    return obj && obj[key] || {};
	  };
	  var handleA11yAction = exports.handleA11yAction = function handleA11yAction(e, callback) {
	    if (e.key === 'Enter' || e.key === ' ') {
	      e.preventDefault();
	      callback();
	    }
	  };
	  var highlightResults = function highlightResults(result) {
	    var data = _extends({}, result);
	    if (data.highlight) {
	      Object.keys(data.highlight).forEach(function (highlightItem) {
	        var highlightValue = data.highlight[highlightItem][0];
	        data._source = _extends({}, data._source, _defineProperty({}, highlightItem, highlightValue));
	      });
	    }
	    return data;
	  };
	  var parseHits = exports.parseHits = function parseHits(hits) {
	    var showHighlighted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    var results = null;
	    if (hits) {
	      results = [].concat(_toConsumableArray(hits)).map(function (item) {
	        var data = _extends({}, item);
	        if (showHighlighted) data = highlightResults(item);
	        var result = Object.keys(data).filter(function (key) {
	          return key !== '_source';
	        }).reduce(function (obj, key) {
	          obj[key] = data[key];
	          return obj;
	        }, _extends({
	          highlight: data.highlight || {}
	        }, data._source));
	        return result;
	      });
	    }
	    return results;
	  };
	  function formatDate(date, props) {
	    if (props.parseDate) {
	      return props.parseDate(date, props);
	    }
	    switch (props.queryFormat) {
	      case 'epoch_millis':
	        return date.valueOf();
	      case 'epoch_second':
	        return Math.floor(date.valueOf() / 1000);
	      default:
	        {
	          if (_dateFormats2["default"][props.queryFormat]) {
	            return date.format(_dateFormats2["default"][props.queryFormat]);
	          }
	          return date.valueOf();
	        }
	    }
	  }
	  function unwrapToNativeDate(wrappedDateInstance) {
	    if (wrappedDateInstance) {
	      return new Date(wrappedDateInstance.valueOf());
	    }
	    return wrappedDateInstance;
	  }
	  var getOptionsFromQuery = function getOptionsFromQuery() {
	    var customQuery = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    if (customQuery) {
	      var query = customQuery.query,
	        rest = _objectWithoutProperties(customQuery, ['query']);
	      return Object.keys(rest).length ? rest : null;
	    }
	    return null;
	  };
	  exports.getOptionsFromQuery = getOptionsFromQuery;
	  var getOptionsForCustomQuery = function getOptionsForCustomQuery() {
	    var customQuery = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    if (customQuery) {
	      var query = customQuery.query,
	        id = customQuery.id,
	        params = customQuery.params,
	        rest = _objectWithoutProperties(customQuery, ['query', 'id', 'params']);
	      return Object.keys(rest).length ? rest : null;
	    }
	    return null;
	  };
	  exports.getOptionsForCustomQuery = getOptionsForCustomQuery;
	  var extractQueryFromCustomQuery = exports.extractQueryFromCustomQuery = function extractQueryFromCustomQuery(customQuery) {
	    if (customQuery) {
	      if (customQuery.id) {
	        return {
	          id: customQuery.id,
	          params: customQuery.params
	        };
	      }
	      return customQuery.query;
	    }
	    return null;
	  };
	  function computeResultStats() {
	    var hits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var searchState = arguments[1];
	    var promotedResults = arguments[2];
	    Object.keys(hits).forEach(function (componentId) {
	      var _ref = hits[componentId] || {},
	        hidden = _ref.hidden,
	        total = _ref.total,
	        time = _ref.time;
	      searchState[componentId] = _extends({}, searchState[componentId], {
	        resultStats: _extends({}, searchState[componentId].resultStats, {
	          numberOfResults: total,
	          time: time,
	          promoted: promotedResults[componentId] && promotedResults[componentId].length,
	          hidden: hidden || 0
	        })
	      });
	    });
	  }
	  var componentTypeToDefaultValue = exports.componentTypeToDefaultValue = (_componentTypeToDefau = {}, _defineProperty(_componentTypeToDefau, constants$1.componentTypes.singleList, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.multiList, []), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.singleDataList, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.singleDropdownList, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.multiDataList, []), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.multiDropdownList, []), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.tagCloud, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.toggleButton, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.singleDropdownRange, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.multiDropdownRange, []), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.singleRange, ''), _defineProperty(_componentTypeToDefau, constants$1.componentTypes.multiRange, []), _componentTypeToDefau);
	  var getSearchState = exports.getSearchState = function getSearchState() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var forHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var selectedValues = state.selectedValues,
	      queryLog = state.queryLog,
	      dependencyTree = state.dependencyTree,
	      props = state.props,
	      hits = state.hits,
	      aggregations = state.aggregations,
	      isLoading = state.isLoading,
	      error = state.error,
	      promotedResults = state.promotedResults,
	      settings = state.settings,
	      customData = state.customData,
	      rawData = state.rawData;
	    var searchState = {};
	    var populateState = function populateState() {
	      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var key = arguments[1];
	      return Object.keys(obj).forEach(function (componentId) {
	        searchState[componentId] = _extends({}, searchState[componentId], key ? _defineProperty({}, key, obj[componentId]) : obj[componentId]);
	      });
	    };
	    populateState(props);
	    Object.keys(selectedValues || {}).forEach(function (componentId) {
	      var componentState = searchState[componentId];
	      var selectedValue = selectedValues[componentId];
	      var componentProps = props[componentId];
	      var componentType = componentProps ? componentProps.componentType : null;
	      if (selectedValue) {
	        var s = _extends({}, componentState, _extends({
	          title: selectedValue.label,
	          componentType: selectedValue.componentType,
	          value: selectedValue.value || componentTypeToDefaultValue[componentType]
	        }, selectedValue.category && {
	          category: selectedValue.category
	        }, {
	          URLParams: selectedValue.URLParams
	        }));
	        if (Object.keys(s).length) {
	          searchState[componentId] = s;
	        }
	      }
	    });
	    if (!forHeaders) {
	      populateState(queryLog);
	      populateState(hits, 'hits');
	      populateState(aggregations, 'aggregations');
	      populateState(isLoading, 'isLoading');
	      populateState(error, 'error');
	      populateState(promotedResults, 'promotedData');
	      populateState(settings, 'settings');
	      populateState(customData, 'customData');
	      populateState(rawData, 'rawData');
	      computeResultStats(hits, searchState, promotedResults);
	    }
	    populateState(dependencyTree, 'react');
	    return searchState;
	  };
	  var updateInternalQuery = exports.updateInternalQuery = function updateInternalQuery(componentId, queryOptions, value, props, defaultQueryToExecute, queryParams) {
	    var defaultQuery = props.defaultQuery;
	    var defaultQueryOptions = void 0;
	    var query = defaultQueryToExecute;
	    if (defaultQuery) {
	      var queryTobeSet = defaultQuery(value, props);
	      var _ref3 = queryTobeSet || {};
	      query = _ref3.query;
	      defaultQueryOptions = getOptionsFromQuery(queryTobeSet);
	      updateDefaultQuery(componentId, props, value);
	    }
	    if (query) {
	      props.setQueryOptions(componentId, _extends({}, defaultQueryOptions, queryOptions || defaultQueryToExecute));
	      props.updateQuery(_extends({
	        componentId: componentId,
	        query: query,
	        value: value
	      }, queryParams));
	    } else {
	      props.setQueryOptions(componentId, _extends({}, defaultQueryOptions, queryOptions || defaultQueryToExecute));
	    }
	  };
	  var extractQueryFromDefaultQuery = function extractQueryFromDefaultQuery(props, value) {
	    var queryToBeReturned = {};
	    var defaultQuery = props.defaultQuery;
	    if (defaultQuery) {
	      var evaluateQuery = defaultQuery(value, props);
	      if (evaluateQuery) {
	        var query = evaluateQuery.query,
	          options = _objectWithoutProperties(evaluateQuery, ['query']);
	        if (options) {
	          queryToBeReturned = options;
	        }
	      }
	    }
	    return queryToBeReturned;
	  };
	  exports.extractQueryFromDefaultQuery = extractQueryFromDefaultQuery;
	  var getAggsQuery = exports.getAggsQuery = function getAggsQuery(value, query, props) {
	    var clonedQuery = query;
	    var dataField = props.dataField,
	      size = props.size,
	      sortBy = props.sortBy,
	      showMissing = props.showMissing,
	      missingLabel = props.missingLabel,
	      aggregationSize = props.aggregationSize;
	    clonedQuery.size = 0;
	    if (typeof dataField === 'string') {
	      clonedQuery.aggs = _defineProperty({}, dataField, {
	        terms: _extends({
	          field: dataField,
	          size: size,
	          aggregationSize: aggregationSize,
	          order: getAggsOrder(sortBy || 'count')
	        }, showMissing ? {
	          missing: missingLabel
	        } : {})
	      });
	    } else {
	      var aggs = void 0;
	      [].concat(_toConsumableArray(dataField)).reverse().forEach(function (dataFieldItem) {
	        aggs = _defineProperty({}, dataFieldItem, {
	          terms: _extends({
	            field: dataFieldItem,
	            size: size,
	            aggregationSize: aggregationSize,
	            order: getAggsOrder(sortBy || 'count')
	          }, showMissing ? {
	            missing: missingLabel
	          } : {}),
	          aggs: aggs
	        });
	      });
	      clonedQuery.aggs = aggs;
	    }
	    if (props.nestedField) {
	      clonedQuery.aggs = {
	        reactivesearch_nested: {
	          nested: {
	            path: props.nestedField
	          },
	          aggs: clonedQuery.aggs
	        }
	      };
	    }
	    return _extends({}, clonedQuery, extractQueryFromDefaultQuery(props, value));
	  };
	  var getCompositeAggsQuery = exports.getCompositeAggsQuery = function getCompositeAggsQuery() {
	    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref4$query = _ref4.query,
	      query = _ref4$query === undefined ? {} : _ref4$query,
	      props = _ref4.props,
	      _ref4$after = _ref4.after,
	      after = _ref4$after === undefined ? null : _ref4$after,
	      _ref4$showTopHits = _ref4.showTopHits,
	      showTopHits = _ref4$showTopHits === undefined ? false : _ref4$showTopHits,
	      value = _ref4.value;
	    var clonedQuery = query;
	    var dataField = props.dataField,
	      size = props.size,
	      sortBy = props.sortBy,
	      showMissing = props.showMissing,
	      aggregationField = props.aggregationField;
	    var finalField = aggregationField || dataField;
	    var order = sortBy === 'count' ? {} : {
	      order: sortBy
	    };
	    clonedQuery.aggs = _defineProperty({}, finalField, _extends({
	      composite: _extends({
	        sources: [_defineProperty({}, finalField, {
	          terms: _extends({
	            field: finalField
	          }, order, showMissing ? {
	            missing_bucket: true
	          } : {})
	        })],
	        size: size
	      }, after)
	    }, showTopHits ? {
	      aggs: _defineProperty({}, finalField, {
	        top_hits: {
	          size: 1
	        }
	      })
	    } : {}));
	    clonedQuery.size = 0;
	    if (props.nestedField) {
	      clonedQuery.aggs = {
	        reactivesearch_nested: {
	          nested: {
	            path: props.nestedField
	          },
	          aggs: clonedQuery.aggs
	        }
	      };
	    }
	    return _extends({}, clonedQuery, extractQueryFromDefaultQuery(props, value));
	  };
	  var withClickIds = exports.withClickIds = function withClickIds() {
	    var results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    return results.map(function (result, index) {
	      return _extends({}, result, {
	        _click_id: index
	      });
	    });
	  };
	  function getResultStats(props) {
	    var total = props.total,
	      size = props.size,
	      time = props.time,
	      hidden = props.hidden,
	      promotedResults = props.promotedResults;
	    return _extends({
	      numberOfResults: total
	    }, size > 0 ? {
	      numberOfPages: Math.ceil(total / size)
	    } : null, {
	      time: time || 0,
	      hidden: hidden,
	      promoted: promotedResults ? promotedResults.length : 0
	    });
	  }
	  function extractFieldsFromSource(esSource) {
	    function getFields() {
	      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      return Object.keys(source).reduce(function () {
	        var acc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	        var k = arguments[1];
	        var key = prefix ? prefix + '.' + k : k;
	        if (!Number.isNaN(parseInt(k, 10))) {
	          key = prefix || k;
	        }
	        if (source[k] && typeof source[k] === 'object') {
	          return _extends({}, acc, getFields(source[k], key));
	        }
	        return _extends({}, acc, _defineProperty({}, key, true));
	      }, []);
	    }
	    var fields = getFields(esSource);
	    return Object.keys(fields);
	  }
	  function normalizeDataField(dataField) {
	    var fieldWeights = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    if (typeof dataField === 'string') {
	      return [{
	        field: dataField,
	        weight: fieldWeights.length ? fieldWeights[0] : undefined
	      }];
	    }
	    if (Array.isArray(dataField)) {
	      return dataField.map(function (field, index) {
	        var normalizedField = {};
	        if (typeof field === 'string') {
	          normalizedField.field = field;
	          if (fieldWeights.length > index) {
	            normalizedField.weight = fieldWeights[index];
	          }
	        } else if (typeof field === 'object' && field && field.field) {
	          normalizedField.field = field.field;
	          normalizedField.weight = field.weight;
	        }
	        return normalizedField;
	      });
	    }
	    if (typeof dataField === 'object' && dataField) {
	      return [{
	        field: dataField.field,
	        weight: dataField.weight
	      }];
	    }
	    return [];
	  }
	  function handleOnSuggestions(results, currentValue, props) {
	    var parseSuggestion = props.parseSuggestion,
	      promotedResults = props.promotedResults,
	      enablePredictiveSuggestions = props.enablePredictiveSuggestions;
	    var fields = [];
	    if (props.dataField) {
	      fields = normalizeDataField(props.dataField).map(function (f) {
	        return f.field;
	      });
	    } else if (results && Array.isArray(results) && results.length > 0 && results[0] && results[0]._source) {
	      fields = extractFieldsFromSource(results[0]._source);
	    }
	    var newResults = parseHits(results, false);
	    var parsedPromotedResults = parseHits(promotedResults, false);
	    if (parsedPromotedResults && parsedPromotedResults.length) {
	      var ids = parsedPromotedResults.map(function (item) {
	        return item._id;
	      }).filter(Boolean);
	      if (ids) {
	        newResults = newResults.filter(function (item) {
	          return !ids.includes(item._id);
	        });
	      }
	      newResults = [].concat(_toConsumableArray(parsedPromotedResults), _toConsumableArray(newResults));
	    }
	    var parsedSuggestions = (0, _suggestions2["default"])({
	      fields: fields,
	      suggestions: newResults,
	      currentValue: currentValue.toLowerCase(),
	      showDistinctSuggestions: props.showDistinctSuggestions,
	      enablePredictiveSuggestions: enablePredictiveSuggestions,
	      enableSynonyms: props.enableSynonyms
	    });
	    if (parseSuggestion) {
	      return parsedSuggestions.map(function (suggestion) {
	        return parseSuggestion(suggestion);
	      });
	    }
	    return parsedSuggestions;
	  }
	  var getTopSuggestions = exports.getTopSuggestions = function getTopSuggestions(querySuggestions) {
	    var currentValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	    var showDistinctSuggestions = arguments[2];
	    var parsedSuggestions = parseHits(querySuggestions, false);
	    var finalSuggestions = (0, _suggestions2["default"])({
	      fields: ['key', 'key.autosuggest', 'key.search'],
	      suggestions: parsedSuggestions || [],
	      currentValue: currentValue.toLowerCase(),
	      showDistinctSuggestions: showDistinctSuggestions
	    });
	    return withClickIds(finalSuggestions);
	  };
	  function isValidDateRangeQueryFormat(queryFormat) {
	    return Object.keys(_dateFormats2["default"]).includes(queryFormat);
	  }
	  var suggestionTypes = exports.suggestionTypes = {
	    Popular: 'popular',
	    Index: 'index',
	    Recent: 'recent',
	    Promoted: 'promoted',
	    Featured: 'featured'
	  };
	  var featuredSuggestionsActionTypes = exports.featuredSuggestionsActionTypes = {
	    NAVIGATE: 'navigate',
	    FUNCTION: 'function',
	    SELECT: 'select'
	  };
	  var queryFormatMillisecondsMap = exports.queryFormatMillisecondsMap = {
	    minute: 60000,
	    hour: 3600000,
	    day: 86400000,
	    week: 604800000,
	    month: 2629746000,
	    quarter: 7889238000,
	    year: 31556952000
	  };
	  var getCalendarIntervalErrorMessage = exports.getCalendarIntervalErrorMessage = function getCalendarIntervalErrorMessage(totalRange) {
	    var calendarInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'minute';
	    var queryFormatMillisecondsMapKeys = Object.keys(queryFormatMillisecondsMap);
	    var indexOfCurrentCalendarInterval = queryFormatMillisecondsMapKeys.indexOf(calendarInterval);
	    if (indexOfCurrentCalendarInterval === -1) {
	      console.error('Invalid calendarInterval Passed');
	    }
	    if (calendarInterval === 'year') {
	      return 'Try using a shorter range of values.';
	    }
	    for (var index = indexOfCurrentCalendarInterval + 1; index < queryFormatMillisecondsMapKeys.length; index += 1) {
	      if (totalRange / Object.values(queryFormatMillisecondsMap)[index] <= 100) {
	        var calendarIntervalKey = queryFormatMillisecondsMapKeys[index];
	        return {
	          errorMessage: 'Please pass calendarInterval prop with value greater than or equal to a `' + calendarIntervalKey + '` for a meaningful resolution of histogram.',
	          calculatedCalendarInterval: calendarIntervalKey
	        };
	      }
	    }
	    return {
	      errorMessage: 'Try using a shorter range of values.',
	      calculatedCalendarInterval: 'year'
	    };
	  };
	  var isFunction = exports.isFunction = function isFunction(element) {
	    return typeof element === 'function';
	  };
	  var getComponent = exports.getComponent = function getComponent() {
	    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var children = props.children,
	      render = props.render;
	    if (isFunction(children)) {
	      return children(data);
	    }
	    if (isFunction(render)) {
	      return render(data);
	    }
	    return null;
	  };
	  var hasCustomRenderer = exports.hasCustomRenderer = function hasCustomRenderer() {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var render = props.render,
	      children = props.children;
	    return isFunction(children) || isFunction(render);
	  };
	  var recLookup = exports.recLookup = function recLookup(obj, path) {
	    var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
	    try {
	      var parts = path.split(separator);
	      if (parts.length === 1) {
	        return obj[parts[0]];
	      }
	      return recLookup(obj[parts[0]], parts.slice(1).join(separator), separator);
	    } catch (e) {
	      return false;
	    }
	  };
	  function setDeep(obj, path, value) {
	    var setrecursively = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	    path.reduce(function (acc, currentItem, level) {
	      if (setrecursively && typeof acc[currentItem] !== 'object' && level !== path.length - 1) {
	        acc[currentItem] = {};
	        return acc[currentItem];
	      }
	      if (level === path.length - 1) {
	        acc[currentItem] = value;
	        return value;
	      }
	      return typeof acc[currentItem] === 'object' ? acc[currentItem] : {};
	    }, obj);
	  }
	  var transformRawTreeListData = exports.transformRawTreeListData = function transformRawTreeListData(data, dataField) {
	    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var newState = [];
	    if (data instanceof Object) {
	      var aggsKeys = Object.keys(data);
	      aggsKeys.forEach(function (key) {
	        if (Array.isArray(data[key].buckets)) {
	          data[key].buckets.forEach(function (bucket) {
	            newState.push(_extends({
	              key: bucket.key,
	              count: bucket.doc_count,
	              level: level
	            }, bucket[dataField[level + 1]] instanceof Object ? {
	              list: transformRawTreeListData(_defineProperty({}, dataField[level + 1], bucket[dataField[level + 1]]), dataField, level + 1)
	            } : {}));
	          });
	        }
	      });
	    }
	    return newState;
	  };
	  var transformTreeListLocalStateIntoQueryComptaibleFormat = exports.transformTreeListLocalStateIntoQueryComptaibleFormat = function transformTreeListLocalStateIntoQueryComptaibleFormat(obj) {
	    var currentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	    var result = [];
	    if (obj instanceof Object) {
	      if (Object.keys(obj).length) {
	        Object.keys(obj).forEach(function (key) {
	          if (obj[key] instanceof Object) {
	            result.push.apply(result, _toConsumableArray(transformTreeListLocalStateIntoQueryComptaibleFormat(obj[key], currentPath ? currentPath + ' > ' + key : key)));
	          }
	          if (obj[key] === true) {
	            result.push(currentPath ? currentPath + ' > ' + key : key);
	          }
	        });
	      } else if (currentPath) {
	        result.push(currentPath);
	      }
	    }
	    return result;
	  };
	  var saveDataAsFile = exports.saveDataAsFile = function saveDataAsFile() {
	    var filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'exportedData';
	    var data = arguments[1];
	    var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'csv';
	    var dataToWrite = data;
	    var dataType = 'text/' + format;
	    if (format === 'json') {
	      dataToWrite = JSON.stringify(dataToWrite, 0, 4);
	    }
	    var blob = new Blob([dataToWrite], {
	      type: dataType
	    });
	    var link = document.createElement('a');
	    link.download = filename + '.' + format;
	    link.href = window.URL.createObjectURL(blob);
	    link.dataset.downloadurl = [dataType, link.download, link.href].join(':');
	    var evt = new MouseEvent('click', {
	      view: window,
	      bubbles: true,
	      cancelable: true
	    });
	    link.dispatchEvent(evt);
	    link.remove();
	  };
	  var flatten = exports.flatten = function flatten(data) {
	    var result = {};
	    function recurse(cur) {
	      var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      if (Object(cur) !== cur) {
	        result[prop] = cur;
	      } else if (Array.isArray(cur)) {
	        result[prop] = JSON.stringify(cur);
	      } else {
	        var isEmpty = true;
	        Object.keys(cur).forEach(function (p) {
	          isEmpty = false;
	          recurse(cur[p], prop ? prop + '.' + p : p);
	        });
	        if (isEmpty && prop) {
	          result[prop] = {};
	        }
	      }
	    }
	    recurse(data);
	    return result;
	  };
	  var transformRequestUsingEndpoint = function transformRequestUsingEndpoint(request, endpointParam) {
	    if (endpointParam instanceof Object) {
	      var _endpointParam$header = endpointParam.headers,
	        headers = _endpointParam$header === undefined ? {} : _endpointParam$header,
	        body = endpointParam.body,
	        rest = _objectWithoutProperties(endpointParam, ['headers', 'body']);
	      var endpointModifiedRequest = _extends({}, request, rest, {
	        headers: _extends({}, request.headers, headers)
	      }, body instanceof Object ? {
	        body: JSON.stringify(body)
	      } : {});
	      return endpointModifiedRequest;
	    }
	    return request;
	  };
	  exports.transformRequestUsingEndpoint = transformRequestUsingEndpoint;
	});
	unwrapExports(helper);
	var helper_1 = helper.transformRequestUsingEndpoint;
	var helper_2 = helper.flatten;
	var helper_3 = helper.saveDataAsFile;
	var helper_4 = helper.transformTreeListLocalStateIntoQueryComptaibleFormat;
	var helper_5 = helper.transformRawTreeListData;
	var helper_6 = helper.recLookup;
	var helper_7 = helper.hasCustomRenderer;
	var helper_8 = helper.getComponent;
	var helper_9 = helper.isFunction;
	var helper_10 = helper.getCalendarIntervalErrorMessage;
	var helper_11 = helper.queryFormatMillisecondsMap;
	var helper_12 = helper.featuredSuggestionsActionTypes;
	var helper_13 = helper.suggestionTypes;
	var helper_14 = helper.getTopSuggestions;
	var helper_15 = helper.withClickIds;
	var helper_16 = helper.getCompositeAggsQuery;
	var helper_17 = helper.getAggsQuery;
	var helper_18 = helper.extractQueryFromDefaultQuery;
	var helper_19 = helper.updateInternalQuery;
	var helper_20 = helper.getSearchState;
	var helper_21 = helper.componentTypeToDefaultValue;
	var helper_22 = helper.extractQueryFromCustomQuery;
	var helper_23 = helper.getOptionsForCustomQuery;
	var helper_24 = helper.getOptionsFromQuery;
	var helper_25 = helper.parseHits;
	var helper_26 = helper.handleA11yAction;
	var helper_27 = helper.getInnerKey;
	var helper_28 = helper.getClassName;
	var helper_29 = helper.checkSomePropChange;
	var helper_30 = helper.checkPropChange;
	var helper_31 = helper.updateDefaultQuery;
	var helper_32 = helper.updateCustomQuery;
	var helper_33 = helper.isEqual;
	var helper_34 = helper.compareQueries;
	var helper_35 = helper.debounce;
	var helper_36 = helper.getQueryOptions;
	var helper_37 = helper.buildQuery;
	var helper_38 = helper.pushToAndClause;
	var helper_39 = helper.checkValueChange;
	var helper_40 = helper.getAggsOrder;
	var helper_41 = helper.formatDate;
	var helper_42 = helper.unwrapToNativeDate;
	var helper_43 = helper.getResultStats;
	var helper_44 = helper.extractFieldsFromSource;
	var helper_45 = helper.normalizeDataField;
	var helper_46 = helper.handleOnSuggestions;
	var helper_47 = helper.isValidDateRangeQueryFormat;
	var helper_48 = helper.setDeep;

	var dayjs_min = createCommonjsModule(function (module, exports) {
	  !function (t, e) {
	     module.exports = e() ;
	  }(commonjsGlobal, function () {

	    var t = 1e3,
	      e = 6e4,
	      n = 36e5,
	      r = "millisecond",
	      i = "second",
	      s = "minute",
	      u = "hour",
	      a = "day",
	      o = "week",
	      f = "month",
	      h = "quarter",
	      c = "year",
	      d = "date",
	      l = "Invalid Date",
	      $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
	      y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
	      M = {
	        name: "en",
	        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
	        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
	        ordinal: function ordinal(t) {
	          var e = ["th", "st", "nd", "rd"],
	            n = t % 100;
	          return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
	        }
	      },
	      m = function m(t, e, n) {
	        var r = String(t);
	        return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
	      },
	      v = {
	        s: m,
	        z: function z(t) {
	          var e = -t.utcOffset(),
	            n = Math.abs(e),
	            r = Math.floor(n / 60),
	            i = n % 60;
	          return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
	        },
	        m: function t(e, n) {
	          if (e.date() < n.date()) return -t(n, e);
	          var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
	            i = e.clone().add(r, f),
	            s = n - i < 0,
	            u = e.clone().add(r + (s ? -1 : 1), f);
	          return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
	        },
	        a: function a(t) {
	          return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
	        },
	        p: function p(t) {
	          return {
	            M: f,
	            y: c,
	            w: o,
	            d: a,
	            D: d,
	            h: u,
	            m: s,
	            s: i,
	            ms: r,
	            Q: h
	          }[t] || String(t || "").toLowerCase().replace(/s$/, "");
	        },
	        u: function u(t) {
	          return void 0 === t;
	        }
	      },
	      g = "en",
	      D = {};
	    D[g] = M;
	    var p = function p(t) {
	        return t instanceof _;
	      },
	      S = function t(e, n, r) {
	        var i;
	        if (!e) return g;
	        if ("string" == typeof e) {
	          var s = e.toLowerCase();
	          D[s] && (i = s), n && (D[s] = n, i = s);
	          var u = e.split("-");
	          if (!i && u.length > 1) return t(u[0]);
	        } else {
	          var a = e.name;
	          D[a] = e, i = a;
	        }
	        return !r && i && (g = i), i || !r && g;
	      },
	      w = function w(t, e) {
	        if (p(t)) return t.clone();
	        var n = "object" == typeof e ? e : {};
	        return n.date = t, n.args = arguments, new _(n);
	      },
	      O = v;
	    O.l = S, O.i = p, O.w = function (t, e) {
	      return w(t, {
	        locale: e.$L,
	        utc: e.$u,
	        x: e.$x,
	        $offset: e.$offset
	      });
	    };
	    var _ = function () {
	        function M(t) {
	          this.$L = S(t.locale, null, !0), this.parse(t);
	        }
	        var m = M.prototype;
	        return m.parse = function (t) {
	          this.$d = function (t) {
	            var e = t.date,
	              n = t.utc;
	            if (null === e) return new Date(NaN);
	            if (O.u(e)) return new Date();
	            if (e instanceof Date) return new Date(e);
	            if ("string" == typeof e && !/Z$/i.test(e)) {
	              var r = e.match($);
	              if (r) {
	                var i = r[2] - 1 || 0,
	                  s = (r[7] || "0").substring(0, 3);
	                return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
	              }
	            }
	            return new Date(e);
	          }(t), this.$x = t.x || {}, this.init();
	        }, m.init = function () {
	          var t = this.$d;
	          this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
	        }, m.$utils = function () {
	          return O;
	        }, m.isValid = function () {
	          return !(this.$d.toString() === l);
	        }, m.isSame = function (t, e) {
	          var n = w(t);
	          return this.startOf(e) <= n && n <= this.endOf(e);
	        }, m.isAfter = function (t, e) {
	          return w(t) < this.startOf(e);
	        }, m.isBefore = function (t, e) {
	          return this.endOf(e) < w(t);
	        }, m.$g = function (t, e, n) {
	          return O.u(t) ? this[e] : this.set(n, t);
	        }, m.unix = function () {
	          return Math.floor(this.valueOf() / 1e3);
	        }, m.valueOf = function () {
	          return this.$d.getTime();
	        }, m.startOf = function (t, e) {
	          var n = this,
	            r = !!O.u(e) || e,
	            h = O.p(t),
	            l = function l(t, e) {
	              var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
	              return r ? i : i.endOf(a);
	            },
	            $ = function $(t, e) {
	              return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
	            },
	            y = this.$W,
	            M = this.$M,
	            m = this.$D,
	            v = "set" + (this.$u ? "UTC" : "");
	          switch (h) {
	            case c:
	              return r ? l(1, 0) : l(31, 11);
	            case f:
	              return r ? l(1, M) : l(0, M + 1);
	            case o:
	              var g = this.$locale().weekStart || 0,
	                D = (y < g ? y + 7 : y) - g;
	              return l(r ? m - D : m + (6 - D), M);
	            case a:
	            case d:
	              return $(v + "Hours", 0);
	            case u:
	              return $(v + "Minutes", 1);
	            case s:
	              return $(v + "Seconds", 2);
	            case i:
	              return $(v + "Milliseconds", 3);
	            default:
	              return this.clone();
	          }
	        }, m.endOf = function (t) {
	          return this.startOf(t, !1);
	        }, m.$set = function (t, e) {
	          var n,
	            o = O.p(t),
	            h = "set" + (this.$u ? "UTC" : ""),
	            l = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o],
	            $ = o === a ? this.$D + (e - this.$W) : e;
	          if (o === f || o === c) {
	            var y = this.clone().set(d, 1);
	            y.$d[l]($), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
	          } else l && this.$d[l]($);
	          return this.init(), this;
	        }, m.set = function (t, e) {
	          return this.clone().$set(t, e);
	        }, m.get = function (t) {
	          return this[O.p(t)]();
	        }, m.add = function (r, h) {
	          var d,
	            l = this;
	          r = Number(r);
	          var $ = O.p(h),
	            y = function y(t) {
	              var e = w(l);
	              return O.w(e.date(e.date() + Math.round(t * r)), l);
	            };
	          if ($ === f) return this.set(f, this.$M + r);
	          if ($ === c) return this.set(c, this.$y + r);
	          if ($ === a) return y(1);
	          if ($ === o) return y(7);
	          var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[$] || 1,
	            m = this.$d.getTime() + r * M;
	          return O.w(m, this);
	        }, m.subtract = function (t, e) {
	          return this.add(-1 * t, e);
	        }, m.format = function (t) {
	          var e = this,
	            n = this.$locale();
	          if (!this.isValid()) return n.invalidDate || l;
	          var r = t || "YYYY-MM-DDTHH:mm:ssZ",
	            i = O.z(this),
	            s = this.$H,
	            u = this.$m,
	            a = this.$M,
	            o = n.weekdays,
	            f = n.months,
	            h = function h(t, n, i, s) {
	              return t && (t[n] || t(e, r)) || i[n].slice(0, s);
	            },
	            c = function c(t) {
	              return O.s(s % 12 || 12, t, "0");
	            },
	            d = n.meridiem || function (t, e, n) {
	              var r = t < 12 ? "AM" : "PM";
	              return n ? r.toLowerCase() : r;
	            },
	            $ = {
	              YY: String(this.$y).slice(-2),
	              YYYY: this.$y,
	              M: a + 1,
	              MM: O.s(a + 1, 2, "0"),
	              MMM: h(n.monthsShort, a, f, 3),
	              MMMM: h(f, a),
	              D: this.$D,
	              DD: O.s(this.$D, 2, "0"),
	              d: String(this.$W),
	              dd: h(n.weekdaysMin, this.$W, o, 2),
	              ddd: h(n.weekdaysShort, this.$W, o, 3),
	              dddd: o[this.$W],
	              H: String(s),
	              HH: O.s(s, 2, "0"),
	              h: c(1),
	              hh: c(2),
	              a: d(s, u, !0),
	              A: d(s, u, !1),
	              m: String(u),
	              mm: O.s(u, 2, "0"),
	              s: String(this.$s),
	              ss: O.s(this.$s, 2, "0"),
	              SSS: O.s(this.$ms, 3, "0"),
	              Z: i
	            };
	          return r.replace(y, function (t, e) {
	            return e || $[t] || i.replace(":", "");
	          });
	        }, m.utcOffset = function () {
	          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
	        }, m.diff = function (r, d, l) {
	          var $,
	            y = O.p(d),
	            M = w(r),
	            m = (M.utcOffset() - this.utcOffset()) * e,
	            v = this - M,
	            g = O.m(this, M);
	          return g = ($ = {}, $[c] = g / 12, $[f] = g, $[h] = g / 3, $[o] = (v - m) / 6048e5, $[a] = (v - m) / 864e5, $[u] = v / n, $[s] = v / e, $[i] = v / t, $)[y] || v, l ? g : O.a(g);
	        }, m.daysInMonth = function () {
	          return this.endOf(f).$D;
	        }, m.$locale = function () {
	          return D[this.$L];
	        }, m.locale = function (t, e) {
	          if (!t) return this.$L;
	          var n = this.clone(),
	            r = S(t, e, !0);
	          return r && (n.$L = r), n;
	        }, m.clone = function () {
	          return O.w(this.$d, this);
	        }, m.toDate = function () {
	          return new Date(this.valueOf());
	        }, m.toJSON = function () {
	          return this.isValid() ? this.toISOString() : null;
	        }, m.toISOString = function () {
	          return this.$d.toISOString();
	        }, m.toString = function () {
	          return this.$d.toUTCString();
	        }, M;
	      }(),
	      T = _.prototype;
	    return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function (t) {
	      T[t[1]] = function (e) {
	        return this.$g(e, t[0], t[1]);
	      };
	    }), w.extend = function (t, e) {
	      return t.$i || (t(e, _, w), t.$i = !0), w;
	    }, w.locale = S, w.isDayjs = p, w.unix = function (t) {
	      return w(1e3 * t);
	    }, w.en = D[g], w.Ls = D, w.p = {}, w;
	  });
	});

	var transform = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.transformValueToComponentStateFormat = exports.getDependentQueries = exports.extractPropsFromState = exports.getValidInterval = exports.getRSQuery = exports.hasPaginationSupport = exports.isComponentUsesLabelAsValue = exports.isSearchComponent = exports.isDRSRangeComponent = exports.getHistogramComponentID = exports.getInternalComponentID = exports.isInternalComponent = exports.getNormalizedField = exports.componentToTypeMap = undefined;
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  var _componentToTypeMap;
	  exports.flatReactProp = flatReactProp;
	  var _dayjs2 = _interopRequireDefault(dayjs_min);
	  var _dateFormats2 = _interopRequireDefault(dateFormats_1);
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  var componentToTypeMap = exports.componentToTypeMap = (_componentToTypeMap = {}, _defineProperty(_componentToTypeMap, constants$1.componentTypes.reactiveList, constants$1.queryTypes.search), _defineProperty(_componentToTypeMap, constants$1.componentTypes.dataSearch, constants$1.queryTypes.search), _defineProperty(_componentToTypeMap, constants$1.componentTypes.categorySearch, constants$1.queryTypes.search), _defineProperty(_componentToTypeMap, constants$1.componentTypes.searchBox, constants$1.queryTypes.suggestion), _defineProperty(_componentToTypeMap, constants$1.componentTypes.singleList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.multiList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.singleDataList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.singleDropdownList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.multiDataList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.multiDropdownList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.tagCloud, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.toggleButton, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.reactiveChart, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.treeList, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.numberBox, constants$1.queryTypes.term), _defineProperty(_componentToTypeMap, constants$1.componentTypes.datePicker, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.dateRange, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.dynamicRangeSlider, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.singleDropdownRange, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.multiDropdownRange, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.singleRange, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.multiRange, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.rangeSlider, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.ratingsFilter, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.rangeInput, constants$1.queryTypes.range), _defineProperty(_componentToTypeMap, constants$1.componentTypes.geoDistanceDropdown, constants$1.queryTypes.geo), _defineProperty(_componentToTypeMap, constants$1.componentTypes.geoDistanceSlider, constants$1.queryTypes.geo), _defineProperty(_componentToTypeMap, constants$1.componentTypes.reactiveMap, constants$1.queryTypes.geo), _componentToTypeMap);
	  var multiRangeComponents = [constants$1.componentTypes.multiRange, constants$1.componentTypes.multiDropdownRange];
	  var dateRangeComponents = [constants$1.componentTypes.dateRange, constants$1.componentTypes.datePicker];
	  var searchComponents = [constants$1.componentTypes.categorySearch, constants$1.componentTypes.dataSearch, constants$1.componentTypes.searchBox];
	  var listComponentsWithPagination = [constants$1.componentTypes.singleList, constants$1.componentTypes.multiList, constants$1.componentTypes.singleDropdownList, constants$1.componentTypes.multiDropdownList];
	  var getNormalizedField = exports.getNormalizedField = function getNormalizedField(field) {
	    if (field && !Array.isArray(field)) {
	      return [field];
	    }
	    return field;
	  };
	  var isInternalComponent = exports.isInternalComponent = function isInternalComponent() {
	    var componentID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return componentID.endsWith('__internal');
	  };
	  var getInternalComponentID = exports.getInternalComponentID = function getInternalComponentID() {
	    var componentID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return componentID + '__internal';
	  };
	  var getHistogramComponentID = exports.getHistogramComponentID = function getHistogramComponentID() {
	    var componentID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return componentID + '__histogram__internal';
	  };
	  var isDRSRangeComponent = exports.isDRSRangeComponent = function isDRSRangeComponent() {
	    var componentID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return componentID.endsWith('__range__internal');
	  };
	  var isSearchComponent = exports.isSearchComponent = function isSearchComponent() {
	    var componentType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return searchComponents.includes(componentType);
	  };
	  var isComponentUsesLabelAsValue = exports.isComponentUsesLabelAsValue = function isComponentUsesLabelAsValue() {
	    var componentType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return componentType === constants$1.componentTypes.multiDataList || componentType === constants$1.componentTypes.singleDataList || componentType === constants$1.componentTypes.tabDataList;
	  };
	  var hasPaginationSupport = exports.hasPaginationSupport = function hasPaginationSupport() {
	    var componentType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return listComponentsWithPagination.includes(componentType);
	  };
	  var getRSQuery = exports.getRSQuery = function getRSQuery(componentId, props) {
	    var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    if (props && componentId) {
	      if (props.defaultQuery === null) {
	        return null;
	      }
	      var queryType = props.type ? props.type : componentToTypeMap[props.componentType];
	      if (!isSearchComponent(props.componentType) && !props.dataField) {
	        return null;
	      }
	      var endpoint = void 0;
	      if (props.endpoint instanceof Object) {
	        endpoint = props.endpoint;
	      }
	      return _extends({
	        id: componentId,
	        type: queryType,
	        dataField: getNormalizedField(props.dataField),
	        execute: execute,
	        react: props.react,
	        highlight: props.highlight,
	        highlightField: getNormalizedField(props.highlightField),
	        fuzziness: props.fuzziness,
	        searchOperators: props.searchOperators,
	        includeFields: props.includeFields,
	        excludeFields: props.excludeFields,
	        size: props.size,
	        aggregationSize: props.aggregationSize,
	        from: props.from,
	        queryFormat: props.queryFormat,
	        sortBy: props.sortBy,
	        fieldWeights: getNormalizedField(props.fieldWeights),
	        includeNullValues: props.includeNullValues,
	        aggregationField: props.aggregationField || undefined,
	        categoryField: props.categoryField || undefined,
	        missingLabel: props.missingLabel || undefined,
	        showMissing: props.showMissing,
	        nestedField: props.nestedField || undefined,
	        interval: props.interval,
	        highlightConfig: props.customHighlight || props.highlightConfig,
	        customQuery: props.customQuery,
	        defaultQuery: props.defaultQuery,
	        value: props.value,
	        categoryValue: props.categoryValue || undefined,
	        after: props.after || undefined,
	        aggregations: props.aggregations || undefined,
	        enableSynonyms: props.enableSynonyms,
	        selectAllLabel: props.selectAllLabel,
	        pagination: props.pagination,
	        queryString: props.queryString,
	        distinctField: props.distinctField,
	        distinctFieldConfig: props.distinctFieldConfig,
	        index: props.index
	      }, queryType === constants$1.queryTypes.suggestion ? _extends({
	        enablePopularSuggestions: props.enablePopularSuggestions,
	        enableEndpointSuggestions: props.enableEndpointSuggestions,
	        enableRecentSuggestions: props.enableRecentSuggestions,
	        popularSuggestionsConfig: props.popularSuggestionsConfig,
	        recentSuggestionsConfig: props.recentSuggestionsConfig,
	        applyStopwords: props.applyStopwords,
	        customStopwords: props.customStopwords,
	        enablePredictiveSuggestions: props.enablePredictiveSuggestions,
	        featuredSuggestionsConfig: props.featuredSuggestionsConfig,
	        indexSuggestionsConfig: props.indexSuggestionsConfig,
	        enableFeaturedSuggestions: props.enableFeaturedSuggestions,
	        enableIndexSuggestions: props.enableIndexSuggestions
	      }, props.searchboxId ? {
	        searchboxId: props.searchboxId
	      } : {}) : {}, {
	        calendarInterval: props.calendarInterval,
	        endpoint: endpoint,
	        range: props.range
	      });
	    }
	    return null;
	  };
	  var getValidInterval = exports.getValidInterval = function getValidInterval(interval) {
	    var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var min = Math.ceil((range.end - range.start) / 100) || 1;
	    if (!interval) {
	      return min;
	    } else if (interval < min) {
	      return min;
	    }
	    return interval;
	  };
	  var extractPropsFromState = exports.extractPropsFromState = function extractPropsFromState(store, component, customOptions) {
	    var componentProps = store.props[component];
	    if (!componentProps) {
	      return null;
	    }
	    var queryType = componentProps.type ? componentProps.type : componentToTypeMap[componentProps.componentType];
	    var calcValues = store.selectedValues[component] || store.internalValues[component];
	    var value = calcValues !== undefined && calcValues !== null ? calcValues.value : undefined;
	    var queryFormat = componentProps.queryFormat;
	    var calendarInterval = void 0;
	    var interval = componentProps.interval;
	    var type = queryType;
	    var dataField = componentProps.dataField;
	    var aggregations = componentProps.aggregations;
	    var pagination = void 0;
	    var from = componentProps.from;
	    var range = void 0;
	    if (queryType === constants$1.queryTypes.term) {
	      if (componentProps.showLoadMore && hasPaginationSupport(componentProps.componentType)) {
	        pagination = true;
	      }
	      if (value != null && typeof value === 'object' && value.value) {
	        value = value.value;
	      } else if (Array.isArray(value)) {
	        var parsedValue = [];
	        value.forEach(function (val) {
	          if (val != null && typeof val === 'object' && val.value) {
	            parsedValue.push(val.value);
	          } else {
	            parsedValue.push(val);
	          }
	        });
	        value = parsedValue;
	      }
	    }
	    if (queryType === constants$1.queryTypes.range) {
	      if (Array.isArray(value)) {
	        if (multiRangeComponents.includes(componentProps.componentType)) {
	          value = value.map(function (_ref) {
	            var start = _ref.start,
	              end = _ref.end;
	            return {
	              start: start,
	              end: end
	            };
	          });
	        } else {
	          value = {
	            start: value[0],
	            end: value[1]
	          };
	        }
	      } else if (componentProps.showHistogram) {
	        var internalComponentID = getInternalComponentID(component);
	        var internalComponentValue = store.internalValues[internalComponentID];
	        if (!internalComponentValue) {
	          var histogramComponentID = getHistogramComponentID(component);
	          internalComponentValue = store.internalValues[histogramComponentID];
	        }
	        if (internalComponentValue && Array.isArray(internalComponentValue.value)) {
	          value = {
	            start: internalComponentValue.value[0],
	            end: internalComponentValue.value[1]
	          };
	          interval = getValidInterval(interval, value);
	        }
	      }
	      if (isDRSRangeComponent(component)) {
	        aggregations = ['min', 'max'];
	      } else if (componentProps.showHistogram) {
	        aggregations = ['histogram'];
	      }
	      if (componentProps.componentType === constants$1.componentTypes.dynamicRangeSlider || componentProps.componentType === constants$1.componentTypes.rangeSlider) {
	        calendarInterval = Object.keys(_dateFormats2["default"]).includes(queryFormat) ? componentProps.calendarInterval : undefined;
	        if (value) {
	          if ((0, helper.isValidDateRangeQueryFormat)(componentProps.queryFormat)) {
	            value = {
	              start: (0, helper.formatDate)((0, _dayjs2["default"])(new Date(value.start)), componentProps),
	              end: (0, helper.formatDate)((0, _dayjs2["default"])(new Date(value.end)), componentProps)
	            };
	          } else {
	            value = {
	              start: parseFloat(value.start),
	              end: parseFloat(value.end)
	            };
	          }
	        }
	        var rangeValue = void 0;
	        if (componentProps.componentType === constants$1.componentTypes.dynamicRangeSlider) {
	          rangeValue = store.aggregations[component + '__range__internal'];
	          if (componentProps.nestedField) {
	            rangeValue = rangeValue && store.aggregations[component + '__range__internal'][componentProps.nestedField].min ? {
	              start: store.aggregations[component + '__range__internal'][componentProps.nestedField].min.value,
	              end: store.aggregations[component + '__range__internal'][componentProps.nestedField].max.value
	            } : null;
	          } else {
	            rangeValue = rangeValue && store.aggregations[component + '__range__internal'].min && store.aggregations[component + '__range__internal'].min.value ? {
	              start: store.aggregations[component + '__range__internal'].min.value,
	              end: store.aggregations[component + '__range__internal'].max.value
	            } : null;
	          }
	        } else {
	          rangeValue = componentProps.range;
	        }
	        if (rangeValue) {
	          if ((0, helper.isValidDateRangeQueryFormat)(componentProps.queryFormat)) {
	            range = {
	              start: (0, helper.formatDate)((0, _dayjs2["default"])(rangeValue.start), componentProps),
	              end: (0, helper.formatDate)((0, _dayjs2["default"])(rangeValue.end), componentProps)
	            };
	          } else {
	            range = {
	              start: parseFloat(rangeValue.start),
	              end: parseFloat(rangeValue.end)
	            };
	          }
	        }
	      }
	      if (dateRangeComponents.includes(componentProps.componentType)) {
	        if (value) {
	          if ((0, helper.isValidDateRangeQueryFormat)(componentProps.queryFormat)) {
	            if (typeof value === 'string') {
	              value = {
	                start: (0, helper.formatDate)((0, _dayjs2["default"])(value).subtract(24, 'hour'), componentProps),
	                end: (0, helper.formatDate)((0, _dayjs2["default"])(value), componentProps)
	              };
	            } else if (Array.isArray(value)) {
	              value = value.map(function (val) {
	                return {
	                  start: (0, helper.formatDate)((0, _dayjs2["default"])(val).subtract(24, 'hour'), componentProps),
	                  end: (0, helper.formatDate)((0, _dayjs2["default"])(val), componentProps)
	                };
	              });
	            } else {
	              value = {
	                start: (0, helper.formatDate)((0, _dayjs2["default"])(value.start).subtract(24, 'hour'), componentProps),
	                end: (0, helper.formatDate)((0, _dayjs2["default"])(value.end), componentProps)
	              };
	            }
	          }
	        }
	      }
	    }
	    if (queryType === constants$1.queryTypes.geo) {
	      value = undefined;
	      var geoCalcValues = store.selectedValues[component] || store.internalValues[component] || store.internalValues[getInternalComponentID(component)];
	      if (geoCalcValues && geoCalcValues.meta) {
	        if (geoCalcValues.meta.distance && geoCalcValues.meta.coordinates) {
	          value = {
	            distance: geoCalcValues.meta.distance,
	            location: geoCalcValues.meta.coordinates
	          };
	          if (componentProps.unit) {
	            value.unit = componentProps.unit;
	          }
	        }
	        if (geoCalcValues.meta.mapBoxBounds && geoCalcValues.meta.mapBoxBounds.top_left && geoCalcValues.meta.mapBoxBounds.bottom_right) {
	          value = {
	            geoBoundingBox: {
	              topLeft: geoCalcValues.meta.mapBoxBounds.top_left[1] + ', ' + geoCalcValues.meta.mapBoxBounds.top_left[0],
	              bottomRight: geoCalcValues.meta.mapBoxBounds.bottom_right[1] + ', ' + geoCalcValues.meta.mapBoxBounds.bottom_right[0]
	            }
	          };
	        }
	      }
	    }
	    if (componentProps.componentType === constants$1.componentTypes.numberBox) {
	      if (queryFormat === 'exact') {
	        type = 'term';
	      } else {
	        type = 'range';
	        if (queryFormat === 'lte') {
	          value = {
	            end: value,
	            boost: 2.0
	          };
	        } else {
	          value = {
	            start: value,
	            boost: 2.0
	          };
	        }
	      }
	      queryFormat = 'or';
	    }
	    if (componentProps.componentType === constants$1.componentTypes.reactiveComponent) {
	      type = 'term';
	      dataField = 'reactive_component_field';
	      value = undefined;
	    }
	    if (isSearchComponent(componentProps.componentType) && !value) {
	      value = '';
	    }
	    if (isComponentUsesLabelAsValue(componentProps.componentType)) {
	      var data = componentProps.data,
	        selectAllLabel = componentProps.selectAllLabel;
	      var absValue = [];
	      if (value && Array.isArray(value)) {
	        absValue = value;
	      } else if (value && typeof value === 'string') {
	        absValue = [value];
	      }
	      var normalizedValue = [];
	      if (absValue.length) {
	        if (data && Array.isArray(data)) {
	          absValue.forEach(function (val) {
	            var dataItem = data.find(function (o) {
	              return o.label === val;
	            });
	            if (dataItem && dataItem.value) {
	              normalizedValue.push(dataItem.value);
	            }
	          });
	        }
	      }
	      if (selectAllLabel && absValue.length && absValue.includes(selectAllLabel)) {
	        normalizedValue = absValue;
	      }
	      if (normalizedValue.length) {
	        value = normalizedValue;
	      } else {
	        value = undefined;
	      }
	    }
	    if (componentProps.componentType === constants$1.componentTypes.reactiveList) {
	      if (value > 0) {
	        from = (value - 1) * (componentProps.size || 10);
	      } else {
	        from = 0;
	      }
	      value = undefined;
	    }
	    var queryValue = value || undefined;
	    if (componentProps.componentType === constants$1.componentTypes.searchBox) {
	      if (Array.isArray(queryValue)) {
	        queryValue = undefined;
	      }
	    }
	    var endpoint = void 0;
	    if (componentProps.endpoint instanceof Object) {
	      endpoint = _extends({}, endpoint || {}, componentProps.endpoint);
	    }
	    return _extends({}, componentProps, {
	      endpoint: endpoint,
	      calendarInterval: calendarInterval,
	      dataField: dataField,
	      queryFormat: queryFormat,
	      type: type,
	      aggregations: aggregations,
	      interval: interval,
	      react: store.dependencyTree ? store.dependencyTree[component] : undefined,
	      customQuery: store.customQueries ? store.customQueries[component] : undefined,
	      defaultQuery: store.defaultQueries[component],
	      customHighlight: store.customHighlightOptions ? store.customHighlightOptions[component] : undefined,
	      categoryValue: store.internalValues[component] ? store.internalValues[component].category : undefined,
	      value: queryValue,
	      pagination: pagination,
	      from: from,
	      range: range
	    }, customOptions);
	  };
	  function flatReactProp(reactProp, componentID) {
	    var flattenReact = [];
	    var flatReact = function flatReact(react) {
	      if (react && Object.keys(react)) {
	        Object.keys(react).forEach(function (r) {
	          if (react[r]) {
	            if (typeof react[r] === 'string') {
	              flattenReact = [].concat(_toConsumableArray(flattenReact), [react[r]]);
	            } else if (Array.isArray(react[r])) {
	              flattenReact = [].concat(_toConsumableArray(flattenReact), _toConsumableArray(react[r]));
	            } else if (typeof react[r] === 'object') {
	              flatReact(react[r]);
	            }
	          }
	        });
	      }
	    };
	    flatReact(reactProp);
	    flattenReact = flattenReact.filter(function (react) {
	      return react !== componentID;
	    });
	    return flattenReact;
	  }
	  var getDependentQueries = exports.getDependentQueries = function getDependentQueries(store, componentID) {
	    var orderOfQueries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	    var finalQuery = {};
	    var react = flatReactProp(store.dependencyTree[componentID], componentID);
	    react.forEach(function (componentObject) {
	      var component = componentObject;
	      var customQuery = store.customQueries[component];
	      if (!isInternalComponent(component)) {
	        var calcValues = store.selectedValues[component] || store.internalValues[component];
	        if ((calcValues || customQuery) && !finalQuery[component]) {
	          var execute = false;
	          if (Array.isArray(orderOfQueries) && orderOfQueries.includes(component)) {
	            execute = true;
	          }
	          var componentProps = store.props[component];
	          var dependentQuery = getRSQuery(component, extractPropsFromState(store, component, _extends({}, componentProps && _extends({}, componentProps.componentType === constants$1.componentTypes.searchBox ? _extends({}, execute === false ? {
	            type: constants$1.queryTypes.search
	          } : {}, calcValues.category ? {
	            categoryValue: calcValues.category
	          } : {
	            categoryValue: undefined
	          }, calcValues.value ? {
	            value: calcValues.value
	          } : {}) : {}, componentProps.componentType === constants$1.componentTypes.categorySearch ? _extends({}, calcValues.category ? {
	            categoryValue: calcValues.category
	          } : {
	            categoryValue: undefined
	          }) : {}))), execute);
	          if (dependentQuery) {
	            finalQuery[component] = dependentQuery;
	          }
	        }
	      }
	    });
	    return finalQuery;
	  };
	  var transformValueToComponentStateFormat = exports.transformValueToComponentStateFormat = function transformValueToComponentStateFormat(value, componentProps) {
	    var componentType = componentProps.componentType,
	      data = componentProps.data,
	      queryFormat = componentProps.queryFormat;
	    var transformedValue = value;
	    var meta = {};
	    if (value) {
	      switch (componentType) {
	        case constants$1.componentTypes.singleDataList:
	        case constants$1.componentTypes.tabDataList:
	          transformedValue = '';
	          if (Array.isArray(value) && typeof value[0] === 'string') {
	            transformedValue = value[0];
	          } else if (typeof value === 'object' && value.label) {
	            transformedValue = value.label;
	          } else {
	            transformedValue = value;
	          }
	          break;
	        case constants$1.componentTypes.multiDataList:
	          transformedValue = [];
	          if (Array.isArray(value)) {
	            value.forEach(function (valObj) {
	              if (typeof valObj === 'object' && (valObj.label || valObj.value)) {
	                transformedValue.push(valObj.label || valObj.value);
	              } else if (typeof valObj === 'string') {
	                transformedValue.push(valObj);
	              }
	            });
	          }
	          break;
	        case constants$1.componentTypes.toggleButton:
	          transformedValue = [];
	          if (Array.isArray(value)) {
	            value.forEach(function (valObj) {
	              if (typeof valObj === 'object' && valObj.label && valObj.value) {
	                transformedValue.push(valObj);
	              } else if (typeof valObj === 'string') {
	                var findDataObj = data.find(function (item) {
	                  return item.label.trim() === valObj.trim() || item.value.trim() === valObj.trim();
	                });
	                transformedValue.push(findDataObj);
	              }
	            });
	          } else if (typeof value === 'object' && value.label && value.value) {
	            transformedValue = value.value;
	          } else if (typeof value === 'string') {
	            var findDataObj = data.find(function (item) {
	              return item.label.trim() === value.trim() || item.value.trim() === value.trim();
	            });
	            transformedValue = findDataObj.value;
	          }
	          break;
	        case constants$1.componentTypes.singleRange:
	        case constants$1.componentTypes.singleDropdownRange:
	          transformedValue = {};
	          if (!Array.isArray(value) && typeof value === 'object') {
	            transformedValue = _extends({}, value);
	          } else if (typeof value === 'string') {
	            var _findDataObj = data.find(function (item) {
	              return item.label.trim() === value.trim();
	            });
	            transformedValue = _extends({}, _findDataObj);
	          }
	          break;
	        case constants$1.componentTypes.multiDropdownRange:
	        case constants$1.componentTypes.multiRange:
	          transformedValue = [];
	          if (Array.isArray(value)) {
	            value.forEach(function (valObj) {
	              if (typeof valObj === 'object' && typeof valObj.start === 'number' && typeof valObj.end === 'number') {
	                var _findDataObj2 = _extends({}, valObj);
	                if (!_findDataObj2.label) {
	                  _findDataObj2 = data.find(function (item) {
	                    return item.start === valObj.start && item.end === valObj.end;
	                  });
	                }
	                transformedValue.push(_findDataObj2);
	              } else if (typeof valObj === 'string') {
	                var _findDataObj3 = data.find(function (item) {
	                  return item.label.trim() === valObj.trim();
	                });
	                transformedValue.push(_findDataObj3);
	              }
	            });
	          } else if (typeof value === 'string') {
	            var _findDataObj4 = data.find(function (item) {
	              return item.label.trim() === value.trim();
	            });
	            transformedValue.push(_findDataObj4);
	          }
	          break;
	        case constants$1.componentTypes.rangeSlider:
	        case constants$1.componentTypes.ratingsFilter:
	        case constants$1.componentTypes.dynamicRangeSlider:
	        case constants$1.componentTypes.reactiveChart:
	          transformedValue = [];
	          if (queryFormat) {
	            if (Array.isArray(value)) {
	              transformedValue = value.map(function (item) {
	                return (0, helper.formatDate)((0, _dayjs2["default"])(item), componentProps);
	              });
	            } else if (typeof value === 'object') {
	              transformedValue = [(0, helper.formatDate)((0, _dayjs2["default"])(value.start), componentProps), (0, helper.formatDate)((0, _dayjs2["default"])(value.end), componentProps)];
	            }
	          } else if (Array.isArray(value)) {
	            transformedValue = [].concat(_toConsumableArray(value));
	          } else if (typeof value === 'object') {
	            transformedValue = [value.start, value.end];
	          } else {
	            transformedValue = value;
	          }
	          break;
	        case constants$1.componentTypes.numberBox:
	          transformedValue = [];
	          if (!Array.isArray(value) && typeof value === 'object') {
	            transformedValue = value.start;
	          } else if (typeof value === 'number') {
	            transformedValue = value;
	          }
	          break;
	        case constants$1.componentTypes.datePicker:
	          transformedValue = '';
	          if (typeof value !== 'object') {
	            transformedValue = (0, _dayjs2["default"])(value).format('YYYY-MM-DD');
	          } else if (value.end) {
	            transformedValue = (0, _dayjs2["default"])(value.end).format('YYYY-MM-DD');
	          } else if (value.start) {
	            transformedValue = (0, _dayjs2["default"])(value.start).add(24, 'hour').format('YYYY-MM-DD');
	          }
	          break;
	        case constants$1.componentTypes.dateRange:
	          transformedValue = [];
	          if (Array.isArray(value)) {
	            transformedValue = value.map(function (t) {
	              return (0, _dayjs2["default"])(t).format('YYYY-MM-DD');
	            });
	          } else if (typeof value === 'object') {
	            transformedValue = [(0, _dayjs2["default"])(value.start).format('YYYY-MM-DD'), (0, _dayjs2["default"])(value.end).format('YYYY-MM-DD')];
	          }
	          break;
	        case constants$1.componentTypes.categorySearch:
	          transformedValue = '';
	          if (typeof value === 'object') {
	            transformedValue = value.value;
	            if (value.category !== undefined) {
	              meta.category = value.category;
	            }
	          } else if (typeof value === 'string') {
	            transformedValue = value;
	          }
	          break;
	      }
	    }
	    return {
	      value: transformedValue,
	      meta: meta
	    };
	  };
	});
	unwrapExports(transform);
	var transform_1 = transform.transformValueToComponentStateFormat;
	var transform_2 = transform.getDependentQueries;
	var transform_3 = transform.extractPropsFromState;
	var transform_4 = transform.getValidInterval;
	var transform_5 = transform.getRSQuery;
	var transform_6 = transform.hasPaginationSupport;
	var transform_7 = transform.isComponentUsesLabelAsValue;
	var transform_8 = transform.isSearchComponent;
	var transform_9 = transform.isDRSRangeComponent;
	var transform_10 = transform.getHistogramComponentID;
	var transform_11 = transform.getInternalComponentID;
	var transform_12 = transform.isInternalComponent;
	var transform_13 = transform.getNormalizedField;
	var transform_14 = transform.componentToTypeMap;
	var transform_15 = transform.flatReactProp;

	var hits = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.updateAggs = updateAggs;
	  exports.updateCompositeAggs = updateCompositeAggs;
	  exports.updateHits = updateHits;
	  exports.saveQueryToHits = saveQueryToHits;
	  exports.mockDataForTesting = mockDataForTesting;
	  function updateAggs(component, aggregations) {
	    var append = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    return {
	      type: constants.UPDATE_AGGS,
	      component: component,
	      aggregations: aggregations,
	      append: append
	    };
	  }
	  function updateCompositeAggs(component, aggregations) {
	    var append = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    return {
	      type: constants.UPDATE_COMPOSITE_AGGS,
	      component: component,
	      aggregations: aggregations,
	      append: append
	    };
	  }
	  function updateHits(component, hits, time, hidden) {
	    var append = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	    return {
	      type: constants.UPDATE_HITS,
	      component: component,
	      hits: hits.hits,
	      total: typeof hits.total === 'object' ? hits.total.value : hits.total,
	      hidden: hidden,
	      time: time,
	      append: append
	    };
	  }
	  function saveQueryToHits(component, query) {
	    return {
	      type: constants.SET_QUERY_TO_HITS,
	      component: component,
	      query: query
	    };
	  }
	  function mockDataForTesting(component, data) {
	    return function (dispatch) {
	      if (data.hasOwnProperty('error')) {
	        dispatch((0, misc.setError)(component, data.error));
	      }
	      if (data.hasOwnProperty('aggregations')) {
	        dispatch(updateAggs(component, data.aggregations));
	      }
	      if (data.hasOwnProperty('hits')) {
	        dispatch(updateHits(component, data, data.time || undefined));
	      }
	    };
	  }
	});
	unwrapExports(hits);
	var hits_1 = hits.updateAggs;
	var hits_2 = hits.updateCompositeAggs;
	var hits_3 = hits.updateHits;
	var hits_4 = hits.saveQueryToHits;
	var hits_5 = hits.mockDataForTesting;

	var misc = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.setRawData = setRawData;
	  exports.setLoading = setLoading;
	  exports.setError = setError;
	  exports.setTimestamp = setTimestamp;
	  exports.setSearchId = setSearchId;
	  exports.setSuggestionsSearchId = setSuggestionsSearchId;
	  exports.setQuery = setQuery;
	  exports.setCustomQuery = setCustomQuery;
	  exports.setDefaultQuery = setDefaultQuery;
	  exports.setCustomHighlightOptions = setCustomHighlightOptions;
	  exports.updateQueryOptions = updateQueryOptions;
	  exports.logQuery = logQuery;
	  exports.logCombinedQuery = logCombinedQuery;
	  exports.setHeaders = setHeaders;
	  exports.setPromotedResults = setPromotedResults;
	  exports.setPopularSuggestions = setPopularSuggestions;
	  exports.setDefaultPopularSuggestions = setDefaultPopularSuggestions;
	  exports.setCustomData = setCustomData;
	  exports.setAppliedSettings = setAppliedSettings;
	  exports.setQueryListener = setQueryListener;
	  exports.setGoogleMapScriptLoading = setGoogleMapScriptLoading;
	  exports.setGoogleMapScriptLoaded = setGoogleMapScriptLoaded;
	  exports.setGoogleMapScriptError = setGoogleMapScriptError;
	  exports.resetStoreForComponent = resetStoreForComponent;
	  exports.setLastUsedAppbaseQuery = setLastUsedAppbaseQuery;
	  exports.setSearchState = setSearchState;
	  function setRawData(component, response) {
	    return {
	      type: constants.SET_RAW_DATA,
	      component: component,
	      response: response
	    };
	  }
	  function setLoading(component, isLoading) {
	    return {
	      type: constants.SET_LOADING,
	      component: component,
	      isLoading: isLoading
	    };
	  }
	  function setError(component, error) {
	    return {
	      type: constants.SET_ERROR,
	      component: component,
	      error: error
	    };
	  }
	  function setTimestamp(component, timestamp) {
	    return {
	      type: constants.SET_TIMESTAMP,
	      component: component,
	      timestamp: timestamp
	    };
	  }
	  function setSearchId() {
	    var searchId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    return {
	      type: constants.SET_SEARCH_ID,
	      searchId: searchId
	    };
	  }
	  function setSuggestionsSearchId() {
	    var searchId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    return {
	      type: constants.SET_SUGGESTIONS_SEARCH_ID,
	      searchId: searchId
	    };
	  }
	  function setQuery(component, query) {
	    return {
	      type: constants.SET_QUERY,
	      component: component,
	      query: query
	    };
	  }
	  function setCustomQuery(component, query) {
	    return {
	      type: constants.SET_CUSTOM_QUERY,
	      component: component,
	      query: query
	    };
	  }
	  function setDefaultQuery(component, query) {
	    return {
	      type: constants.SET_DEFAULT_QUERY,
	      component: component,
	      query: query
	    };
	  }
	  function setCustomHighlightOptions(component, data) {
	    return {
	      type: constants.SET_CUSTOM_HIGHLIGHT_OPTIONS,
	      component: component,
	      data: data
	    };
	  }
	  function updateQueryOptions(component, options) {
	    return {
	      type: constants.SET_QUERY_OPTIONS,
	      component: component,
	      options: options
	    };
	  }
	  function logQuery(component, query) {
	    return {
	      type: constants.LOG_QUERY,
	      component: component,
	      query: query
	    };
	  }
	  function logCombinedQuery(component, query) {
	    return {
	      type: constants.LOG_COMBINED_QUERY,
	      component: component,
	      query: query
	    };
	  }
	  function setHeaders(headers) {
	    return {
	      type: constants.SET_HEADERS,
	      headers: headers
	    };
	  }
	  function setPromotedResults() {
	    var results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var component = arguments[1];
	    return {
	      type: constants.SET_PROMOTED_RESULTS,
	      results: results,
	      component: component
	    };
	  }
	  function setPopularSuggestions() {
	    var suggestions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var component = arguments[1];
	    return {
	      type: constants.SET_POPULAR_SUGGESTIONS,
	      suggestions: suggestions,
	      component: component
	    };
	  }
	  function setDefaultPopularSuggestions() {
	    var suggestions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var component = arguments[1];
	    return {
	      type: constants.SET_DEFAULT_POPULAR_SUGGESTIONS,
	      suggestions: suggestions,
	      component: component
	    };
	  }
	  function setCustomData() {
	    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var component = arguments[1];
	    return {
	      type: constants.SET_CUSTOM_DATA,
	      data: data,
	      component: component
	    };
	  }
	  function setAppliedSettings() {
	    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var component = arguments[1];
	    return {
	      type: constants.SET_APPLIED_SETTINGS,
	      data: data,
	      component: component
	    };
	  }
	  function setQueryListener(component, onQueryChange, onError) {
	    return {
	      type: constants.SET_QUERY_LISTENER,
	      component: component,
	      onQueryChange: onQueryChange,
	      onError: onError
	    };
	  }
	  function setGoogleMapScriptLoading(bool) {
	    return {
	      type: constants.SET_GOOGLE_MAP_SCRIPT_LOADING,
	      loading: bool
	    };
	  }
	  function setGoogleMapScriptLoaded(bool) {
	    return {
	      type: constants.SET_GOOGLE_MAP_SCRIPT_LOADED,
	      loaded: bool
	    };
	  }
	  function setGoogleMapScriptError(error) {
	    return {
	      type: constants.SET_GOOGLE_MAP_SCRIPT_ERROR,
	      error: error
	    };
	  }
	  function resetStoreForComponent(componentId) {
	    return function (dispatch) {
	      dispatch(setRawData(componentId, null));
	      dispatch(setCustomData(null, componentId));
	      dispatch(setPromotedResults([], componentId));
	      dispatch(setPopularSuggestions([], componentId));
	      dispatch(setDefaultPopularSuggestions([], componentId));
	      dispatch((0, hits.updateAggs)(componentId, null));
	      dispatch((0, hits.updateCompositeAggs)(componentId, {}));
	      dispatch((0, hits.updateHits)(componentId, {
	        hits: [],
	        total: 0
	      }, 0));
	    };
	  }
	  function setLastUsedAppbaseQuery(query) {
	    return {
	      type: constants.SET_APPBASE_QUERY,
	      query: query
	    };
	  }
	  function setSearchState() {
	    var componentsValueAndTypeMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    return function (dispatch) {
	      var componentValues = {};
	      Object.keys(componentsValueAndTypeMap).forEach(function (componentId) {
	        var _componentsValueAndTy = componentsValueAndTypeMap[componentId],
	          value = _componentsValueAndTy.value,
	          componentProps = _componentsValueAndTy.componentProps;
	        var _transformValueToComp = (0, transform.transformValueToComponentStateFormat)(value, componentProps),
	          transformedValue = _transformValueToComp.value,
	          _transformValueToComp2 = _transformValueToComp.meta,
	          meta = _transformValueToComp2 === undefined ? {} : _transformValueToComp2;
	        componentValues[componentId] = _extends({
	          value: transformedValue
	        }, meta);
	      });
	      dispatch((0, value.setValues)(componentValues));
	    };
	  }
	});
	unwrapExports(misc);
	var misc_1 = misc.setRawData;
	var misc_2 = misc.setLoading;
	var misc_3 = misc.setError;
	var misc_4 = misc.setTimestamp;
	var misc_5 = misc.setSearchId;
	var misc_6 = misc.setSuggestionsSearchId;
	var misc_7 = misc.setQuery;
	var misc_8 = misc.setCustomQuery;
	var misc_9 = misc.setDefaultQuery;
	var misc_10 = misc.setCustomHighlightOptions;
	var misc_11 = misc.updateQueryOptions;
	var misc_12 = misc.logQuery;
	var misc_13 = misc.logCombinedQuery;
	var misc_14 = misc.setHeaders;
	var misc_15 = misc.setPromotedResults;
	var misc_16 = misc.setPopularSuggestions;
	var misc_17 = misc.setDefaultPopularSuggestions;
	var misc_18 = misc.setCustomData;
	var misc_19 = misc.setAppliedSettings;
	var misc_20 = misc.setQueryListener;
	var misc_21 = misc.setGoogleMapScriptLoading;
	var misc_22 = misc.setGoogleMapScriptLoaded;
	var misc_23 = misc.setGoogleMapScriptError;
	var misc_24 = misc.resetStoreForComponent;
	var misc_25 = misc.setLastUsedAppbaseQuery;
	var misc_26 = misc.setSearchState;

	var utils = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.getSuggestionQuery = exports.isPropertyDefined = exports.handleResponseMSearch = exports.handleResponse = exports.handleError = exports.getQuerySuggestionsId = exports.isComponentActive = exports.handleTransformResponse = undefined;
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.executeQueryListener = executeQueryListener;
	  exports.updateStoreConfig = updateStoreConfig;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  var handleTransformResponse = exports.handleTransformResponse = function handleTransformResponse() {
	    var res = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var component = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	    if (config.transformResponse && typeof config.transformResponse === 'function') {
	      return config.transformResponse(res, component);
	    }
	    return new Promise(function (resolve) {
	      return resolve(res);
	    });
	  };
	  var isComponentActive = exports.isComponentActive = function isComponentActive() {
	    var getState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
	    var componentId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	    var _getState = getState(),
	      components = _getState.components;
	    if (components.includes(componentId)) {
	      return true;
	    }
	    return false;
	  };
	  var getQuerySuggestionsId = exports.getQuerySuggestionsId = function getQuerySuggestionsId() {
	    var componentId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	    return componentId + '__suggestions';
	  };
	  var handleError = exports.handleError = function handleError() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$orderOfQueries = _ref.orderOfQueries,
	      orderOfQueries = _ref$orderOfQueries === undefined ? [] : _ref$orderOfQueries,
	      _ref$error = _ref.error,
	      error = _ref$error === undefined ? null : _ref$error;
	    var getState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
	    var dispatch = arguments[2];
	    var _getState2 = getState(),
	      queryListener = _getState2.queryListener;
	    try {
	      console.error(JSON.stringify(error));
	    } catch (e) {
	      console.error(error);
	    }
	    orderOfQueries.forEach(function (component) {
	      if (isComponentActive(getState, component)) {
	        if (queryListener[component] && queryListener[component].onError) {
	          queryListener[component].onError(error);
	        }
	        dispatch((0, misc.setError)(component, error));
	        dispatch((0, misc.setLoading)(component, false));
	      }
	    });
	  };
	  var handleResponse = exports.handleResponse = function handleResponse() {
	    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      res = _ref2.res,
	      _ref2$orderOfQueries = _ref2.orderOfQueries,
	      orderOfQueries = _ref2$orderOfQueries === undefined ? [] : _ref2$orderOfQueries,
	      _ref2$appendToHits = _ref2.appendToHits,
	      appendToHits = _ref2$appendToHits === undefined ? false : _ref2$appendToHits,
	      _ref2$appendToAggs = _ref2.appendToAggs,
	      appendToAggs = _ref2$appendToAggs === undefined ? false : _ref2$appendToAggs,
	      _ref2$isSuggestionsQu = _ref2.isSuggestionsQuery,
	      isSuggestionsQuery = _ref2$isSuggestionsQu === undefined ? false : _ref2$isSuggestionsQu,
	      query = _ref2.query,
	      queryId = _ref2.queryId;
	    var getState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
	    var dispatch = arguments[2];
	    var _getState3 = getState(),
	      config = _getState3.config,
	      internalValues = _getState3.internalValues,
	      lastUsedAppbaseQuery = _getState3.lastUsedAppbaseQuery,
	      analyticsRef = _getState3.analyticsRef;
	    var searchId = res._headers ? res._headers.get('X-Search-Id') : null;
	    if (searchId) {
	      if (isSuggestionsQuery) {
	        dispatch((0, misc.setSuggestionsSearchId)(searchId));
	      } else {
	        dispatch((0, misc.setSearchId)(searchId));
	        if (analyticsRef) {
	          analyticsRef.queryID = searchId;
	        }
	      }
	    }
	    orderOfQueries.forEach(function (component) {
	      if (isComponentActive(getState, component)) {
	        if (lastUsedAppbaseQuery[component] && lastUsedAppbaseQuery[component].queryId && queryId && lastUsedAppbaseQuery[component].queryId !== queryId) {
	          return;
	        }
	        if (res.settings) {
	          dispatch((0, misc.setAppliedSettings)(res.settings, component));
	        }
	        handleTransformResponse(res[component], config, component).then(function (response) {
	          if (response) {
	            var _getState4 = getState(),
	              timestamp = _getState4.timestamp,
	              props = _getState4.props;
	            if (timestamp[component] === undefined || timestamp[component] < res._timestamp) {
	              var promotedResults = response.promoted;
	              if (promotedResults) {
	                var parsedPromotedResults = promotedResults.map(function (promoted) {
	                  return _extends({}, promoted.doc, {
	                    _position: promoted.position
	                  });
	                });
	                dispatch((0, misc.setPromotedResults)(parsedPromotedResults, component));
	              } else {
	                dispatch((0, misc.setPromotedResults)([], component));
	              }
	              dispatch((0, misc.setRawData)(component, response));
	              dispatch((0, misc.setCustomData)(response.customData, component));
	              if (response.hits) {
	                dispatch((0, misc.setTimestamp)(component, res._timestamp));
	                if (props[component].componentType === constants$1.componentTypes.reactiveList && query.find(function (queryItem) {
	                  return queryItem.id === component;
	                }).execute) {
	                  dispatch((0, misc.setLastUsedAppbaseQuery)(_defineProperty({}, component, query)));
	                }
	                dispatch((0, hits.updateHits)(component, response.hits, response.took, response.hits && response.hits.hidden, appendToHits));
	                var internalComponentID = (0, transform.getInternalComponentID)(component);
	                if (internalValues[internalComponentID]) {
	                  dispatch((0, hits.saveQueryToHits)(component, internalValues[internalComponentID].value));
	                }
	              }
	              if (response.aggregations) {
	                dispatch((0, hits.updateAggs)(component, response.aggregations, appendToAggs));
	                dispatch((0, hits.updateCompositeAggs)(component, response.aggregations, appendToAggs));
	              }
	            }
	            dispatch((0, misc.setLoading)(component, false));
	          }
	        })["catch"](function (err) {
	          handleError({
	            orderOfQueries: orderOfQueries,
	            error: err
	          }, getState, dispatch);
	        });
	      }
	    });
	  };
	  var handleResponseMSearch = exports.handleResponseMSearch = function handleResponseMSearch(_ref3) {
	    var _ref3$res = _ref3.res,
	      res = _ref3$res === undefined ? {} : _ref3$res,
	      _ref3$isSuggestionsQu = _ref3.isSuggestionsQuery,
	      isSuggestionsQuery = _ref3$isSuggestionsQu === undefined ? false : _ref3$isSuggestionsQu,
	      _ref3$orderOfQueries = _ref3.orderOfQueries,
	      orderOfQueries = _ref3$orderOfQueries === undefined ? [] : _ref3$orderOfQueries,
	      _ref3$appendToHits = _ref3.appendToHits,
	      appendToHits = _ref3$appendToHits === undefined ? false : _ref3$appendToHits,
	      _ref3$appendToAggs = _ref3.appendToAggs,
	      appendToAggs = _ref3$appendToAggs === undefined ? false : _ref3$appendToAggs;
	    var getState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
	    var dispatch = arguments[2];
	    var _getState5 = getState(),
	      analyticsRef = _getState5.analyticsRef;
	    orderOfQueries.forEach(function (component, index) {
	      if (isComponentActive(getState, component)) {
	        var searchId = res._headers ? res._headers.get('X-Search-Id') : null;
	        if (searchId) {
	          if (isSuggestionsQuery) {
	            dispatch((0, misc.setSuggestionsSearchId)(searchId));
	          } else {
	            dispatch((0, misc.setSearchId)(searchId));
	            if (analyticsRef) {
	              analyticsRef.queryID = searchId;
	            }
	          }
	        }
	        var transformResponse = res;
	        if (res && Array.isArray(res.responses) && res.responses[index]) {
	          transformResponse = res.responses[index];
	        }
	        var _getState6 = getState(),
	          config = _getState6.config,
	          internalValues = _getState6.internalValues;
	        handleTransformResponse(transformResponse, config, component).then(function (response) {
	          var _getState7 = getState(),
	            timestamp = _getState7.timestamp;
	          if (timestamp[component] === undefined || timestamp[component] < res._timestamp) {
	            dispatch((0, misc.setRawData)(component, response));
	            var promotedResults = response.promoted || res.promoted;
	            if (promotedResults) {
	              dispatch((0, misc.setPromotedResults)(promotedResults, component));
	            } else {
	              dispatch((0, misc.setPromotedResults)([], component));
	            }
	            if (response.hits) {
	              dispatch((0, misc.setTimestamp)(component, res._timestamp));
	              dispatch((0, hits.updateHits)(component, response.hits, response.took, response.hits && response.hits.hidden, appendToHits));
	              var internalComponentID = (0, transform.getInternalComponentID)(component);
	              if (internalValues[internalComponentID]) {
	                dispatch((0, hits.saveQueryToHits)(component, internalValues[internalComponentID].value));
	              }
	            }
	            if (response.aggregations) {
	              dispatch((0, hits.updateAggs)(component, response.aggregations, appendToAggs));
	              dispatch((0, hits.updateCompositeAggs)(component, response.aggregations, appendToAggs));
	            }
	          }
	          dispatch((0, misc.setLoading)(component, false));
	        })["catch"](function (err) {
	          handleError({
	            orderOfQueries: orderOfQueries,
	            error: err
	          }, getState, dispatch);
	        });
	      }
	    });
	  };
	  var isPropertyDefined = exports.isPropertyDefined = function isPropertyDefined(property) {
	    return property !== undefined && property !== null;
	  };
	  var getSuggestionQuery = exports.getSuggestionQuery = function getSuggestionQuery() {
	    var getState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
	    var componentId = arguments[1];
	    var _getState8 = getState(),
	      internalValues = _getState8.internalValues;
	    var internalValue = internalValues[componentId];
	    var value = internalValue && internalValue.value || '';
	    return [{
	      id: getQuerySuggestionsId(componentId),
	      dataField: ['key', 'key.autosuggest'],
	      size: 5,
	      value: value,
	      defaultQuery: {
	        query: {
	          bool: {
	            minimum_should_match: 1,
	            should: [{
	              function_score: {
	                field_value_factor: {
	                  field: 'count',
	                  modifier: 'sqrt',
	                  missing: 1
	                }
	              }
	            }, {
	              multi_match: {
	                fields: ['key^9', 'key.autosuggest^1', 'key.keyword^10'],
	                fuzziness: 0,
	                operator: 'or',
	                query: value,
	                type: 'best_fields'
	              }
	            }, {
	              multi_match: {
	                fields: ['key^9', 'key.autosuggest^1', 'key.keyword^10'],
	                operator: 'or',
	                query: value,
	                type: 'phrase'
	              }
	            }, {
	              multi_match: {
	                fields: ['key^9'],
	                operator: 'or',
	                query: value,
	                type: 'phrase_prefix'
	              }
	            }]
	          }
	        }
	      }
	    }];
	  };
	  function executeQueryListener(listener, oldQuery, newQuery) {
	    if (listener && listener.onQueryChange) {
	      listener.onQueryChange(oldQuery, newQuery);
	    }
	  }
	  function updateStoreConfig(payload) {
	    return function (dispatch) {
	      dispatch({
	        type: constants.UPDATE_CONFIG,
	        config: payload
	      });
	    };
	  }
	});
	unwrapExports(utils);
	var utils_1 = utils.getSuggestionQuery;
	var utils_2 = utils.isPropertyDefined;
	var utils_3 = utils.handleResponseMSearch;
	var utils_4 = utils.handleResponse;
	var utils_5 = utils.handleError;
	var utils_6 = utils.getQuerySuggestionsId;
	var utils_7 = utils.isComponentActive;
	var utils_8 = utils.handleTransformResponse;
	var utils_9 = utils.executeQueryListener;
	var utils_10 = utils.updateStoreConfig;

	var value = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.setValue = setValue;
	  exports.resetValuesToDefault = resetValuesToDefault;
	  exports.setInternalValue = setInternalValue;
	  exports.patchValue = patchValue;
	  exports.clearValues = clearValues;
	  exports.setValues = setValues;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function setValue(component, value, label, showFilter, URLParams, componentType, category, meta, updateSource) {
	    return function (dispatch, getState) {
	      var _getState = getState(),
	        urlValues = _getState.urlValues,
	        selectedValues = _getState.selectedValues,
	        watchMan = _getState.watchMan,
	        props = _getState.props;
	      var reference = updateSource;
	      if ((0, helper.isEqual)(urlValues[component], value)) {
	        reference = 'URL';
	      }
	      var componentsToReset = {};
	      var isResultComponent = [constants$1.componentTypes.reactiveList, constants$1.componentTypes.reactiveMap].includes(props[component] && props[component].componentType);
	      var previousValue = selectedValues[component] && selectedValues[component].value;
	      if (!(0, helper.isEqual)(previousValue, value) && props[component] && !isResultComponent) {
	        var componentList = [component];
	        var watchList = watchMan[component] || [];
	        componentList = [].concat(_toConsumableArray(componentList), _toConsumableArray(watchList));
	        componentList.forEach(function (comp) {
	          var componentProps = props[comp];
	          if (reference !== 'URL' && componentProps && [constants$1.componentTypes.reactiveList, constants$1.componentTypes.reactiveMap].includes(componentProps.componentType)) {
	            if (selectedValues[comp] !== null) {
	              componentsToReset[comp] = 0;
	            }
	          }
	        });
	      }
	      if (isResultComponent) {
	        if (value < 2 && (!previousValue || previousValue < 2)) {
	          return;
	        }
	      }
	      dispatch({
	        type: constants.SET_VALUE,
	        component: component,
	        reference: reference,
	        value: value,
	        label: label,
	        showFilter: showFilter,
	        URLParams: URLParams,
	        componentType: componentType,
	        category: category,
	        meta: meta,
	        componentsToReset: componentsToReset
	      });
	    };
	  }
	  function resetValuesToDefault(clearAllBlacklistComponents) {
	    return function (dispatch, getState) {
	      var _getState2 = getState(),
	        selectedValues = _getState2.selectedValues,
	        componentProps = _getState2.props;
	      var defaultValues = {};
	      var valueToSet = void 0;
	      Object.keys(selectedValues).forEach(function (component) {
	        if (!(Array.isArray(clearAllBlacklistComponents) && clearAllBlacklistComponents.includes(component))) {
	          if (!componentProps[component] || !componentProps[component].componentType || !componentProps[component].defaultValue) {
	            valueToSet = null;
	          } else if ([constants$1.componentTypes.rangeSlider, constants$1.componentTypes.rangeInput, constants$1.componentTypes.ratingsFilter, constants$1.componentTypes.dateRange].includes(componentProps[component].componentType)) {
	            valueToSet = typeof componentProps[component].defaultValue === 'object' ? [componentProps[component].defaultValue.start, componentProps[component].defaultValue.end] : null;
	          } else if ([constants$1.componentTypes.multiDropdownList, constants$1.componentTypes.multiDataList, constants$1.componentTypes.multiList, constants$1.componentTypes.singleDataList, constants$1.componentTypes.singleDropdownList, constants$1.componentTypes.singleList, constants$1.componentTypes.tagCloud, constants$1.componentTypes.toggleButton, constants$1.componentTypes.multiDropdownRange, constants$1.componentTypes.multiRange, constants$1.componentTypes.singleDropdownRange, constants$1.componentTypes.singleRange, constants$1.componentTypes.dataSearch, constants$1.componentTypes.datePicker, constants$1.componentTypes.treeList].includes(componentProps[component].componentType)) {
	            valueToSet = componentProps[component].defaultValue;
	          } else if ([constants$1.componentTypes.categorySearch].includes(componentProps[component].componentType)) {
	            valueToSet = componentProps[component].defaultValue ? componentProps[component].defaultValue.term : '';
	          }
	          if (!(0, helper.isEqual)(selectedValues[component].value, valueToSet)) {
	            defaultValues = _extends({}, defaultValues, _defineProperty({}, component, _extends({}, selectedValues[component], {
	              value: valueToSet
	            })));
	          }
	        }
	      });
	      dispatch({
	        type: constants.RESET_TO_DEFAULT,
	        defaultValues: defaultValues
	      });
	    };
	  }
	  function setInternalValue(component, value, componentType, category, meta) {
	    return {
	      type: constants.SET_INTERNAL_VALUE,
	      component: component,
	      value: value,
	      componentType: componentType,
	      category: category,
	      meta: meta
	    };
	  }
	  function patchValue(component, payload) {
	    return {
	      type: constants.PATCH_VALUE,
	      component: component,
	      payload: payload
	    };
	  }
	  function clearValues() {
	    var resetValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var clearAllBlacklistComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    return {
	      type: constants.CLEAR_VALUES,
	      resetValues: resetValues,
	      clearAllBlacklistComponents: clearAllBlacklistComponents
	    };
	  }
	  function setValues(componentsValues) {
	    return function (dispatch) {
	      dispatch((0, utils.updateStoreConfig)({
	        queryLockConfig: {
	          initialTimestamp: new Date().getTime(),
	          lockTime: 300
	        }
	      }));
	      dispatch({
	        type: constants.SET_VALUES,
	        componentsValues: componentsValues
	      });
	    };
	  }
	});
	unwrapExports(value);
	var value_1 = value.setValue;
	var value_2 = value.resetValuesToDefault;
	var value_3 = value.setInternalValue;
	var value_4 = value.patchValue;
	var value_5 = value.clearValues;
	var value_6 = value.setValues;

	var maps = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.updateMapData = updateMapData;
	  exports.setMapData = setMapData;
	  exports.setMapResults = setMapResults;
	  function updateMapData(componentId, query, persistMapQuery) {
	    return {
	      type: constants.SET_MAP_DATA,
	      componentId: componentId,
	      query: query,
	      persistMapQuery: persistMapQuery
	    };
	  }
	  function setMapData(componentId, query$1, persistMapQuery, forceExecute) {
	    var meta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	    var queryId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
	    return function (dispatch) {
	      dispatch(updateMapData(componentId, query$1, persistMapQuery));
	      dispatch((0, value.setInternalValue)((0, transform.getInternalComponentID)(componentId), undefined, undefined, undefined, meta));
	      if (forceExecute) {
	        var executeWatchList = false;
	        var mustExecuteMapQuery = true;
	        dispatch((0, query.executeQuery)(componentId, executeWatchList, mustExecuteMapQuery, constants$1.componentTypes.reactiveMap, {}, queryId));
	      }
	    };
	  }
	  function setMapResults(componentId, _ref) {
	    var center = _ref.center,
	      zoom = _ref.zoom,
	      markers = _ref.markers;
	    return {
	      type: constants.SET_MAP_RESULTS,
	      componentId: componentId,
	      payload: {
	        center: center,
	        zoom: zoom,
	        markers: markers
	      }
	    };
	  }
	});
	unwrapExports(maps);
	var maps_1 = maps.updateMapData;
	var maps_2 = maps.setMapData;
	var maps_3 = maps.setMapResults;

	var browserPonyfill = createCommonjsModule(function (module, exports) {
	  var global = typeof self !== 'undefined' ? self : commonjsGlobal;
	  var __self__ = function () {
	    function F() {
	      this.fetch = false;
	      this.DOMException = global.DOMException;
	    }
	    F.prototype = global;
	    return new F();
	  }();
	  (function (self) {
	    var irrelevant = function (exports) {
	      var support = {
	        searchParams: 'URLSearchParams' in self,
	        iterable: 'Symbol' in self && 'iterator' in Symbol,
	        blob: 'FileReader' in self && 'Blob' in self && function () {
	          try {
	            new Blob();
	            return true;
	          } catch (e) {
	            return false;
	          }
	        }(),
	        formData: 'FormData' in self,
	        arrayBuffer: 'ArrayBuffer' in self
	      };
	      function isDataView(obj) {
	        return obj && DataView.prototype.isPrototypeOf(obj);
	      }
	      if (support.arrayBuffer) {
	        var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
	        var isArrayBufferView = ArrayBuffer.isView || function (obj) {
	          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
	        };
	      }
	      function normalizeName(name) {
	        if (typeof name !== 'string') {
	          name = String(name);
	        }
	        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	          throw new TypeError('Invalid character in header field name');
	        }
	        return name.toLowerCase();
	      }
	      function normalizeValue(value) {
	        if (typeof value !== 'string') {
	          value = String(value);
	        }
	        return value;
	      }

	      // Build a destructive iterator for the value list
	      function iteratorFor(items) {
	        var iterator = {
	          next: function next() {
	            var value = items.shift();
	            return {
	              done: value === undefined,
	              value: value
	            };
	          }
	        };
	        if (support.iterable) {
	          iterator[Symbol.iterator] = function () {
	            return iterator;
	          };
	        }
	        return iterator;
	      }
	      function Headers(headers) {
	        this.map = {};
	        if (headers instanceof Headers) {
	          headers.forEach(function (value, name) {
	            this.append(name, value);
	          }, this);
	        } else if (Array.isArray(headers)) {
	          headers.forEach(function (header) {
	            this.append(header[0], header[1]);
	          }, this);
	        } else if (headers) {
	          Object.getOwnPropertyNames(headers).forEach(function (name) {
	            this.append(name, headers[name]);
	          }, this);
	        }
	      }
	      Headers.prototype.append = function (name, value) {
	        name = normalizeName(name);
	        value = normalizeValue(value);
	        var oldValue = this.map[name];
	        this.map[name] = oldValue ? oldValue + ', ' + value : value;
	      };
	      Headers.prototype['delete'] = function (name) {
	        delete this.map[normalizeName(name)];
	      };
	      Headers.prototype.get = function (name) {
	        name = normalizeName(name);
	        return this.has(name) ? this.map[name] : null;
	      };
	      Headers.prototype.has = function (name) {
	        return this.map.hasOwnProperty(normalizeName(name));
	      };
	      Headers.prototype.set = function (name, value) {
	        this.map[normalizeName(name)] = normalizeValue(value);
	      };
	      Headers.prototype.forEach = function (callback, thisArg) {
	        for (var name in this.map) {
	          if (this.map.hasOwnProperty(name)) {
	            callback.call(thisArg, this.map[name], name, this);
	          }
	        }
	      };
	      Headers.prototype.keys = function () {
	        var items = [];
	        this.forEach(function (value, name) {
	          items.push(name);
	        });
	        return iteratorFor(items);
	      };
	      Headers.prototype.values = function () {
	        var items = [];
	        this.forEach(function (value) {
	          items.push(value);
	        });
	        return iteratorFor(items);
	      };
	      Headers.prototype.entries = function () {
	        var items = [];
	        this.forEach(function (value, name) {
	          items.push([name, value]);
	        });
	        return iteratorFor(items);
	      };
	      if (support.iterable) {
	        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	      }
	      function consumed(body) {
	        if (body.bodyUsed) {
	          return Promise.reject(new TypeError('Already read'));
	        }
	        body.bodyUsed = true;
	      }
	      function fileReaderReady(reader) {
	        return new Promise(function (resolve, reject) {
	          reader.onload = function () {
	            resolve(reader.result);
	          };
	          reader.onerror = function () {
	            reject(reader.error);
	          };
	        });
	      }
	      function readBlobAsArrayBuffer(blob) {
	        var reader = new FileReader();
	        var promise = fileReaderReady(reader);
	        reader.readAsArrayBuffer(blob);
	        return promise;
	      }
	      function readBlobAsText(blob) {
	        var reader = new FileReader();
	        var promise = fileReaderReady(reader);
	        reader.readAsText(blob);
	        return promise;
	      }
	      function readArrayBufferAsText(buf) {
	        var view = new Uint8Array(buf);
	        var chars = new Array(view.length);
	        for (var i = 0; i < view.length; i++) {
	          chars[i] = String.fromCharCode(view[i]);
	        }
	        return chars.join('');
	      }
	      function bufferClone(buf) {
	        if (buf.slice) {
	          return buf.slice(0);
	        } else {
	          var view = new Uint8Array(buf.byteLength);
	          view.set(new Uint8Array(buf));
	          return view.buffer;
	        }
	      }
	      function Body() {
	        this.bodyUsed = false;
	        this._initBody = function (body) {
	          this._bodyInit = body;
	          if (!body) {
	            this._bodyText = '';
	          } else if (typeof body === 'string') {
	            this._bodyText = body;
	          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	            this._bodyBlob = body;
	          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	            this._bodyFormData = body;
	          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	            this._bodyText = body.toString();
	          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	            this._bodyArrayBuffer = bufferClone(body.buffer);
	            // IE 10-11 can't handle a DataView body.
	            this._bodyInit = new Blob([this._bodyArrayBuffer]);
	          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	            this._bodyArrayBuffer = bufferClone(body);
	          } else {
	            this._bodyText = body = Object.prototype.toString.call(body);
	          }
	          if (!this.headers.get('content-type')) {
	            if (typeof body === 'string') {
	              this.headers.set('content-type', 'text/plain;charset=UTF-8');
	            } else if (this._bodyBlob && this._bodyBlob.type) {
	              this.headers.set('content-type', this._bodyBlob.type);
	            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	          }
	        };
	        if (support.blob) {
	          this.blob = function () {
	            var rejected = consumed(this);
	            if (rejected) {
	              return rejected;
	            }
	            if (this._bodyBlob) {
	              return Promise.resolve(this._bodyBlob);
	            } else if (this._bodyArrayBuffer) {
	              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
	            } else if (this._bodyFormData) {
	              throw new Error('could not read FormData body as blob');
	            } else {
	              return Promise.resolve(new Blob([this._bodyText]));
	            }
	          };
	          this.arrayBuffer = function () {
	            if (this._bodyArrayBuffer) {
	              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
	            } else {
	              return this.blob().then(readBlobAsArrayBuffer);
	            }
	          };
	        }
	        this.text = function () {
	          var rejected = consumed(this);
	          if (rejected) {
	            return rejected;
	          }
	          if (this._bodyBlob) {
	            return readBlobAsText(this._bodyBlob);
	          } else if (this._bodyArrayBuffer) {
	            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
	          } else if (this._bodyFormData) {
	            throw new Error('could not read FormData body as text');
	          } else {
	            return Promise.resolve(this._bodyText);
	          }
	        };
	        if (support.formData) {
	          this.formData = function () {
	            return this.text().then(decode);
	          };
	        }
	        this.json = function () {
	          return this.text().then(JSON.parse);
	        };
	        return this;
	      }

	      // HTTP methods whose capitalization should be normalized
	      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
	      function normalizeMethod(method) {
	        var upcased = method.toUpperCase();
	        return methods.indexOf(upcased) > -1 ? upcased : method;
	      }
	      function Request(input, options) {
	        options = options || {};
	        var body = options.body;
	        if (input instanceof Request) {
	          if (input.bodyUsed) {
	            throw new TypeError('Already read');
	          }
	          this.url = input.url;
	          this.credentials = input.credentials;
	          if (!options.headers) {
	            this.headers = new Headers(input.headers);
	          }
	          this.method = input.method;
	          this.mode = input.mode;
	          this.signal = input.signal;
	          if (!body && input._bodyInit != null) {
	            body = input._bodyInit;
	            input.bodyUsed = true;
	          }
	        } else {
	          this.url = String(input);
	        }
	        this.credentials = options.credentials || this.credentials || 'same-origin';
	        if (options.headers || !this.headers) {
	          this.headers = new Headers(options.headers);
	        }
	        this.method = normalizeMethod(options.method || this.method || 'GET');
	        this.mode = options.mode || this.mode || null;
	        this.signal = options.signal || this.signal;
	        this.referrer = null;
	        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	          throw new TypeError('Body not allowed for GET or HEAD requests');
	        }
	        this._initBody(body);
	      }
	      Request.prototype.clone = function () {
	        return new Request(this, {
	          body: this._bodyInit
	        });
	      };
	      function decode(body) {
	        var form = new FormData();
	        body.trim().split('&').forEach(function (bytes) {
	          if (bytes) {
	            var split = bytes.split('=');
	            var name = split.shift().replace(/\+/g, ' ');
	            var value = split.join('=').replace(/\+/g, ' ');
	            form.append(decodeURIComponent(name), decodeURIComponent(value));
	          }
	        });
	        return form;
	      }
	      function parseHeaders(rawHeaders) {
	        var headers = new Headers();
	        // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	        // https://tools.ietf.org/html/rfc7230#section-3.2
	        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
	        preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
	          var parts = line.split(':');
	          var key = parts.shift().trim();
	          if (key) {
	            var value = parts.join(':').trim();
	            headers.append(key, value);
	          }
	        });
	        return headers;
	      }
	      Body.call(Request.prototype);
	      function Response(bodyInit, options) {
	        if (!options) {
	          options = {};
	        }
	        this.type = 'default';
	        this.status = options.status === undefined ? 200 : options.status;
	        this.ok = this.status >= 200 && this.status < 300;
	        this.statusText = 'statusText' in options ? options.statusText : 'OK';
	        this.headers = new Headers(options.headers);
	        this.url = options.url || '';
	        this._initBody(bodyInit);
	      }
	      Body.call(Response.prototype);
	      Response.prototype.clone = function () {
	        return new Response(this._bodyInit, {
	          status: this.status,
	          statusText: this.statusText,
	          headers: new Headers(this.headers),
	          url: this.url
	        });
	      };
	      Response.error = function () {
	        var response = new Response(null, {
	          status: 0,
	          statusText: ''
	        });
	        response.type = 'error';
	        return response;
	      };
	      var redirectStatuses = [301, 302, 303, 307, 308];
	      Response.redirect = function (url, status) {
	        if (redirectStatuses.indexOf(status) === -1) {
	          throw new RangeError('Invalid status code');
	        }
	        return new Response(null, {
	          status: status,
	          headers: {
	            location: url
	          }
	        });
	      };
	      exports.DOMException = self.DOMException;
	      try {
	        new exports.DOMException();
	      } catch (err) {
	        exports.DOMException = function (message, name) {
	          this.message = message;
	          this.name = name;
	          var error = Error(message);
	          this.stack = error.stack;
	        };
	        exports.DOMException.prototype = Object.create(Error.prototype);
	        exports.DOMException.prototype.constructor = exports.DOMException;
	      }
	      function fetch(input, init) {
	        return new Promise(function (resolve, reject) {
	          var request = new Request(input, init);
	          if (request.signal && request.signal.aborted) {
	            return reject(new exports.DOMException('Aborted', 'AbortError'));
	          }
	          var xhr = new XMLHttpRequest();
	          function abortXhr() {
	            xhr.abort();
	          }
	          xhr.onload = function () {
	            var options = {
	              status: xhr.status,
	              statusText: xhr.statusText,
	              headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	            };
	            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	            var body = 'response' in xhr ? xhr.response : xhr.responseText;
	            resolve(new Response(body, options));
	          };
	          xhr.onerror = function () {
	            reject(new TypeError('Network request failed'));
	          };
	          xhr.ontimeout = function () {
	            reject(new TypeError('Network request failed'));
	          };
	          xhr.onabort = function () {
	            reject(new exports.DOMException('Aborted', 'AbortError'));
	          };
	          xhr.open(request.method, request.url, true);
	          if (request.credentials === 'include') {
	            xhr.withCredentials = true;
	          } else if (request.credentials === 'omit') {
	            xhr.withCredentials = false;
	          }
	          if ('responseType' in xhr && support.blob) {
	            xhr.responseType = 'blob';
	          }
	          request.headers.forEach(function (value, name) {
	            xhr.setRequestHeader(name, value);
	          });
	          if (request.signal) {
	            request.signal.addEventListener('abort', abortXhr);
	            xhr.onreadystatechange = function () {
	              // DONE (success or failure)
	              if (xhr.readyState === 4) {
	                request.signal.removeEventListener('abort', abortXhr);
	              }
	            };
	          }
	          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	        });
	      }
	      fetch.polyfill = true;
	      if (!self.fetch) {
	        self.fetch = fetch;
	        self.Headers = Headers;
	        self.Request = Request;
	        self.Response = Response;
	      }
	      exports.Headers = Headers;
	      exports.Request = Request;
	      exports.Response = Response;
	      exports.fetch = fetch;
	      Object.defineProperty(exports, '__esModule', {
	        value: true
	      });
	      return exports;
	    }({});
	  })(__self__);
	  __self__.fetch.ponyfill = true;
	  // Remove "polyfill" property added by whatwg-fetch
	  delete __self__.fetch.polyfill;
	  // Choose between native implementation (global) or custom implementation (__self__)
	  // var ctx = global.fetch ? global : __self__;
	  var ctx = __self__; // this line disable service worker support temporarily
	  exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
	  exports["default"] = ctx.fetch; // For TypeScript consumers without esModuleInterop.
	  exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
	  exports.Headers = ctx.Headers;
	  exports.Request = ctx.Request;
	  exports.Response = ctx.Response;
	  module.exports = exports;
	});
	var fetch$1 = unwrapExports(browserPonyfill);
	var browserPonyfill_1 = browserPonyfill.fetch;
	var browserPonyfill_2 = browserPonyfill.Headers;
	var browserPonyfill_3 = browserPonyfill.Request;
	var browserPonyfill_4 = browserPonyfill.Response;

	var graphQL = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  var _crossFetch2 = _interopRequireDefault(browserPonyfill);
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  var fetchGraphQL = function fetchGraphQL(requestOptions) {
	    var graphQLUrl = requestOptions.graphQLUrl,
	      url = requestOptions.url,
	      credentials = requestOptions.credentials,
	      app = requestOptions.app,
	      query = requestOptions.query,
	      headers = requestOptions.headers;
	    var fetchUrl = credentials ? url.replace('//', '//' + credentials + '@') : url;
	    return (0, _crossFetch2["default"])(graphQLUrl, {
	      method: 'POST',
	      body: '\n\t\t\tquery{\n\t\t\t\telastic77(host: "' + fetchUrl + '"){\n\t\t\t\t\tmsearch(\n\t\t\t\t\t\tindex: "' + app + '"\n\t\t\t\t\t\tbody: ' + JSON.stringify(query.map(function (item) {
	        return JSON.stringify(item);
	      })) + '\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t',
	      headers: _extends({}, headers, {
	        'Content-Type': 'application/graphql'
	      })
	    }).then(function (res) {
	      return res.json();
	    }).then(function (jsonRes) {
	      return jsonRes.data.elastic77.msearch;
	    })["catch"](function (error) {
	      console.error(error);
	    });
	  };
	  exports["default"] = fetchGraphQL;
	});
	var fetchGraphQL = unwrapExports(graphQL);

	var query = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.loadPopularSuggestions = loadPopularSuggestions;
	  exports.executeQuery = executeQuery;
	  exports.setQueryOptions = setQueryOptions;
	  exports.updateQuery = updateQuery;
	  exports.loadMore = loadMore;
	  exports.loadDataToExport = loadDataToExport;
	  var _analytics2 = _interopRequireDefault(analytics);
	  var _graphQL2 = _interopRequireDefault(graphQL);
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }
	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }
	  function loadPopularSuggestions(componentId) {
	    return function (dispatch, getState) {
	      var _getState = getState(),
	        config = _getState.config,
	        appbaseRef = _getState.appbaseRef,
	        props = _getState.props,
	        internalValues = _getState.internalValues;
	      var isAppbaseEnabled = config && config.enableAppbase;
	      var componentProps = props[componentId] || {};
	      var internalValue = internalValues[componentId];
	      var value = internalValue && internalValue.value || '';
	      if (isAppbaseEnabled && (componentProps.enablePopularSuggestions || componentProps.enableQuerySuggestions)) {
	        if (config.mongodb) {
	          dispatch((0, misc.setDefaultPopularSuggestions)([], componentId.split('__internal')[0]));
	          return;
	        }
	        var suggQuery = (0, utils.getSuggestionQuery)(getState, componentId);
	        appbaseRef.getQuerySuggestions(suggQuery).then(function (suggestions) {
	          var querySuggestion = suggestions[(0, utils.getQuerySuggestionsId)(componentId)];
	          if (value) {
	            dispatch((0, misc.setPopularSuggestions)(querySuggestion && querySuggestion.hits && querySuggestion.hits.hits, componentId.split('__internal')[0]));
	          } else {
	            dispatch((0, misc.setDefaultPopularSuggestions)(querySuggestion && querySuggestion.hits && querySuggestion.hits.hits, componentId.split('__internal')[0]));
	          }
	        })["catch"](function (e) {
	          (0, utils.handleError)({
	            orderOfQueries: [componentId],
	            error: e
	          }, getState, dispatch);
	        });
	      }
	    };
	  }
	  var handleTransformRequest = function handleTransformRequest(transformRequest, res) {
	    if (transformRequest && typeof transformRequest === 'function') {
	      var transformRequestPromise = transformRequest(res);
	      return transformRequestPromise instanceof Promise ? transformRequestPromise : Promise.resolve(transformRequestPromise);
	    }
	    return Promise.resolve(res);
	  };
	  function msearch(query, orderOfQueries) {
	    var appendToHits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    var isInternalComponent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	    var appendToAggs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	    var componentType = arguments[5];
	    return function (dispatch, getState) {
	      var _getState2 = getState(),
	        appbaseRef = _getState2.appbaseRef,
	        config = _getState2.config,
	        headers = _getState2.headers,
	        analytics$1 = _getState2.analytics,
	        selectedValues = _getState2.selectedValues;
	      var searchHeaders = {};
	      var suggestionsComponents = [constants$1.componentTypes.dataSearch, constants$1.componentTypes.categorySearch];
	      var isSuggestionsQuery = isInternalComponent && suggestionsComponents.indexOf(componentType) !== -1;
	      if (config.analytics) {
	        if (config.analyticsConfig.suggestionAnalytics && isSuggestionsQuery) {
	          var suggestionsSearchValue = analytics$1.suggestionsSearchValue;
	          var shouldIncludeQuery = !!(config.analyticsConfig.emptyQuery || suggestionsSearchValue);
	          if (shouldIncludeQuery) {
	            searchHeaders = {
	              'X-Search-Query': suggestionsSearchValue || ''
	            };
	          }
	        } else {
	          var searchValue = analytics$1.searchValue,
	            searchId = analytics$1.searchId;
	          var filterString = (0, _analytics2["default"])(selectedValues);
	          if (searchId) {
	            searchHeaders = _extends({
	              'X-Search-Id': searchId,
	              'X-Search-Query': searchValue || ''
	            }, filterString && {
	              'X-Search-Filters': filterString
	            });
	          } else {
	            var _shouldIncludeQuery = !!(config.analyticsConfig.emptyQuery || searchValue);
	            searchHeaders = _extends(_shouldIncludeQuery && {
	              'X-Search-Query': searchValue || ''
	            }, filterString && {
	              'X-Search-Filters': filterString
	            });
	          }
	        }
	        if (config.analyticsConfig.userId) {
	          searchHeaders['X-User-Id'] = config.analyticsConfig.userId;
	        }
	        if (config.analyticsConfig.customEvents) {
	          searchHeaders['X-Search-CustomEvent'] = (0, analytics.parseCustomEvents)(config.analyticsConfig.customEvents);
	        }
	      }
	      orderOfQueries.forEach(function (component) {
	        dispatch((0, misc.setLoading)(component, true));
	        dispatch((0, misc.setError)(component, null));
	      });
	      if (config.graphQLUrl) {
	        var requestOptions = {
	          graphQLUrl: config.graphQLUrl,
	          url: config.url,
	          credentials: config.credentials,
	          app: config.app,
	          query: query,
	          headers: headers
	        };
	        handleTransformRequest(appbaseRef.transformRequest, requestOptions).then(function (modifiedRequest) {
	          (0, _graphQL2["default"])(modifiedRequest).then(function (res) {
	            (0, utils.handleResponseMSearch)({
	              res: res,
	              isSuggestionsQuery: isSuggestionsQuery,
	              orderOfQueries: orderOfQueries,
	              appendToHits: appendToHits,
	              appendToAggs: appendToAggs
	            }, getState, dispatch);
	          })["catch"](function (err) {
	            (0, utils.handleError)({
	              orderOfQueries: orderOfQueries,
	              error: err
	            }, getState, dispatch);
	          });
	        })["catch"](function (err) {
	          (0, utils.handleError)({
	            orderOfQueries: orderOfQueries,
	            error: err
	          }, getState, dispatch);
	        });
	      } else {
	        appbaseRef.setHeaders(_extends({}, headers, searchHeaders));
	        appbaseRef.msearch({
	          type: config.type === '*' ? '' : config.type,
	          body: query
	        }).then(function (res) {
	          (0, utils.handleResponseMSearch)({
	            res: res,
	            isSuggestionsQuery: isSuggestionsQuery,
	            orderOfQueries: orderOfQueries,
	            appendToHits: appendToHits,
	            appendToAggs: appendToAggs
	          }, getState, dispatch);
	        })["catch"](function (err) {
	          (0, utils.handleError)({
	            orderOfQueries: orderOfQueries,
	            error: err
	          }, getState, dispatch);
	        });
	      }
	    };
	  }
	  function appbaseSearch() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      queryId = _ref.queryId,
	      query = _ref.query,
	      orderOfQueries = _ref.orderOfQueries,
	      _ref$appendToHits = _ref.appendToHits,
	      appendToHits = _ref$appendToHits === undefined ? false : _ref$appendToHits,
	      _ref$isSuggestionsQue = _ref.isSuggestionsQuery,
	      isSuggestionsQuery = _ref$isSuggestionsQue === undefined ? false : _ref$isSuggestionsQue,
	      searchComponentID = _ref.searchComponentID,
	      _ref$appendToAggs = _ref.appendToAggs,
	      appendToAggs = _ref$appendToAggs === undefined ? false : _ref$appendToAggs;
	    return function (dispatch, getState) {
	      var _getState3 = getState(),
	        appbaseRef = _getState3.appbaseRef,
	        config = _getState3.config,
	        headers = _getState3.headers;
	      var isAnalyticsEnabled = false;
	      if (config) {
	        if ((0, utils.isPropertyDefined)(config.analytics)) {
	          isAnalyticsEnabled = config.analytics;
	        } else if (config.analyticsConfig) {
	          if ((0, utils.isPropertyDefined)(config.analyticsConfig.recordAnalytics)) {
	            isAnalyticsEnabled = config.analyticsConfig.recordAnalytics;
	          } else if ((0, utils.isPropertyDefined)(config.analyticsConfig.analytics)) {
	            isAnalyticsEnabled = config.analyticsConfig.analytics;
	          }
	        }
	      }
	      var settings = {
	        recordAnalytics: isAnalyticsEnabled
	      };
	      if (config.analyticsConfig) {
	        settings.userId = (0, utils.isPropertyDefined)(config.analyticsConfig.userId) ? config.analyticsConfig.userId : undefined;
	        settings.enableQueryRules = (0, utils.isPropertyDefined)(config.analyticsConfig.enableQueryRules) ? config.analyticsConfig.enableQueryRules : undefined;
	        settings.customEvents = (0, utils.isPropertyDefined)(config.analyticsConfig.customEvents) ? config.analyticsConfig.customEvents : undefined;
	        settings.emptyQuery = (0, utils.isPropertyDefined)(config.analyticsConfig.emptyQuery) ? config.analyticsConfig.emptyQuery : undefined;
	        var searchRelevancy = config.analyticsConfig.enableSearchRelevancy;
	        settings.enableSearchRelevancy = (0, utils.isPropertyDefined)(searchRelevancy) ? searchRelevancy : undefined;
	        settings.suggestionAnalytics = (0, utils.isPropertyDefined)(config.analyticsConfig.suggestionAnalytics) ? config.analyticsConfig.suggestionAnalytics : undefined;
	        settings.useCache = (0, utils.isPropertyDefined)(config.analyticsConfig.useCache) ? config.analyticsConfig.useCache : undefined;
	        settings.queryParams = (0, utils.isPropertyDefined)(config.analyticsConfig.queryParams) ? config.analyticsConfig.queryParams : undefined;
	      }
	      orderOfQueries.forEach(function (component) {
	        dispatch((0, misc.setLoading)(component, true));
	        dispatch((0, misc.setError)(component, null));
	      });
	      appbaseRef.setHeaders(_extends({}, headers));
	      if (isSuggestionsQuery && searchComponentID) {
	        dispatch(loadPopularSuggestions(searchComponentID));
	      }
	      appbaseRef.reactiveSearch(query, settings, settings.queryParams).then(function (res) {
	        (0, utils.handleResponse)({
	          res: res,
	          orderOfQueries: orderOfQueries,
	          appendToHits: appendToHits,
	          appendToAggs: appendToAggs,
	          query: query,
	          queryId: queryId
	        }, getState, dispatch);
	      })["catch"](function (err) {
	        (0, utils.handleError)({
	          orderOfQueries: orderOfQueries,
	          error: err,
	          queryId: queryId
	        }, getState, dispatch);
	      });
	    };
	  }
	  var requestStack = [];
	  function executeQuery(componentId) {
	    var executeWatchList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var mustExecuteMapQuery = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    var componentType = arguments[3];
	    var metaOptions = arguments[4];
	    var requestId = arguments[5];
	    return function (dispatch, getState) {
	      var _getState4 = getState(),
	        queryLog = _getState4.queryLog,
	        config = _getState4.config,
	        mapData = _getState4.mapData,
	        watchMan = _getState4.watchMan,
	        dependencyTree = _getState4.dependencyTree,
	        queryList = _getState4.queryList,
	        queryOptions = _getState4.queryOptions,
	        queryListener = _getState4.queryListener,
	        props = _getState4.props,
	        internalValues = _getState4.internalValues,
	        lock = _getState4.lock,
	        selectedValues = _getState4.selectedValues;
	      var lockTime = config.initialQueriesSyncTime || 50;
	      var initialTimestamp = config.initialTimestamp;
	      var queryId = requestId || new Date().getTime();
	      if (config.queryLockConfig instanceof Object) {
	        lockTime = config.queryLockConfig.lockTime;
	        initialTimestamp = config.queryLockConfig.initialTimestamp;
	      }
	      var componentList = [componentId];
	      var finalQuery = [];
	      var appbaseQuery = {};
	      var orderOfQueries = [];
	      var isAppbaseEnabled = config && config.enableAppbase;
	      if (executeWatchList) {
	        var watchList = watchMan[componentId] || [];
	        componentList = [].concat(_toConsumableArray(componentList), _toConsumableArray(watchList));
	      }
	      var matchAllQuery = {
	        match_all: {}
	      };
	      componentList.forEach(function (component) {
	        var _buildQuery = (0, helper.buildQuery)(component, dependencyTree, queryList, queryOptions),
	          queryObj = _buildQuery.queryObj,
	          options = _buildQuery.options;
	        var validOptions = ['aggs', 'from', 'sort'];
	        if (queryObj && !!Object.keys(queryObj).length || options && Object.keys(options).some(function (item) {
	          return validOptions.includes(item);
	        })) {
	          if (!queryObj || queryObj && !Object.keys(queryObj).length) {
	            queryObj = _extends({}, matchAllQuery);
	          }
	          var from = void 0;
	          var depComponentType = props[component] ? props[component].componentType : null;
	          if (depComponentType === constants$1.componentTypes.reactiveList) {
	            var componentValue = selectedValues[component] ? selectedValues[component].value : undefined;
	            var componentProps = props[component];
	            if (componentValue !== undefined && componentProps) {
	              if (componentValue > 0) {
	                from = (componentValue - 1) * (componentProps.size || 10);
	              } else {
	                from = 0;
	              }
	            }
	          }
	          var currentQuery = _extends({
	            query: _extends({}, queryObj)
	          }, options, queryOptions[component], {
	            from: from
	          });
	          var queryToLog = _extends({
	            query: _extends({}, queryObj)
	          }, options, queryOptions[component], {
	            from: from
	          });
	          var oldQuery = queryLog[component];
	          if (mustExecuteMapQuery || !(0, helper.compareQueries)(currentQuery, oldQuery, false)) {
	            orderOfQueries = [].concat(_toConsumableArray(orderOfQueries), [component]);
	            var isMapComponent = Object.keys(mapData).includes(component);
	            if (isMapComponent) {
	              dispatch((0, misc.setLastUsedAppbaseQuery)(_defineProperty({}, component, {
	                queryId: queryId
	              })));
	            }
	            dispatch((0, misc.logQuery)(component, queryToLog));
	            if (isMapComponent && mapData[component].query) {
	              var existingQuery = currentQuery.query;
	              currentQuery.query = {
	                bool: {
	                  must: [existingQuery, mapData[component].query]
	                }
	              };
	              if (!mapData[component].persistMapQuery) {
	                dispatch((0, maps.updateMapData)(componentId, null, false));
	              }
	              var _getState5 = getState(),
	                combinedLog = _getState5.combinedLog;
	              if ((0, helper.compareQueries)(combinedLog[component], currentQuery)) return;
	              dispatch((0, misc.logCombinedQuery)(component, currentQuery));
	            }
	            (0, utils.executeQueryListener)(queryListener[component], oldQuery, currentQuery);
	            if (isAppbaseEnabled) {
	              var value = void 0;
	              var isInternalComponent = componentId.endsWith('__internal');
	              var mainComponentProps = props[componentId];
	              if (isInternalComponent && mainComponentProps && (0, transform.isSearchComponent)(mainComponentProps.componentType)) {
	                value = internalValues[componentId] && internalValues[componentId].value;
	              }
	              var query = (0, transform.getRSQuery)(component, (0, transform.extractPropsFromState)(getState(), component, _extends({}, value ? {
	                value: value
	              } : null, metaOptions ? {
	                from: metaOptions.from
	              } : null)));
	              if (query) {
	                appbaseQuery = _extends({}, appbaseQuery, _defineProperty({}, component, query), (0, transform.getDependentQueries)(getState(), component, orderOfQueries));
	              }
	              if (isMapComponent) {
	                var internalComponent = (0, transform.getInternalComponentID)(component);
	                var internalQuery = (0, transform.getRSQuery)(internalComponent, (0, transform.extractPropsFromState)(getState(), internalComponent, metaOptions ? {
	                  from: metaOptions.from
	                } : null));
	                if (internalQuery) {
	                  appbaseQuery[internalComponent] = _extends({}, internalQuery, {
	                    execute: false
	                  });
	                }
	              }
	            } else {
	              var preference = config && config.analyticsConfig && config.analyticsConfig.userId ? config.analyticsConfig.userId + '_' + component : component;
	              finalQuery = [].concat(_toConsumableArray(finalQuery), [{
	                preference: preference
	              }, currentQuery]);
	            }
	          }
	        }
	      });
	      if (isAppbaseEnabled) {
	        finalQuery = Object.keys(appbaseQuery).map(function (component) {
	          return appbaseQuery[component];
	        });
	      }
	      if (finalQuery.length) {
	        if (isAppbaseEnabled) {
	          var suggestionsComponents = [constants$1.componentTypes.dataSearch, constants$1.componentTypes.categorySearch];
	          var isInternalComponent = componentId.endsWith('__internal');
	          var isSuggestionsQuery = isInternalComponent && suggestionsComponents.indexOf(componentType) !== -1;
	          var currentTime = new Date().getTime();
	          if (currentTime - initialTimestamp < lockTime) {
	            if (!lock || config.queryLockConfig) {
	              setTimeout(function () {
	                var finalOrderOfQueries = [];
	                var finalIsSuggestionsQuery = false;
	                var finalSearchComponentID = '';
	                var orderOfQueriesMap = {};
	                var processedQueriesMap = {};
	                var queryExecutionMap = {};
	                requestStack.forEach(function (request) {
	                  if (!finalIsSuggestionsQuery) {
	                    finalIsSuggestionsQuery = request.isSuggestionsQuery;
	                  }
	                  if (!finalSearchComponentID) {
	                    finalSearchComponentID = request.searchComponentID;
	                  }
	                  if (Array.isArray(request.query)) {
	                    request.query.forEach(function (query) {
	                      if (query.execute) {
	                        queryExecutionMap[query.id] = query.execute;
	                      }
	                      var newQuery = query;
	                      if (queryExecutionMap[query.id]) {
	                        newQuery.execute = true;
	                      }
	                      if (processedQueriesMap[query.id] && processedQueriesMap[query.id].type === constants$1.queryTypes.suggestion && newQuery.type !== constants$1.queryTypes.suggestion) {
	                        processedQueriesMap[query.id + '__suggestion_type'] = _extends({}, processedQueriesMap[query.id]);
	                        processedQueriesMap[query.id] = _extends({}, newQuery, {
	                          execute: false
	                        });
	                        return;
	                      }
	                      processedQueriesMap[query.id] = newQuery;
	                    });
	                  }
	                  if (Array.isArray(request.orderOfQueries)) {
	                    request.orderOfQueries.forEach(function (query) {
	                      if (!orderOfQueriesMap[query.id]) {
	                        finalOrderOfQueries = [query].concat(_toConsumableArray(finalOrderOfQueries));
	                      } else {
	                        orderOfQueriesMap[query.id] = true;
	                      }
	                    });
	                  }
	                });
	                var finalCombinedQuery = Object.values(processedQueriesMap);
	                if (finalCombinedQuery.length) {
	                  dispatch(appbaseSearch({
	                    query: finalCombinedQuery,
	                    orderOfQueries: finalOrderOfQueries,
	                    isSuggestionsQuery: finalIsSuggestionsQuery,
	                    searchComponentID: finalSearchComponentID
	                  }));
	                }
	                requestStack = [];
	                dispatch((0, utils.updateStoreConfig)({
	                  queryLockConfig: undefined
	                }));
	              }, lockTime);
	            }
	            dispatch((0, utils.updateStoreConfig)({
	              lock: true
	            }));
	            requestStack.push({
	              query: finalQuery,
	              orderOfQueries: orderOfQueries,
	              isSuggestionsQuery: isSuggestionsQuery,
	              searchComponentID: componentId
	            });
	          } else {
	            dispatch(appbaseSearch({
	              queryId: queryId,
	              query: finalQuery,
	              orderOfQueries: orderOfQueries,
	              isSuggestionsQuery: isSuggestionsQuery,
	              searchComponentID: componentId
	            }));
	          }
	        } else {
	          dispatch(msearch(finalQuery, orderOfQueries, false, componentId.endsWith('__internal'), undefined, componentType));
	        }
	      }
	    };
	  }
	  function setQueryOptions(component, queryOptions) {
	    var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    return function (dispatch) {
	      dispatch((0, misc.updateQueryOptions)(component, queryOptions));
	      if (execute) {
	        dispatch(executeQuery(component, true));
	      }
	    };
	  }
	  function updateQuery(_ref2) {
	    var componentId = _ref2.componentId,
	      query = _ref2.query,
	      value$1 = _ref2.value,
	      _ref2$label = _ref2.label,
	      label = _ref2$label === undefined ? null : _ref2$label,
	      _ref2$showFilter = _ref2.showFilter,
	      showFilter = _ref2$showFilter === undefined ? true : _ref2$showFilter,
	      _ref2$URLParams = _ref2.URLParams,
	      URLParams = _ref2$URLParams === undefined ? false : _ref2$URLParams,
	      _ref2$componentType = _ref2.componentType,
	      componentType = _ref2$componentType === undefined ? null : _ref2$componentType,
	      _ref2$category = _ref2.category,
	      category = _ref2$category === undefined ? null : _ref2$category,
	      _ref2$meta = _ref2.meta,
	      meta = _ref2$meta === undefined ? {} : _ref2$meta;
	    var execute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    var shouldSetInternalValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    return function (dispatch) {
	      var queryToDispatch = query;
	      if (query && query.query) {
	        queryToDispatch = query.query;
	      }
	      if (!componentId.endsWith('__internal')) {
	        dispatch((0, value.setValue)(componentId, value$1, label, showFilter, URLParams, componentType, category, meta));
	        if (shouldSetInternalValue) {
	          if (componentType === constants$1.componentTypes.dynamicRangeSlider) {
	            dispatch((0, value.setInternalValue)((0, transform.getHistogramComponentID)(componentId), value$1, componentType, category, meta));
	          } else {
	            dispatch((0, value.setInternalValue)(componentId + '__internal', value$1, componentType, category, meta));
	          }
	        }
	      } else {
	        dispatch((0, value.setInternalValue)(componentId, value$1, componentType, category, meta));
	      }
	      dispatch((0, misc.setQuery)(componentId, queryToDispatch));
	      if (execute) dispatch(executeQuery(componentId, true, false, componentType));
	    };
	  }
	  function loadMore(component, newOptions) {
	    var appendToHits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    var appendToAggs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	    return function (dispatch, getState) {
	      var store = getState();
	      var _buildQuery2 = (0, helper.buildQuery)(component, store.dependencyTree, store.queryList, store.queryOptions),
	        queryObj = _buildQuery2.queryObj,
	        options = _buildQuery2.options;
	      var queryLog = store.queryLog;
	      if (!options) options = {};
	      options = _extends({}, options, newOptions);
	      if (!queryObj || queryObj && !Object.keys(queryObj).length) {
	        queryObj = {
	          match_all: {}
	        };
	      }
	      var currentQuery = _extends({
	        query: _extends({}, queryObj)
	      }, options);
	      if ((0, helper.compareQueries)(queryLog[component], currentQuery)) return;
	      dispatch((0, misc.logQuery)(component, currentQuery));
	      if (store.config && store.config.enableAppbase) {
	        var appbaseQuery = {};
	        var componentProps = store.props[component] || {};
	        var compositeAggregationField = componentProps.aggregationField;
	        var queryType = transform.componentToTypeMap[componentProps.componentType];
	        if (queryType === constants$1.queryTypes.term) {
	          compositeAggregationField = componentProps.dataField;
	        }
	        var query = (0, transform.getRSQuery)(component, (0, transform.extractPropsFromState)(store, component, {
	          from: options.from,
	          after: store.aggregations[component] && store.aggregations[component][compositeAggregationField] && store.aggregations[component][compositeAggregationField].after_key || undefined
	        }));
	        appbaseQuery = _extends(_defineProperty({}, component, query), (0, transform.getDependentQueries)(getState(), component, []));
	        var finalQuery = Object.keys(appbaseQuery).map(function (c) {
	          return appbaseQuery[c];
	        });
	        dispatch(appbaseSearch({
	          query: finalQuery,
	          orderOfQueries: [component],
	          appendToHits: appendToHits,
	          appendToAggs: appendToAggs
	        }));
	      } else {
	        var preference = store.config && store.config.analyticsConfig && store.config.analyticsConfig.userId ? store.config.analyticsConfig.userId + '_' + component : component;
	        var _finalQuery = [{
	          preference: preference
	        }, currentQuery];
	        dispatch(msearch(_finalQuery, [component], appendToHits, false, appendToAggs));
	      }
	    };
	  }
	  function loadDataToExport(componentId) {
	    var deepPaginationCursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	    var totalResults = arguments[2];
	    var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
	    return function (dispatch, getState) {
	      var _getState6 = getState(),
	        appbaseRef = _getState6.appbaseRef,
	        lastUsedAppbaseQuery = _getState6.lastUsedAppbaseQuery;
	      var queryFromStore = lastUsedAppbaseQuery[componentId];
	      if (queryFromStore) {
	        var query = queryFromStore.map(function (queryItem) {
	          if (queryItem.id === componentId) {
	            var finalQueryItem = _extends({}, queryItem, {
	              deepPaginationConfig: {
	                cursor: deepPaginationCursor
	              },
	              deepPagination: true,
	              size: totalResults < 1000 ? totalResults : 1000,
	              sortField: '_id',
	              sortBy: 'asc'
	            });
	            delete finalQueryItem.from;
	            return finalQueryItem;
	          }
	          return queryItem;
	        });
	        if (totalResults && Array.isArray(data) && totalResults <= data.length) {
	          return data;
	        }
	        return appbaseRef.reactiveSearchv3(query).then(function (res) {
	          var newDataChunk = res[componentId].hits.hits;
	          if (!Array.isArray(newDataChunk) || newDataChunk.length === 0) {
	            return data;
	          }
	          return dispatch(loadDataToExport(componentId, newDataChunk[newDataChunk.length - 1]._id, res[componentId].hits.total.value, [].concat(_toConsumableArray(data), _toConsumableArray(newDataChunk))));
	        })["catch"](function (err) {
	          console.error('Error fetching data to export! ', err);
	        });
	      }
	      return console.error('Error fetching data to export!');
	    };
	  }
	});
	unwrapExports(query);
	var query_1 = query.loadPopularSuggestions;
	var query_2 = query.executeQuery;
	var query_3 = query.setQueryOptions;
	var query_4 = query.updateQuery;
	var query_5 = query.loadMore;
	var query_6 = query.loadDataToExport;

	var component = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.addComponent = addComponent;
	  exports.removeComponent = removeComponent;
	  exports.watchComponent = watchComponent;
	  function addComponentToList(component) {
	    return {
	      type: constants.ADD_COMPONENT,
	      component: component
	    };
	  }
	  function addComponentTimestamp(component, timestamp) {
	    return {
	      type: constants.SET_REGISTERED_COMPONENT_TIMESTAMP,
	      component: component,
	      timestamp: timestamp
	    };
	  }
	  function addComponent(component, timestamp) {
	    return function (dispatch) {
	      dispatch(addComponentToList(component));
	      dispatch(addComponentTimestamp(component, timestamp));
	    };
	  }
	  function removeComponent(component) {
	    return {
	      type: constants.REMOVE_COMPONENT,
	      component: component
	    };
	  }
	  function updateWatchman(component, react) {
	    return {
	      type: constants.WATCH_COMPONENT,
	      component: component,
	      react: react
	    };
	  }
	  function watchComponent(component, react) {
	    var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    return function (dispatch) {
	      dispatch(updateWatchman(component, react));
	      if (execute) dispatch((0, query.executeQuery)(component));
	    };
	  }
	});
	unwrapExports(component);
	var component_1 = component.addComponent;
	var component_2 = component.removeComponent;
	var component_3 = component.watchComponent;

	var props = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.setComponentProps = setComponentProps;
	  exports.updateComponentProps = updateComponentProps;
	  exports.removeComponentProps = removeComponentProps;
	  var getfilteredOptions = function getfilteredOptions() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var filteredOptions = {};
	    Object.keys(options).forEach(function (option) {
	      if (constants$1.validProps.includes(option)) {
	        filteredOptions[option] = options[option];
	      }
	    });
	    return filteredOptions;
	  };
	  function setComponentProps(component, options, componentType) {
	    return {
	      type: constants.SET_PROPS,
	      component: component,
	      options: getfilteredOptions(_extends({}, options, {
	        componentType: componentType
	      }))
	    };
	  }
	  function updateComponentProps(component, options, componentType) {
	    return {
	      type: constants.UPDATE_PROPS,
	      component: component,
	      options: getfilteredOptions(_extends({}, options, {
	        componentType: componentType
	      }))
	    };
	  }
	  function removeComponentProps(component) {
	    return {
	      type: constants.REMOVE_PROPS,
	      component: component
	    };
	  }
	});
	unwrapExports(props);
	var props_1 = props.setComponentProps;
	var props_2 = props.updateComponentProps;
	var props_3 = props.removeComponentProps;

	var analytics$1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports.setSuggestionsSearchValue = setSuggestionsSearchValue;
	  exports.clearSuggestionsSearchValue = clearSuggestionsSearchValue;
	  exports.updateAnalyticsConfig = updateAnalyticsConfig;
	  exports.getRecentSearches = getRecentSearches;
	  exports.recordResultClick = recordResultClick;
	  exports.recordSuggestionClick = recordSuggestionClick;
	  exports.recordImpressions = recordImpressions;
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }
	    return obj;
	  }
	  function setSuggestionsSearchValue(value) {
	    return {
	      type: constants.SET_SUGGESTIONS_SEARCH_VALUE,
	      value: value
	    };
	  }
	  function clearSuggestionsSearchValue() {
	    return {
	      type: constants.CLEAR_SUGGESTIONS_SEARCH_VALUE
	    };
	  }
	  function updateAnalyticsConfig(analyticsConfig) {
	    return {
	      type: constants.UPDATE_ANALYTICS_CONFIG,
	      analyticsConfig: analyticsConfig
	    };
	  }
	  function getRecentSearches() {
	    var queryOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	      size: 5,
	      minChars: 3
	    };
	    return function (dispatch, getState) {
	      var _getState = getState(),
	        config = _getState.config,
	        headers = _getState.headers,
	        _getState$appbaseRef = _getState.appbaseRef,
	        url = _getState$appbaseRef.url,
	        protocol = _getState$appbaseRef.protocol,
	        credentials = _getState$appbaseRef.credentials;
	      var app = config.app,
	        mongodb = config.mongodb;
	      var esURL = protocol + '://' + url;
	      var parsedURL = (esURL || '').replace(/\/+$/, '');
	      var requestOptions = {
	        headers: _extends({}, headers, {
	          'Content-Type': 'application/json',
	          Authorization: 'Basic ' + btoa(credentials)
	        })
	      };
	      var queryString = '';
	      var addParam = function addParam(key, value) {
	        if (queryString) {
	          queryString += '&' + key + '=' + value;
	        } else {
	          queryString += key + '=' + value;
	        }
	      };
	      if (config.analyticsConfig && config.analyticsConfig.userId) {
	        addParam('user_id', config.analyticsConfig.userId);
	      }
	      if (queryOptions) {
	        if (queryOptions.size) {
	          addParam('size', String(queryOptions.size));
	        }
	        if (queryOptions.from) {
	          addParam('from', queryOptions.from);
	        }
	        if (queryOptions.to) {
	          addParam('to', queryOptions.to);
	        }
	        if (queryOptions.minChars) {
	          addParam('min_chars', String(queryOptions.minChars));
	        }
	        if (queryOptions.customEvents) {
	          Object.keys(queryOptions.customEvents).forEach(function (key) {
	            addParam(key, queryOptions.customEvents[key]);
	          });
	        }
	      }
	      if (mongodb) {
	        return dispatch({
	          type: constants.RECENT_SEARCHES_SUCCESS,
	          data: []
	        });
	      }
	      return fetch(parsedURL + '/_analytics/' + app + '/recent-searches?' + queryString, requestOptions).then(function (res) {
	        if (res.status >= 500 || res.status >= 400) {
	          return dispatch({
	            type: constants.RECENT_SEARCHES_ERROR,
	            error: res
	          });
	        }
	        return res.json().then(function (recentSearches) {
	          return dispatch({
	            type: constants.RECENT_SEARCHES_SUCCESS,
	            data: recentSearches
	          });
	        })["catch"](function (e) {
	          return dispatch({
	            type: constants.RECENT_SEARCHES_ERROR,
	            error: e
	          });
	        });
	      })["catch"](function (e) {
	        return dispatch({
	          type: constants.RECENT_SEARCHES_ERROR,
	          error: e
	        });
	      });
	    };
	  }
	  function recordClick(_ref) {
	    var documentId = _ref.documentId,
	      clickPosition = _ref.clickPosition,
	      analyticsInstance = _ref.analyticsInstance,
	      isSuggestionClick = _ref.isSuggestionClick;
	    if (!documentId) {
	      console.warn('ReactiveSearch: document id is required to record the click analytics');
	    } else {
	      analyticsInstance.click({
	        queryID: analyticsInstance.getQueryID(),
	        objects: _defineProperty({}, documentId, clickPosition + 1),
	        isSuggestionClick: isSuggestionClick
	      });
	    }
	  }
	  function recordResultClick(searchPosition, documentId) {
	    return function (dispatch, getState) {
	      var _getState2 = getState(),
	        config = _getState2.config,
	        searchId = _getState2.analytics.searchId,
	        headers = _getState2.headers,
	        _getState2$appbaseRef = _getState2.appbaseRef,
	        url = _getState2$appbaseRef.url,
	        protocol = _getState2$appbaseRef.protocol,
	        credentials = _getState2$appbaseRef.credentials,
	        analyticsInstance = _getState2.analyticsRef;
	      var app = config.app;
	      var esURL = protocol + '://' + url;
	      if (config.analytics && searchId) {
	        var parsedHeaders = headers;
	        delete parsedHeaders['X-Search-Query'];
	        var parsedURL = (esURL || '').replace(/\/+$/, '');
	        if (parsedURL.includes('scalr.api.appbase.io')) {
	          fetch(parsedURL + '/' + app + '/_analytics', {
	            method: 'POST',
	            headers: _extends({}, parsedHeaders, {
	              'Content-Type': 'application/json',
	              Authorization: 'Basic ' + btoa(credentials),
	              'X-Search-Id': searchId,
	              'X-Search-Click': true,
	              'X-Search-ClickPosition': searchPosition + 1
	            })
	          });
	        } else {
	          recordClick({
	            documentId: documentId,
	            clickPosition: searchPosition,
	            analyticsInstance: analyticsInstance
	          });
	        }
	      }
	    };
	  }
	  function recordSuggestionClick(searchPosition, documentId) {
	    return function (dispatch, getState) {
	      var _getState3 = getState(),
	        config = _getState3.config,
	        suggestionsSearchId = _getState3.analytics.suggestionsSearchId,
	        headers = _getState3.headers,
	        _getState3$appbaseRef = _getState3.appbaseRef,
	        url = _getState3$appbaseRef.url,
	        protocol = _getState3$appbaseRef.protocol,
	        credentials = _getState3$appbaseRef.credentials,
	        analyticsInstance = _getState3.analyticsRef;
	      var app = config.app;
	      var esURL = protocol + '://' + url;
	      if (config.analytics && (config.analyticsConfig === undefined || config.analyticsConfig.suggestionAnalytics === undefined || config.analyticsConfig.suggestionAnalytics)) {
	        var parsedHeaders = headers;
	        delete parsedHeaders['X-Search-Query'];
	        var parsedURL = (esURL || '').replace(/\/+$/, '');
	        if (parsedURL.includes('scalr.api.appbase.io') && searchPosition !== undefined && suggestionsSearchId) {
	          fetch(parsedURL + '/' + app + '/_analytics', {
	            method: 'POST',
	            headers: _extends({}, parsedHeaders, {
	              'Content-Type': 'application/json',
	              Authorization: 'Basic ' + btoa(credentials),
	              'X-Search-Id': suggestionsSearchId,
	              'X-Search-Suggestions-Click': true,
	              'X-Search-Suggestions-ClickPosition': searchPosition + 1
	            })
	          });
	        } else if (searchPosition !== undefined) {
	          recordClick({
	            documentId: documentId,
	            clickPosition: searchPosition,
	            analyticsInstance: analyticsInstance,
	            isSuggestionClick: true
	          });
	        }
	      }
	    };
	  }
	  function recordImpressions(queryId) {
	    var impressions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    return function (dispatch, getState) {
	      var _getState4 = getState(),
	        _getState4$appbaseRef = _getState4.appbaseRef,
	        url = _getState4$appbaseRef.url,
	        protocol = _getState4$appbaseRef.protocol,
	        analyticsInstance = _getState4.analyticsRef,
	        config = _getState4.config;
	      var esURL = protocol + '://' + url;
	      var parsedURL = esURL.replace(/\/+$/, '');
	      if (config.analytics && !parsedURL.includes('scalr.api.appbase.io') && queryId && impressions.length) {
	        analyticsInstance.search({
	          queryID: analyticsInstance.getQueryID(),
	          impressions: impressions
	        });
	      }
	    };
	  }
	});
	unwrapExports(analytics$1);
	var analytics_1$1 = analytics$1.setSuggestionsSearchValue;
	var analytics_2$1 = analytics$1.clearSuggestionsSearchValue;
	var analytics_3$1 = analytics$1.updateAnalyticsConfig;
	var analytics_4$1 = analytics$1.getRecentSearches;
	var analytics_5$1 = analytics$1.recordResultClick;
	var analytics_6$1 = analytics$1.recordSuggestionClick;
	var analytics_7$1 = analytics$1.recordImpressions;

	var actions = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  Object.keys(component).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return component[key];
	      }
	    });
	  });
	  Object.keys(hits).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return hits[key];
	      }
	    });
	  });
	  Object.keys(maps).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return maps[key];
	      }
	    });
	  });
	  Object.keys(query).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return query[key];
	      }
	    });
	  });
	  Object.keys(value).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return value[key];
	      }
	    });
	  });
	  Object.keys(props).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return props[key];
	      }
	    });
	  });
	  Object.keys(analytics$1).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return analytics$1[key];
	      }
	    });
	  });
	  Object.keys(misc).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return misc[key];
	      }
	    });
	  });
	});
	unwrapExports(actions);

	if (!Array.prototype.find) {
	  Object.defineProperty(Array.prototype, 'find', {
	    value: function value(predicate) {
	      if (this == null) {
	        throw new TypeError('"this" is null or not defined');
	      }
	      var o = Object(this);
	      var len = o.length >>> 0;
	      if (typeof predicate !== 'function') {
	        throw new TypeError('predicate must be a function');
	      }
	      var thisArg = arguments[1];
	      var k = 0;
	      while (k < len) {
	        var kValue = o[k];
	        if (predicate.call(thisArg, kValue, k, o)) {
	          return kValue;
	        }
	        k++;
	      }
	      return undefined;
	    },
	    configurable: true,
	    writable: true
	  });
	}
	if (!String.prototype.endsWith) {
	  String.prototype.endsWith = function (pattern) {
	    var d = this.length - pattern.length;
	    return d >= 0 && this.lastIndexOf(pattern) === d;
	  };
	}
	if (typeof Event !== 'function') {
	  var _Event = function _Event(event) {
	    var evt = document.createEvent('Event');
	    evt.initEvent(event, true, true);
	    return evt;
	  };
	  if (typeof window !== 'undefined') {
	    window.Event = _Event;
	  }
	}

	var polyfills = /*#__PURE__*/Object.freeze({
		__proto__: null
	});

	var causes_1 = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var ENTER_PRESS = 'ENTER_PRESS';
	  var SUGGESTION_SELECT = 'SUGGESTION_SELECT';
	  var CLEAR_VALUE = 'CLEAR_VALUE';
	  var SEARCH_ICON_CLICK = 'SEARCH_ICON_CLICK';
	  var causes = {
	    ENTER_PRESS: ENTER_PRESS,
	    SUGGESTION_SELECT: SUGGESTION_SELECT,
	    CLEAR_VALUE: CLEAR_VALUE,
	    SEARCH_ICON_CLICK: SEARCH_ICON_CLICK
	  };
	  exports["default"] = causes;
	});
	unwrapExports(causes_1);

	var lib = createCommonjsModule(function (module, exports) {
	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.constants = exports.Reducers = exports.polyfills = exports.storeKey = exports.Actions = exports.suggestions = exports.causes = exports.helper = undefined;
	  var _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  exports["default"] = configureStore;
	  var _reduxThunk2 = _interopRequireDefault(thunk);
	  var _reducers2 = _interopRequireDefault(reducers);
	  var Actions = _interopRequireWildcard(actions);
	  var helper$1 = _interopRequireWildcard(helper);
	  var _suggestions2 = _interopRequireDefault(suggestions);
	  var _constants3 = _interopRequireDefault(constants$1);
	  var _polyfills2 = _interopRequireDefault(polyfills);
	  var _causes2 = _interopRequireDefault(causes_1);
	  var _valueReducer2 = _interopRequireDefault(valueReducer_1);
	  var _queryReducer2 = _interopRequireDefault(queryReducer_1);
	  var _queryOptionsReducer2 = _interopRequireDefault(queryOptionsReducer_1);
	  var _dependencyTreeReducer2 = _interopRequireDefault(dependencyTreeReducer_1);
	  var _propsReducer2 = _interopRequireDefault(propsReducer);
	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};
	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }
	      newObj["default"] = obj;
	      return newObj;
	    }
	  }
	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      "default": obj
	    };
	  }
	  var storeKey = constants.STORE_KEY;
	  var suggestions$1 = _suggestions2["default"];
	  var causes = _causes2["default"];
	  var Reducers = {
	    valueReducer: _valueReducer2["default"],
	    queryOptionsReducer: _queryOptionsReducer2["default"],
	    queryReducer: _queryReducer2["default"],
	    dependencyTreeReducer: _dependencyTreeReducer2["default"],
	    propsReducer: _propsReducer2["default"]
	  };
	  exports.helper = helper$1;
	  exports.causes = causes;
	  exports.suggestions = suggestions$1;
	  exports.Actions = Actions;
	  exports.storeKey = storeKey;
	  exports.polyfills = _polyfills2["default"];
	  exports.Reducers = Reducers;
	  exports.constants = _constants3["default"];
	  var composeEnhancers = typeof window === 'object' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : redux.compose;
	  var enhancer = composeEnhancers((0, redux.applyMiddleware)(_reduxThunk2["default"]));
	  function configureStore(initialState) {
	    var finalInitialState = _extends({}, initialState, {
	      config: _extends({}, initialState.config, {
	        lock: false,
	        analyticsConfig: initialState.config && initialState.config.analyticsConfig ? _extends({}, analytics.defaultAnalyticsConfig, initialState.config.analyticsConfig) : analytics.defaultAnalyticsConfig
	      })
	    });
	    return (0, redux.createStore)(_reducers2["default"], finalInitialState, enhancer);
	  }
	});
	var configureStore = unwrapExports(lib);
	var lib_1 = lib.constants;
	var lib_2 = lib.Reducers;
	var lib_3 = lib.polyfills;
	var lib_4 = lib.storeKey;
	var lib_5 = lib.Actions;
	var lib_6 = lib.suggestions;
	var lib_7 = lib.causes;
	var lib_8 = lib.helper;

	function _regeneratorRuntime() {
	  _regeneratorRuntime = function () {
	    return exports;
	  };
	  var exports = {},
	    Op = Object.prototype,
	    hasOwn = Op.hasOwnProperty,
	    defineProperty = Object.defineProperty || function (obj, key, desc) {
	      obj[key] = desc.value;
	    },
	    $Symbol = "function" == typeof Symbol ? Symbol : {},
	    iteratorSymbol = $Symbol.iterator || "@@iterator",
	    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
	    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	  function define(obj, key, value) {
	    return Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: !0,
	      configurable: !0,
	      writable: !0
	    }), obj[key];
	  }
	  try {
	    define({}, "");
	  } catch (err) {
	    define = function (obj, key, value) {
	      return obj[key] = value;
	    };
	  }
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
	      generator = Object.create(protoGenerator.prototype),
	      context = new Context(tryLocsList || []);
	    return defineProperty(generator, "_invoke", {
	      value: makeInvokeMethod(innerFn, self, context)
	    }), generator;
	  }
	  function tryCatch(fn, obj, arg) {
	    try {
	      return {
	        type: "normal",
	        arg: fn.call(obj, arg)
	      };
	    } catch (err) {
	      return {
	        type: "throw",
	        arg: err
	      };
	    }
	  }
	  exports.wrap = wrap;
	  var ContinueSentinel = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf,
	    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      define(prototype, method, function (arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }
	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if ("throw" !== record.type) {
	        var result = record.arg,
	          value = result.value;
	        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
	          invoke("next", value, resolve, reject);
	        }, function (err) {
	          invoke("throw", err, resolve, reject);
	        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
	          result.value = unwrapped, resolve(result);
	        }, function (error) {
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	      reject(record.arg);
	    }
	    var previousPromise;
	    defineProperty(this, "_invoke", {
	      value: function (method, arg) {
	        function callInvokeWithMethodAndArg() {
	          return new PromiseImpl(function (resolve, reject) {
	            invoke(method, arg, resolve, reject);
	          });
	        }
	        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	      }
	    });
	  }
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = "suspendedStart";
	    return function (method, arg) {
	      if ("executing" === state) throw new Error("Generator is already running");
	      if ("completed" === state) {
	        if ("throw" === method) throw arg;
	        return doneResult();
	      }
	      for (context.method = method, context.arg = arg;;) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
	          if ("suspendedStart" === state) throw state = "completed", context.arg;
	          context.dispatchException(context.arg);
	        } else "return" === context.method && context.abrupt("return", context.arg);
	        state = "executing";
	        var record = tryCatch(innerFn, self, context);
	        if ("normal" === record.type) {
	          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
	          return {
	            value: record.arg,
	            done: context.done
	          };
	        }
	        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
	      }
	    };
	  }
	  function maybeInvokeDelegate(delegate, context) {
	    var methodName = context.method,
	      method = delegate.iterator[methodName];
	    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
	    var record = tryCatch(method, delegate.iterator, context.arg);
	    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
	    var info = record.arg;
	    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
	  }
	  function pushTryEntry(locs) {
	    var entry = {
	      tryLoc: locs[0]
	    };
	    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
	  }
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal", delete record.arg, entry.completion = record;
	  }
	  function Context(tryLocsList) {
	    this.tryEntries = [{
	      tryLoc: "root"
	    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
	  }
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) return iteratorMethod.call(iterable);
	      if ("function" == typeof iterable.next) return iterable;
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	          next = function next() {
	            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
	            return next.value = undefined, next.done = !0, next;
	          };
	        return next.next = next;
	      }
	    }
	    return {
	      next: doneResult
	    };
	  }
	  function doneResult() {
	    return {
	      value: undefined,
	      done: !0
	    };
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: !0
	  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: !0
	  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
	    var ctor = "function" == typeof genFun && genFun.constructor;
	    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
	  }, exports.mark = function (genFun) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
	  }, exports.awrap = function (arg) {
	    return {
	      __await: arg
	    };
	  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    void 0 === PromiseImpl && (PromiseImpl = Promise);
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
	    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
	    return this;
	  }), define(Gp, "toString", function () {
	    return "[object Generator]";
	  }), exports.keys = function (val) {
	    var object = Object(val),
	      keys = [];
	    for (var key in object) keys.push(key);
	    return keys.reverse(), function next() {
	      for (; keys.length;) {
	        var key = keys.pop();
	        if (key in object) return next.value = key, next.done = !1, next;
	      }
	      return next.done = !0, next;
	    };
	  }, exports.values = values, Context.prototype = {
	    constructor: Context,
	    reset: function (skipTempReset) {
	      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
	    },
	    stop: function () {
	      this.done = !0;
	      var rootRecord = this.tryEntries[0].completion;
	      if ("throw" === rootRecord.type) throw rootRecord.arg;
	      return this.rval;
	    },
	    dispatchException: function (exception) {
	      if (this.done) throw exception;
	      var context = this;
	      function handle(loc, caught) {
	        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
	      }
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i],
	          record = entry.completion;
	        if ("root" === entry.tryLoc) return handle("end");
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc"),
	            hasFinally = hasOwn.call(entry, "finallyLoc");
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
	            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
	          } else {
	            if (!hasFinally) throw new Error("try statement without catch or finally");
	            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
	          }
	        }
	      }
	    },
	    abrupt: function (type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
	      var record = finallyEntry ? finallyEntry.completion : {};
	      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
	    },
	    complete: function (record, afterLoc) {
	      if ("throw" === record.type) throw record.arg;
	      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
	    },
	    finish: function (finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
	      }
	    },
	    catch: function (tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if ("throw" === record.type) {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function (iterable, resultName, nextLoc) {
	      return this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
	    }
	  }, exports;
	}
	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }
	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}
	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	      args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);
	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }
	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }
	      _next(undefined);
	    });
	  };
	}
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	function _extends() {
	  _extends = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends.apply(this, arguments);
	}
	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  _setPrototypeOf(subClass, superClass);
	}
	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf(o, p);
	}
	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}
	function _taggedTemplateLiteralLoose(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }
	  strings.raw = raw;
	  return strings;
	}
	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}
	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;
	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	  return arr2;
	}
	function _createForOfIteratorHelperLoose(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
	  if (it) return (it = it.call(o)).next.bind(it);
	  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	    if (it) o = it;
	    var i = 0;
	    return function () {
	      if (i >= o.length) return {
	        done: true
	      };
	      return {
	        done: false,
	        value: o[i++]
	      };
	    };
	  }
	  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	function _toPrimitive(input, hint) {
	  if (typeof input !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (typeof res !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return typeof key === "symbol" ? key : String(key);
	}

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */

	function isObject(val) {
	  return val != null && typeof val === 'object' && Array.isArray(val) === false;
	}

	/*!
	 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */
	function isObjectObject(o) {
	  return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
	}
	function isPlainObject$1(o) {
	  var ctor, prot;
	  if (isObjectObject(o) === false) return false;

	  // If has modified constructor
	  ctor = o.constructor;
	  if (typeof ctor !== 'function') return false;

	  // If has modified prototype
	  prot = ctor.prototype;
	  if (isObjectObject(prot) === false) return false;

	  // If constructor does not have an Object-specific method
	  if (prot.hasOwnProperty('isPrototypeOf') === false) {
	    return false;
	  }

	  // Most likely a plain Object
	  return true;
	}

	var ObjProto = Object.prototype;
	var toString = ObjProto.toString;
	var hasOwn = ObjProto.hasOwnProperty;
	var FN_MATCH_REGEXP = /^\s*function (\w+)/; // https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177

	function getType(fn) {
	  var type = fn !== null && fn !== undefined ? fn.type ? fn.type : fn : null;
	  var match = type && type.toString().match(FN_MATCH_REGEXP);
	  return match && match[1];
	}
	function getNativeType(value) {
	  if (value === null || value === undefined) return null;
	  var match = value.constructor.toString().match(FN_MATCH_REGEXP);
	  return match && match[1];
	}
	/**
	 * No-op function
	 */

	function noop() {}
	/**
	 * A function that always returns true
	 */

	var stubTrue = function stubTrue() {
	  return true;
	};
	/**
	 * Checks for a own property in an object
	 *
	 * @param {object} obj - Object
	 * @param {string} prop - Property to check
	 * @returns {boolean}
	 */

	var has = function has(obj, prop) {
	  return hasOwn.call(obj, prop);
	};
	/**
	 * Determines whether the passed value is an integer. Uses `Number.isInteger` if available
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
	 * @param {*} value - The value to be tested for being an integer.
	 * @returns {boolean}
	 */

	var isInteger = Number.isInteger || function isInteger(value) {
	  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
	};
	/**
	 * Determines whether the passed value is an Array.
	 *
	 * @param {*} value - The value to be tested for being an array.
	 * @returns {boolean}
	 */

	var isArray = Array.isArray || function isArray(value) {
	  return toString.call(value) === '[object Array]';
	};
	/**
	 * Checks if a value is a function
	 *
	 * @param {any} value - Value to check
	 * @returns {boolean}
	 */

	var isFunction = function isFunction(value) {
	  return toString.call(value) === '[object Function]';
	};
	/**
	 * Adds a `def` method to the object returning a new object with passed in argument as `default` property
	 *
	 * @param {object} type - Object to enhance
	 * @returns {object} the passed-in prop type
	 */

	function withDefault(type) {
	  return Object.defineProperty(type, 'def', {
	    value: function value(def) {
	      if (def === undefined && !this["default"]) {
	        return this;
	      }
	      if (!isFunction(def) && !validateType(this, def)) {
	        warn(this._vueTypes_name + " - invalid default value: \"" + def + "\"", def);
	        return this;
	      }
	      if (isArray(def)) {
	        this["default"] = function () {
	          return [].concat(def);
	        };
	      } else if (isPlainObject$1(def)) {
	        this["default"] = function () {
	          return Object.assign({}, def);
	        };
	      } else {
	        this["default"] = def;
	      }
	      return this;
	    },
	    enumerable: false,
	    writable: false
	  });
	}
	/**
	 * Adds a `isRequired` getter returning a new object with `required: true` key-value
	 *
	 * @param {object} type - Object to enhance
	 * @returns {object} the passed-in prop type
	 */

	function withRequired(type) {
	  return Object.defineProperty(type, 'isRequired', {
	    get: function get() {
	      this.required = true;
	      return this;
	    },
	    enumerable: false
	  });
	}
	/**
	 * Adds a validate method useful to set the prop `validator` function.
	 *
	 * @param {object} type Prop type to extend
	 * @returns {object} the passed-in prop type
	 */

	function withValidate(type) {
	  return Object.defineProperty(type, 'validate', {
	    value: function value(fn) {
	      this.validator = fn.bind(this);
	      return this;
	    },
	    enumerable: false
	  });
	}
	/**
	 * Adds `isRequired` and `def` modifiers to an object
	 *
	 * @param {string} name - Type internal name
	 * @param {object} obj - Object to enhance
	 * @param {boolean} [validateFn=false] - add the `validate()` method to the type object
	 * @returns {object}
	 */

	function toType(name, obj, validateFn) {
	  if (validateFn === void 0) {
	    validateFn = false;
	  }
	  Object.defineProperty(obj, '_vueTypes_name', {
	    enumerable: false,
	    writable: false,
	    value: name
	  });
	  withDefault(withRequired(obj));
	  if (validateFn) {
	    withValidate(obj);
	  } else {
	    Object.defineProperty(obj, 'validate', {
	      value: function value() {
	        warn(name + " - \"validate\" method not supported on this type");
	        return this;
	      },
	      enumerable: false
	    });
	  }
	  if (isFunction(obj.validator)) {
	    obj.validator = obj.validator.bind(obj);
	  }
	  return obj;
	}
	/**
	 * Validates a given value against a prop type object
	 *
	 * @param {Object|*} type - Type to use for validation. Either a type object or a constructor
	 * @param {*} value - Value to check
	 * @param {boolean} silent - Silence warnings
	 * @returns {boolean}
	 */

	function validateType(type, value, silent) {
	  if (silent === void 0) {
	    silent = false;
	  }
	  var typeToCheck = type;
	  var valid = true;
	  var expectedType;
	  if (!isPlainObject$1(type)) {
	    typeToCheck = {
	      type: type
	    };
	  }
	  var namePrefix = typeToCheck._vueTypes_name ? typeToCheck._vueTypes_name + ' - ' : '';
	  if (hasOwn.call(typeToCheck, 'type') && typeToCheck.type !== null) {
	    if (typeToCheck.type === undefined) {
	      throw new TypeError("[VueTypes error]: Setting type to undefined is not allowed.");
	    }
	    if (!typeToCheck.required && value === undefined) {
	      return valid;
	    }
	    if (isArray(typeToCheck.type)) {
	      valid = typeToCheck.type.some(function (type) {
	        return validateType(type, value, true);
	      });
	      expectedType = typeToCheck.type.map(function (type) {
	        return getType(type);
	      }).join(' or ');
	    } else {
	      expectedType = getType(typeToCheck);
	      if (expectedType === 'Array') {
	        valid = isArray(value);
	      } else if (expectedType === 'Object') {
	        valid = isPlainObject$1(value);
	      } else if (expectedType === 'String' || expectedType === 'Number' || expectedType === 'Boolean' || expectedType === 'Function') {
	        valid = getNativeType(value) === expectedType;
	      } else {
	        valid = value instanceof typeToCheck.type;
	      }
	    }
	  }
	  if (!valid) {
	    silent === false && warn(namePrefix + "value \"" + value + "\" should be of type \"" + expectedType + "\"");
	    return false;
	  }
	  if (hasOwn.call(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {
	    // swallow warn
	    var oldWarn;
	    if (silent) {
	      oldWarn = warn;
	      warn = noop;
	    }
	    valid = typeToCheck.validator(value);
	    oldWarn && (warn = oldWarn);
	    if (!valid && silent === false) warn(namePrefix + "custom validation failed");
	    return valid;
	  }
	  return valid;
	}
	var warn = noop;
	{
	  var hasConsole = typeof console !== 'undefined';
	  warn = hasConsole ? function warn(msg) {
	    // eslint-disable-next-line no-console
	    Vue.config.silent === false && console.warn("[VueTypes warn]: " + msg);
	  } : noop;
	}

	var typeDefaults = function typeDefaults() {
	  return {
	    func: function func() {},
	    bool: true,
	    string: '',
	    number: 0,
	    array: function array() {
	      return [];
	    },
	    object: function object() {
	      return {};
	    },
	    integer: 0
	  };
	};
	var setDefaults = function setDefaults(root) {
	  var currentDefaults = typeDefaults();
	  return Object.defineProperty(root, 'sensibleDefaults', {
	    enumerable: false,
	    set: function set(value) {
	      if (value === false) {
	        currentDefaults = {};
	      } else if (value === true) {
	        currentDefaults = typeDefaults();
	      } else {
	        currentDefaults = value;
	      }
	    },
	    get: function get() {
	      return currentDefaults;
	    }
	  });
	};

	function _objectWithoutPropertiesLoose$1(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}
	var VueTypes = {
	  get any() {
	    return toType('any', {
	      type: null
	    }, true);
	  },
	  get func() {
	    return toType('function', {
	      type: Function
	    }, true).def(VueTypes.sensibleDefaults.func);
	  },
	  get bool() {
	    return toType('boolean', {
	      type: Boolean
	    }, true).def(VueTypes.sensibleDefaults.bool);
	  },
	  get string() {
	    return toType('string', {
	      type: String
	    }, true).def(VueTypes.sensibleDefaults.string);
	  },
	  get number() {
	    return toType('number', {
	      type: Number
	    }, true).def(VueTypes.sensibleDefaults.number);
	  },
	  get array() {
	    return toType('array', {
	      type: Array
	    }, true).def(VueTypes.sensibleDefaults.array);
	  },
	  get object() {
	    return toType('object', {
	      type: Object
	    }, true).def(VueTypes.sensibleDefaults.object);
	  },
	  get integer() {
	    return toType('integer', {
	      type: Number,
	      validator: function validator(value) {
	        return isInteger(value);
	      }
	    }).def(VueTypes.sensibleDefaults.integer);
	  },
	  get symbol() {
	    return toType('symbol', {
	      type: null,
	      validator: function validator(value) {
	        return typeof value === 'symbol';
	      }
	    }, true);
	  },
	  extend: function extend(props) {
	    if (props === void 0) {
	      props = {};
	    }
	    if (isArray(props)) {
	      props.forEach(function (p) {
	        return VueTypes.extend(p);
	      });
	      return this;
	    }
	    var _props = props,
	      name = _props.name,
	      _props$validate = _props.validate,
	      validate = _props$validate === void 0 ? false : _props$validate,
	      _props$getter = _props.getter,
	      getter = _props$getter === void 0 ? false : _props$getter,
	      opts = _objectWithoutPropertiesLoose$1(_props, ["name", "validate", "getter"]);
	    if (has(VueTypes, name)) {
	      throw new TypeError("[VueTypes error]: Type \"" + name + "\" already defined");
	    }
	    var type = opts.type,
	      _opts$validator = opts.validator,
	      validator = _opts$validator === void 0 ? stubTrue : _opts$validator;
	    if (type && type._vueTypes_name) {
	      // we are using as base type a vue-type object
	      // detach the original type
	      // we are going to inherit the parent data.
	      delete opts.type; // inherit base types, required flag and default flag if set

	      var keys = ['type', 'required', 'default'];
	      for (var i = 0; i < keys.length; i += 1) {
	        var key = keys[i];
	        if (type[key] !== undefined) {
	          opts[key] = type[key];
	        }
	      }
	      validate = false; // we don't allow validate method on this kind of types

	      if (isFunction(type.validator)) {
	        opts.validator = function () {
	          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	          return type.validator.apply(type, args) && validator.apply(this, args);
	        };
	      }
	    }
	    var descriptor;
	    if (getter) {
	      descriptor = {
	        get: function get() {
	          return toType(name, Object.assign({}, opts), validate);
	        },
	        enumerable: true,
	        configurable: false
	      };
	    } else {
	      var _validator = opts.validator;
	      descriptor = {
	        value: function value() {
	          var ret = toType(name, Object.assign({}, opts), validate);
	          if (_validator) {
	            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	              args[_key2] = arguments[_key2];
	            }
	            ret.validator = _validator.bind.apply(_validator, [ret].concat(args));
	          }
	          return ret;
	        },
	        writable: false,
	        enumerable: true,
	        configurable: false
	      };
	    }
	    return Object.defineProperty(this, name, descriptor);
	  },
	  custom: function custom(validatorFn, warnMsg) {
	    if (warnMsg === void 0) {
	      warnMsg = 'custom validation failed';
	    }
	    if (typeof validatorFn !== 'function') {
	      throw new TypeError('[VueTypes error]: You must provide a function as argument');
	    }
	    return toType(validatorFn.name || '<<anonymous function>>', {
	      validator: function validator(value) {
	        var valid = validatorFn(value);
	        if (!valid) warn(this._vueTypes_name + " - " + warnMsg);
	        return valid;
	      }
	    });
	  },
	  oneOf: function oneOf(arr) {
	    if (!isArray(arr)) {
	      throw new TypeError('[VueTypes error]: You must provide an array as argument');
	    }
	    var msg = "oneOf - value should be one of \"" + arr.join('", "') + "\"";
	    var allowedTypes = arr.reduce(function (ret, v) {
	      if (v !== null && v !== undefined) {
	        ret.indexOf(v.constructor) === -1 && ret.push(v.constructor);
	      }
	      return ret;
	    }, []);
	    return toType('oneOf', {
	      type: allowedTypes.length > 0 ? allowedTypes : null,
	      validator: function validator(value) {
	        var valid = arr.indexOf(value) !== -1;
	        if (!valid) warn(msg);
	        return valid;
	      }
	    });
	  },
	  instanceOf: function instanceOf(instanceConstructor) {
	    return toType('instanceOf', {
	      type: instanceConstructor
	    });
	  },
	  oneOfType: function oneOfType(arr) {
	    if (!isArray(arr)) {
	      throw new TypeError('[VueTypes error]: You must provide an array as argument');
	    }
	    var hasCustomValidators = false;
	    var nativeChecks = arr.reduce(function (ret, type) {
	      if (isPlainObject$1(type)) {
	        if (type._vueTypes_name === 'oneOf') {
	          return ret.concat(type.type || []);
	        }
	        if (isFunction(type.validator)) {
	          hasCustomValidators = true;
	          return ret;
	        }
	        if (type.type) {
	          if (isArray(type.type)) return ret.concat(type.type);
	          ret.push(type.type);
	        }
	        return ret;
	      }
	      ret.push(type);
	      return ret;
	    }, []);
	    if (!hasCustomValidators) {
	      // we got just native objects (ie: Array, Object)
	      // delegate to Vue native prop check
	      return toType('oneOfType', {
	        type: nativeChecks
	      });
	    }
	    var typesStr = arr.map(function (type) {
	      if (type && isArray(type.type)) {
	        return type.type.map(getType);
	      }
	      return getType(type);
	    }).reduce(function (ret, type) {
	      return ret.concat(isArray(type) ? type : [type]);
	    }, []).join('", "');
	    return this.custom(function oneOfType(value) {
	      var valid = arr.some(function (type) {
	        if (type._vueTypes_name === 'oneOf') {
	          return type.type ? validateType(type.type, value, true) : true;
	        }
	        return validateType(type, value, true);
	      });
	      if (!valid) warn("oneOfType - value type should be one of \"" + typesStr + "\"");
	      return valid;
	    });
	  },
	  arrayOf: function arrayOf(type) {
	    return toType('arrayOf', {
	      type: Array,
	      validator: function validator(values) {
	        var valid = values.every(function (value) {
	          return validateType(type, value);
	        });
	        if (!valid) warn("arrayOf - value must be an array of \"" + getType(type) + "\"");
	        return valid;
	      }
	    });
	  },
	  objectOf: function objectOf(type) {
	    return toType('objectOf', {
	      type: Object,
	      validator: function validator(obj) {
	        var valid = Object.keys(obj).every(function (key) {
	          return validateType(type, obj[key]);
	        });
	        if (!valid) warn("objectOf - value must be an object of \"" + getType(type) + "\"");
	        return valid;
	      }
	    });
	  },
	  shape: function shape(obj) {
	    var keys = Object.keys(obj);
	    var requiredKeys = keys.filter(function (key) {
	      return obj[key] && obj[key].required === true;
	    });
	    var type = toType('shape', {
	      type: Object,
	      validator: function validator(value) {
	        var _this = this;
	        if (!isPlainObject$1(value)) {
	          return false;
	        }
	        var valueKeys = Object.keys(value); // check for required keys (if any)

	        if (requiredKeys.length > 0 && requiredKeys.some(function (req) {
	          return valueKeys.indexOf(req) === -1;
	        })) {
	          warn("shape - at least one of required properties \"" + requiredKeys.join('", "') + "\" is not present");
	          return false;
	        }
	        return valueKeys.every(function (key) {
	          if (keys.indexOf(key) === -1) {
	            if (_this._vueTypes_isLoose === true) return true;
	            warn("shape - object is missing \"" + key + "\" property");
	            return false;
	          }
	          var type = obj[key];
	          return validateType(type, value[key]);
	        });
	      }
	    });
	    Object.defineProperty(type, '_vueTypes_isLoose', {
	      enumerable: false,
	      writable: true,
	      value: false
	    });
	    Object.defineProperty(type, 'loose', {
	      get: function get() {
	        this._vueTypes_isLoose = true;
	        return this;
	      },
	      enumerable: false
	    });
	    return type;
	  }
	};
	setDefaults(VueTypes);
	VueTypes.utils = {
	  validate: function validate(value, type) {
	    return validateType(type, value, true);
	  },
	  toType: toType
	};

	var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

	function memoize(fn) {
	  var cache = {};
	  return function (arg) {
	    if (cache[arg] === undefined) cache[arg] = fn(arg);
	    return cache[arg];
	  };
	}

	var unitlessKeys = {
	  animationIterationCount: 1,
	  borderImageOutset: 1,
	  borderImageSlice: 1,
	  borderImageWidth: 1,
	  boxFlex: 1,
	  boxFlexGroup: 1,
	  boxOrdinalGroup: 1,
	  columnCount: 1,
	  columns: 1,
	  flex: 1,
	  flexGrow: 1,
	  flexPositive: 1,
	  flexShrink: 1,
	  flexNegative: 1,
	  flexOrder: 1,
	  gridRow: 1,
	  gridRowEnd: 1,
	  gridRowSpan: 1,
	  gridRowStart: 1,
	  gridColumn: 1,
	  gridColumnEnd: 1,
	  gridColumnSpan: 1,
	  gridColumnStart: 1,
	  fontWeight: 1,
	  lineHeight: 1,
	  opacity: 1,
	  order: 1,
	  orphans: 1,
	  tabSize: 1,
	  widows: 1,
	  zIndex: 1,
	  zoom: 1,
	  WebkitLineClamp: 1,
	  // SVG-related properties
	  fillOpacity: 1,
	  floodOpacity: 1,
	  stopOpacity: 1,
	  strokeDasharray: 1,
	  strokeDashoffset: 1,
	  strokeMiterlimit: 1,
	  strokeOpacity: 1,
	  strokeWidth: 1
	};

	/* eslint-disable */
	// murmurhash2 via https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
	function murmurhash2_32_gc(str) {
	  var l = str.length,
	    h = l ^ l,
	    i = 0,
	    k;
	  while (l >= 4) {
	    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
	    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
	    k ^= k >>> 24;
	    k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
	    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
	    l -= 4;
	    ++i;
	  }
	  switch (l) {
	    case 3:
	      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
	    case 2:
	      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
	    case 1:
	      h ^= str.charCodeAt(i) & 0xff;
	      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
	  }
	  h ^= h >>> 13;
	  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
	  h ^= h >>> 15;
	  return (h >>> 0).toString(36);
	}

	function stylis_min(W) {
	  function M(d, c, e, h, a) {
	    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
	      g = e.charCodeAt(l);
	      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);
	      if (0 === b + n + v + m) {
	        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
	          switch (g) {
	            case 32:
	            case 9:
	            case 59:
	            case 13:
	            case 10:
	              break;
	            default:
	              f += e.charAt(l);
	          }
	          g = 59;
	        }
	        switch (g) {
	          case 123:
	            f = f.trim();
	            q = f.charCodeAt(0);
	            k = 1;
	            for (t = ++l; l < B;) {
	              switch (g = e.charCodeAt(l)) {
	                case 123:
	                  k++;
	                  break;
	                case 125:
	                  k--;
	                  break;
	                case 47:
	                  switch (g = e.charCodeAt(l + 1)) {
	                    case 42:
	                    case 47:
	                      a: {
	                        for (u = l + 1; u < J; ++u) {
	                          switch (e.charCodeAt(u)) {
	                            case 47:
	                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
	                                l = u + 1;
	                                break a;
	                              }
	                              break;
	                            case 10:
	                              if (47 === g) {
	                                l = u + 1;
	                                break a;
	                              }
	                          }
	                        }
	                        l = u;
	                      }
	                  }
	                  break;
	                case 91:
	                  g++;
	                case 40:
	                  g++;
	                case 34:
	                case 39:
	                  for (; l++ < J && e.charCodeAt(l) !== g;) {}
	              }
	              if (0 === k) break;
	              l++;
	            }
	            k = e.substring(t, l);
	            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));
	            switch (q) {
	              case 64:
	                0 < r && (f = f.replace(N, ''));
	                g = f.charCodeAt(1);
	                switch (g) {
	                  case 100:
	                  case 109:
	                  case 115:
	                  case 45:
	                    r = c;
	                    break;
	                  default:
	                    r = O;
	                }
	                k = M(c, r, k, g, a + 1);
	                t = k.length;
	                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
	                if (0 < t) switch (g) {
	                  case 115:
	                    f = f.replace(da, ea);
	                  case 100:
	                  case 109:
	                  case 45:
	                    k = f + '{' + k + '}';
	                    break;
	                  case 107:
	                    f = f.replace(fa, '$1 $2');
	                    k = f + '{' + k + '}';
	                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
	                    break;
	                  default:
	                    k = f + k, 112 === h && (k = (p += k, ''));
	                } else k = '';
	                break;
	              default:
	                k = M(c, X(c, f, I), k, h, a + 1);
	            }
	            F += k;
	            k = I = r = u = q = 0;
	            f = '';
	            g = e.charCodeAt(++l);
	            break;
	          case 125:
	          case 59:
	            f = (0 < r ? f.replace(N, '') : f).trim();
	            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
	              case 0:
	                break;
	              case 64:
	                if (105 === g || 99 === g) {
	                  G += f + e.charAt(l);
	                  break;
	                }
	              default:
	                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
	            }
	            I = r = u = q = 0;
	            f = '';
	            g = e.charCodeAt(++l);
	        }
	      }
	      switch (g) {
	        case 13:
	        case 10:
	          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
	          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
	          z = 1;
	          D++;
	          break;
	        case 59:
	        case 125:
	          if (0 === b + n + v + m) {
	            z++;
	            break;
	          }
	        default:
	          z++;
	          y = e.charAt(l);
	          switch (g) {
	            case 9:
	            case 32:
	              if (0 === n + m + b) switch (x) {
	                case 44:
	                case 58:
	                case 9:
	                case 32:
	                  y = '';
	                  break;
	                default:
	                  32 !== g && (y = ' ');
	              }
	              break;
	            case 0:
	              y = '\\0';
	              break;
	            case 12:
	              y = '\\f';
	              break;
	            case 11:
	              y = '\\v';
	              break;
	            case 38:
	              0 === n + b + m && (r = I = 1, y = '\f' + y);
	              break;
	            case 108:
	              if (0 === n + b + m + E && 0 < u) switch (l - u) {
	                case 2:
	                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);
	                case 8:
	                  111 === K && (E = K);
	              }
	              break;
	            case 58:
	              0 === n + b + m && (u = l);
	              break;
	            case 44:
	              0 === b + v + n + m && (r = 1, y += '\r');
	              break;
	            case 34:
	            case 39:
	              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
	              break;
	            case 91:
	              0 === n + b + v && m++;
	              break;
	            case 93:
	              0 === n + b + v && m--;
	              break;
	            case 41:
	              0 === n + b + m && v--;
	              break;
	            case 40:
	              if (0 === n + b + m) {
	                if (0 === q) switch (2 * x + 3 * K) {
	                  case 533:
	                    break;
	                  default:
	                    q = 1;
	                }
	                v++;
	              }
	              break;
	            case 64:
	              0 === b + v + n + m + u + k && (k = 1);
	              break;
	            case 42:
	            case 47:
	              if (!(0 < n + m + v)) switch (b) {
	                case 0:
	                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
	                    case 235:
	                      b = 47;
	                      break;
	                    case 220:
	                      t = l, b = 42;
	                  }
	                  break;
	                case 42:
	                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
	              }
	          }
	          0 === b && (f += y);
	      }
	      K = x;
	      x = g;
	      l++;
	    }
	    t = p.length;
	    if (0 < t) {
	      r = c;
	      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
	      p = r.join(',') + '{' + p + '}';
	      if (0 !== w * E) {
	        2 !== w || L(p, 2) || (E = 0);
	        switch (E) {
	          case 111:
	            p = p.replace(ha, ':-moz-$1') + p;
	            break;
	          case 112:
	            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
	        }
	        E = 0;
	      }
	    }
	    return G + p + F;
	  }
	  function X(d, c, e) {
	    var h = c.trim().split(ia);
	    c = h;
	    var a = h.length,
	      m = d.length;
	    switch (m) {
	      case 0:
	      case 1:
	        var b = 0;
	        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
	          c[b] = Z(d, c[b], e).trim();
	        }
	        break;
	      default:
	        var v = b = 0;
	        for (c = []; b < a; ++b) {
	          for (var n = 0; n < m; ++n) {
	            c[v++] = Z(d[n] + ' ', h[b], e).trim();
	          }
	        }
	    }
	    return c;
	  }
	  function Z(d, c, e) {
	    var h = c.charCodeAt(0);
	    33 > h && (h = (c = c.trim()).charCodeAt(0));
	    switch (h) {
	      case 38:
	        return c.replace(F, '$1' + d.trim());
	      case 58:
	        return d.trim() + c.replace(F, '$1' + d.trim());
	      default:
	        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
	    }
	    return d + c;
	  }
	  function P(d, c, e, h) {
	    var a = d + ';',
	      m = 2 * c + 3 * e + 4 * h;
	    if (944 === m) {
	      d = a.indexOf(':', 9) + 1;
	      var b = a.substring(d, a.length - 1).trim();
	      b = a.substring(0, d).trim() + b + ';';
	      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
	    }
	    if (0 === w || 2 === w && !L(a, 1)) return a;
	    switch (m) {
	      case 1015:
	        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;
	      case 951:
	        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;
	      case 963:
	        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;
	      case 1009:
	        if (100 !== a.charCodeAt(4)) break;
	      case 969:
	      case 942:
	        return '-webkit-' + a + a;
	      case 978:
	        return '-webkit-' + a + '-moz-' + a + a;
	      case 1019:
	      case 983:
	        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;
	      case 883:
	        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
	        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
	        break;
	      case 932:
	        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
	          case 103:
	            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;
	          case 115:
	            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;
	          case 98:
	            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
	        }
	        return '-webkit-' + a + '-ms-' + a + a;
	      case 964:
	        return '-webkit-' + a + '-ms-flex-' + a + a;
	      case 1023:
	        if (99 !== a.charCodeAt(8)) break;
	        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
	        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;
	      case 1005:
	        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;
	      case 1e3:
	        b = a.substring(13).trim();
	        c = b.indexOf('-') + 1;
	        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
	          case 226:
	            b = a.replace(G, 'tb');
	            break;
	          case 232:
	            b = a.replace(G, 'tb-rl');
	            break;
	          case 220:
	            b = a.replace(G, 'lr');
	            break;
	          default:
	            return a;
	        }
	        return '-webkit-' + a + '-ms-' + b + a;
	      case 1017:
	        if (-1 === a.indexOf('sticky', 9)) break;
	      case 975:
	        c = (a = d).length - 10;
	        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();
	        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
	          case 203:
	            if (111 > b.charCodeAt(8)) break;
	          case 115:
	            a = a.replace(b, '-webkit-' + b) + ';' + a;
	            break;
	          case 207:
	          case 102:
	            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
	        }
	        return a + ';';
	      case 938:
	        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
	          case 105:
	            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;
	          case 115:
	            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;
	          default:
	            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
	        }
	        break;
	      case 973:
	      case 989:
	        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;
	      case 931:
	      case 953:
	        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
	        break;
	      case 962:
	        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
	    }
	    return a;
	  }
	  function L(d, c) {
	    var e = d.indexOf(1 === c ? ':' : '{'),
	      h = d.substring(0, 3 !== c ? e : 10);
	    e = d.substring(e + 1, d.length - 1);
	    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
	  }
	  function ea(d, c) {
	    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
	    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
	  }
	  function H(d, c, e, h, a, m, b, v, n, q) {
	    for (var g = 0, x = c, w; g < A; ++g) {
	      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
	        case void 0:
	        case !1:
	        case !0:
	        case null:
	          break;
	        default:
	          x = w;
	      }
	    }
	    if (x !== c) return x;
	  }
	  function T(d) {
	    switch (d) {
	      case void 0:
	      case null:
	        A = S.length = 0;
	        break;
	      default:
	        switch (d.constructor) {
	          case Array:
	            for (var c = 0, e = d.length; c < e; ++c) {
	              T(d[c]);
	            }
	            break;
	          case Function:
	            S[A++] = d;
	            break;
	          case Boolean:
	            Y = !!d | 0;
	        }
	    }
	    return T;
	  }
	  function U(d) {
	    d = d.prefix;
	    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
	    return U;
	  }
	  function B(d, c) {
	    var e = d;
	    33 > e.charCodeAt(0) && (e = e.trim());
	    V = e;
	    e = [V];
	    if (0 < A) {
	      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
	      void 0 !== h && 'string' === typeof h && (c = h);
	    }
	    var a = M(O, e, c, 0, 0);
	    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
	    V = '';
	    E = 0;
	    z = D = 1;
	    return a;
	  }
	  var ca = /^\0+/g,
	    N = /[\0\r\f]/g,
	    aa = /: */g,
	    ka = /zoo|gra/,
	    ma = /([,: ])(transform)/g,
	    ia = /,\r+?/g,
	    F = /([\t\r\n ])*\f?&/g,
	    fa = /@(k\w+)\s*(\S*)\s*/,
	    Q = /::(place)/g,
	    ha = /:(read-only)/g,
	    G = /[svh]\w+-[tblr]{2}/,
	    da = /\(\s*(.*)\s*\)/g,
	    oa = /([\s\S]*?);/g,
	    ba = /-self|flex-/g,
	    na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
	    la = /stretch|:\s*\w+\-(?:conte|avail)/,
	    ja = /([^-])(image-set\()/,
	    z = 1,
	    D = 1,
	    E = 0,
	    w = 1,
	    O = [],
	    S = [],
	    A = 0,
	    R = null,
	    Y = 0,
	    V = '';
	  B.use = T;
	  B.set = U;
	  void 0 !== W && U(W);
	  return B;
	}

	var stylisRuleSheet = createCommonjsModule(function (module, exports) {
	  (function (factory) {
	     module['exports'] = factory() ;
	  })(function () {

	    return function (insertRule) {
	      var delimiter = '/*|*/';
	      var needle = delimiter + '}';
	      function toSheet(block) {
	        if (block) try {
	          insertRule(block + '}');
	        } catch (e) {}
	      }
	      return function ruleSheet(context, content, selectors, parents, line, column, length, ns, depth, at) {
	        switch (context) {
	          // property
	          case 1:
	            // @import
	            if (depth === 0 && content.charCodeAt(0) === 64) return insertRule(content + ';'), '';
	            break;
	          // selector
	          case 2:
	            if (ns === 0) return content + delimiter;
	            break;
	          // at-rule
	          case 3:
	            switch (ns) {
	              // @font-face, @page
	              case 102:
	              case 112:
	                return insertRule(selectors[0] + content), '';
	              default:
	                return content + (at === 0 ? delimiter : '');
	            }
	          case -2:
	            content.split(needle).forEach(toSheet);
	        }
	      };
	    };
	  });
	});

	var hyphenateRegex = /[A-Z]|^ms/g;
	var processStyleName = memoize(function (styleName) {
	  return styleName.replace(hyphenateRegex, '-$&').toLowerCase();
	});
	var processStyleValue = function processStyleValue(key, value) {
	  if (value == null || typeof value === 'boolean') {
	    return '';
	  }
	  if (unitlessKeys[key] !== 1 && key.charCodeAt(1) !== 45 &&
	  // custom properties
	  !isNaN(value) && value !== 0) {
	    return value + 'px';
	  }
	  return value;
	};
	{
	  var contentValuePattern = /(attr|calc|counters?|url)\(/;
	  var contentValues = ['normal', 'none', 'counter', 'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote', 'initial', 'inherit', 'unset'];
	  var oldProcessStyleValue = processStyleValue;
	  processStyleValue = function processStyleValue(key, value) {
	    if (key === 'content') {
	      if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
	        console.error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
	      }
	    }
	    return oldProcessStyleValue(key, value);
	  };
	}
	var classnames = function classnames(args) {
	  var len = args.length;
	  var i = 0;
	  var cls = '';
	  for (; i < len; i++) {
	    var arg = args[i];
	    if (arg == null) continue;
	    var toAdd = void 0;
	    switch (typeof arg) {
	      case 'boolean':
	        break;
	      case 'function':
	        {
	          console.error('Passing functions to cx is deprecated and will be removed in the next major version of Emotion.\n' + 'Please call the function before passing it to cx.');
	        }
	        toAdd = classnames([arg()]);
	        break;
	      case 'object':
	        {
	          if (Array.isArray(arg)) {
	            toAdd = classnames(arg);
	          } else {
	            toAdd = '';
	            for (var k in arg) {
	              if (arg[k] && k) {
	                toAdd && (toAdd += ' ');
	                toAdd += k;
	              }
	            }
	          }
	          break;
	        }
	      default:
	        {
	          toAdd = arg;
	        }
	    }
	    if (toAdd) {
	      cls && (cls += ' ');
	      cls += toAdd;
	    }
	  }
	  return cls;
	};
	var isBrowser = typeof document !== 'undefined';

	/*

	high performance StyleSheet for css-in-js systems

	- uses multiple style tags behind the scenes for millions of rules
	- uses `insertRule` for appending in production for *much* faster performance
	- 'polyfills' on server side

	// usage

	import StyleSheet from 'glamor/lib/sheet'
	let styleSheet = new StyleSheet()

	styleSheet.inject()
	- 'injects' the stylesheet into the page (or into memory if on server)

	styleSheet.insert('#box { border: 1px solid red; }')
	- appends a css rule into the stylesheet

	styleSheet.flush()
	- empties the stylesheet of all its contents

	*/
	// $FlowFixMe
	function sheetForTag(tag) {
	  if (tag.sheet) {
	    // $FlowFixMe
	    return tag.sheet;
	  } // this weirdness brought to you by firefox

	  for (var i = 0; i < document.styleSheets.length; i++) {
	    if (document.styleSheets[i].ownerNode === tag) {
	      // $FlowFixMe
	      return document.styleSheets[i];
	    }
	  }
	}
	function makeStyleTag(opts) {
	  var tag = document.createElement('style');
	  tag.setAttribute('data-emotion', opts.key || '');
	  if (opts.nonce !== undefined) {
	    tag.setAttribute('nonce', opts.nonce);
	  }
	  tag.appendChild(document.createTextNode('')) // $FlowFixMe
	  ;

	  (opts.container !== undefined ? opts.container : document.head).appendChild(tag);
	  return tag;
	}
	var StyleSheet = /*#__PURE__*/
	function () {
	  function StyleSheet(options) {
	    this.isSpeedy = "development" === 'production'; // the big drawback here is that the css won't be editable in devtools

	    this.tags = [];
	    this.ctr = 0;
	    this.opts = options;
	  }
	  var _proto = StyleSheet.prototype;
	  _proto.inject = function inject() {
	    if (this.injected) {
	      throw new Error('already injected!');
	    }
	    this.tags[0] = makeStyleTag(this.opts);
	    this.injected = true;
	  };
	  _proto.speedy = function speedy(bool) {
	    if (this.ctr !== 0) {
	      // cannot change speedy mode after inserting any rule to sheet. Either call speedy(${bool}) earlier in your app, or call flush() before speedy(${bool})
	      throw new Error("cannot change speedy now");
	    }
	    this.isSpeedy = !!bool;
	  };
	  _proto.insert = function insert(rule, sourceMap) {
	    // this is the ultrafast version, works across browsers
	    if (this.isSpeedy) {
	      var tag = this.tags[this.tags.length - 1];
	      var sheet = sheetForTag(tag);
	      try {
	        sheet.insertRule(rule, sheet.cssRules.length);
	      } catch (e) {
	        {
	          console.warn('illegal rule', rule); // eslint-disable-line no-console
	        }
	      }
	    } else {
	      var _tag = makeStyleTag(this.opts);
	      this.tags.push(_tag);
	      _tag.appendChild(document.createTextNode(rule + (sourceMap || '')));
	    }
	    this.ctr++;
	    if (this.ctr % 65000 === 0) {
	      this.tags.push(makeStyleTag(this.opts));
	    }
	  };
	  _proto.flush = function flush() {
	    // $FlowFixMe
	    this.tags.forEach(function (tag) {
	      return tag.parentNode.removeChild(tag);
	    });
	    this.tags = [];
	    this.ctr = 0; // todo - look for remnants in document.styleSheets

	    this.injected = false;
	  };
	  return StyleSheet;
	}();
	function createEmotion(context, options) {
	  if (context.__SECRET_EMOTION__ !== undefined) {
	    return context.__SECRET_EMOTION__;
	  }
	  if (options === undefined) options = {};
	  var key = options.key || 'css';
	  {
	    if (/[^a-z-]/.test(key)) {
	      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
	    }
	  }
	  var current;
	  function insertRule(rule) {
	    current += rule;
	    if (isBrowser) {
	      sheet.insert(rule, currentSourceMap);
	    }
	  }
	  var insertionPlugin = stylisRuleSheet(insertRule);
	  var stylisOptions;
	  if (options.prefix !== undefined) {
	    stylisOptions = {
	      prefix: options.prefix
	    };
	  }
	  var caches = {
	    registered: {},
	    inserted: {},
	    nonce: options.nonce,
	    key: key
	  };
	  var sheet = new StyleSheet(options);
	  if (isBrowser) {
	    // 🚀
	    sheet.inject();
	  }
	  var stylis = new stylis_min(stylisOptions);
	  stylis.use(options.stylisPlugins)(insertionPlugin);
	  var currentSourceMap = '';
	  function handleInterpolation(interpolation, couldBeSelectorInterpolation) {
	    if (interpolation == null) {
	      return '';
	    }
	    switch (typeof interpolation) {
	      case 'boolean':
	        return '';
	      case 'function':
	        if (interpolation.__emotion_styles !== undefined) {
	          var selector = interpolation.toString();
	          if (selector === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
	            throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
	          }
	          return selector;
	        }
	        if (this === undefined && "development" !== 'production') {
	          console.error('Interpolating functions in css calls is deprecated and will be removed in the next major version of Emotion.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
	        }
	        return handleInterpolation.call(this, this === undefined ? interpolation() :
	        // $FlowFixMe
	        interpolation(this.mergedProps, this.context), couldBeSelectorInterpolation);
	      case 'object':
	        return createStringFromObject.call(this, interpolation);
	      default:
	        var cached = caches.registered[interpolation];
	        return couldBeSelectorInterpolation === false && cached !== undefined ? cached : interpolation;
	    }
	  }
	  var objectToStringCache = new WeakMap();
	  function createStringFromObject(obj) {
	    if (objectToStringCache.has(obj)) {
	      // $FlowFixMe
	      return objectToStringCache.get(obj);
	    }
	    var string = '';
	    if (Array.isArray(obj)) {
	      obj.forEach(function (interpolation) {
	        string += handleInterpolation.call(this, interpolation, false);
	      }, this);
	    } else {
	      Object.keys(obj).forEach(function (key) {
	        if (typeof obj[key] !== 'object') {
	          if (caches.registered[obj[key]] !== undefined) {
	            string += key + "{" + caches.registered[obj[key]] + "}";
	          } else {
	            string += processStyleName(key) + ":" + processStyleValue(key, obj[key]) + ";";
	          }
	        } else {
	          if (key === 'NO_COMPONENT_SELECTOR' && "development" !== 'production') {
	            throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
	          }
	          if (Array.isArray(obj[key]) && typeof obj[key][0] === 'string' && caches.registered[obj[key][0]] === undefined) {
	            obj[key].forEach(function (value) {
	              string += processStyleName(key) + ":" + processStyleValue(key, value) + ";";
	            });
	          } else {
	            string += key + "{" + handleInterpolation.call(this, obj[key], false) + "}";
	          }
	        }
	      }, this);
	    }
	    objectToStringCache.set(obj, string);
	    return string;
	  }
	  var name;
	  var stylesWithLabel;
	  var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
	  var createClassName = function createClassName(styles, identifierName) {
	    return murmurhash2_32_gc(styles + identifierName) + identifierName;
	  };
	  {
	    var oldCreateClassName = createClassName;
	    var sourceMappingUrlPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
	    createClassName = function createClassName(styles, identifierName) {
	      return oldCreateClassName(styles.replace(sourceMappingUrlPattern, function (sourceMap) {
	        currentSourceMap = sourceMap;
	        return '';
	      }), identifierName);
	    };
	  }
	  var createStyles = function createStyles(strings) {
	    var stringMode = true;
	    var styles = '';
	    var identifierName = '';
	    if (strings == null || strings.raw === undefined) {
	      stringMode = false;
	      styles += handleInterpolation.call(this, strings, false);
	    } else {
	      styles += strings[0];
	    }
	    for (var _len = arguments.length, interpolations = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      interpolations[_key - 1] = arguments[_key];
	    }
	    interpolations.forEach(function (interpolation, i) {
	      styles += handleInterpolation.call(this, interpolation, styles.charCodeAt(styles.length - 1) === 46 // .
	      );

	      if (stringMode === true && strings[i + 1] !== undefined) {
	        styles += strings[i + 1];
	      }
	    }, this);
	    stylesWithLabel = styles;
	    styles = styles.replace(labelPattern, function (match, p1) {
	      identifierName += "-" + p1;
	      return '';
	    });
	    name = createClassName(styles, identifierName);
	    return styles;
	  };
	  {
	    var oldStylis = stylis;
	    stylis = function stylis(selector, styles) {
	      oldStylis(selector, styles);
	      currentSourceMap = '';
	    };
	  }
	  function insert(scope, styles) {
	    if (caches.inserted[name] === undefined) {
	      current = '';
	      stylis(scope, styles);
	      caches.inserted[name] = current;
	    }
	  }
	  var css = function css() {
	    var styles = createStyles.apply(this, arguments);
	    var selector = key + "-" + name;
	    if (caches.registered[selector] === undefined) {
	      caches.registered[selector] = stylesWithLabel;
	    }
	    insert("." + selector, styles);
	    return selector;
	  };
	  var keyframes = function keyframes() {
	    var styles = createStyles.apply(this, arguments);
	    var animation = "animation-" + name;
	    insert('', "@keyframes " + animation + "{" + styles + "}");
	    return animation;
	  };
	  var injectGlobal = function injectGlobal() {
	    var styles = createStyles.apply(this, arguments);
	    insert('', styles);
	  };
	  function getRegisteredStyles(registeredStyles, classNames) {
	    var rawClassName = '';
	    classNames.split(' ').forEach(function (className) {
	      if (caches.registered[className] !== undefined) {
	        registeredStyles.push(className);
	      } else {
	        rawClassName += className + " ";
	      }
	    });
	    return rawClassName;
	  }
	  function merge(className, sourceMap) {
	    var registeredStyles = [];
	    var rawClassName = getRegisteredStyles(registeredStyles, className);
	    if (registeredStyles.length < 2) {
	      return className;
	    }
	    return rawClassName + css(registeredStyles, sourceMap);
	  }
	  function cx() {
	    for (var _len2 = arguments.length, classNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      classNames[_key2] = arguments[_key2];
	    }
	    return merge(classnames(classNames));
	  }
	  function hydrateSingleId(id) {
	    caches.inserted[id] = true;
	  }
	  function hydrate(ids) {
	    ids.forEach(hydrateSingleId);
	  }
	  function flush() {
	    if (isBrowser) {
	      sheet.flush();
	      sheet.inject();
	    }
	    caches.inserted = {};
	    caches.registered = {};
	  }
	  if (isBrowser) {
	    var chunks = document.querySelectorAll("[data-emotion-" + key + "]");
	    Array.prototype.forEach.call(chunks, function (node) {
	      // $FlowFixMe
	      sheet.tags[0].parentNode.insertBefore(node, sheet.tags[0]); // $FlowFixMe

	      node.getAttribute("data-emotion-" + key).split(' ').forEach(hydrateSingleId);
	    });
	  }
	  var emotion = {
	    flush: flush,
	    hydrate: hydrate,
	    cx: cx,
	    merge: merge,
	    getRegisteredStyles: getRegisteredStyles,
	    injectGlobal: injectGlobal,
	    keyframes: keyframes,
	    css: css,
	    sheet: sheet,
	    caches: caches
	  };
	  context.__SECRET_EMOTION__ = emotion;
	  return emotion;
	}

	var context = typeof global$1 !== 'undefined' ? global$1 : {};
	var _createEmotion = createEmotion(context),
	  flush = _createEmotion.flush,
	  hydrate = _createEmotion.hydrate,
	  cx = _createEmotion.cx,
	  merge = _createEmotion.merge,
	  getRegisteredStyles = _createEmotion.getRegisteredStyles,
	  injectGlobal = _createEmotion.injectGlobal,
	  keyframes = _createEmotion.keyframes,
	  css = _createEmotion.css,
	  sheet = _createEmotion.sheet,
	  caches = _createEmotion.caches;

	/*!
	 * nano-assign v1.0.1
	 * (c) 2018-present egoist <0x142857@gmail.com>
	 * Released under the MIT License.
	 */

	var index = function index(obj) {
	  var arguments$1 = arguments;
	  for (var i = 1; i < arguments.length; i++) {
	    // eslint-disable-next-line guard-for-in, prefer-rest-params
	    for (var p in arguments[i]) {
	      obj[p] = arguments$1[i][p];
	    }
	  }
	  return obj;
	};
	var nanoAssign_common = index;

	/* eslint-disable */
	var STYLES_KEY = '__emotion_styles';

	function _typeof(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }
	  return _typeof(obj);
	}
	function stringifyClass(klass) {
	  if (Array.isArray(klass)) {
	    return klass.join(' ');
	  }
	  if (_typeof(klass) === 'object') {
	    return Object.keys(klass).filter(function (key) {
	      return Boolean(klass[key]);
	    }).join(' ');
	  }
	  return klass;
	}
	var index$1 = function index(tag, options) {
	  var staticClassName;
	  var identifierName;
	  var stableClassName;
	  var propsDefinitions;
	  if (options !== undefined) {
	    staticClassName = options.e;
	    identifierName = options.label;
	    stableClassName = options.target;
	    propsDefinitions = options.props;
	  }
	  var isReal = tag.__emotion_real === tag;
	  var baseTag = staticClassName === undefined ? isReal && tag.__emotion_base || tag : tag;
	  return function () {
	    var styles = isReal && tag[STYLES_KEY] !== undefined ? tag[STYLES_KEY].slice(0) : [];
	    if (identifierName !== undefined) {
	      styles.push("label:".concat(identifierName, ";"));
	    }
	    if (staticClassName === undefined) {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      if (args[0] === null || args[0].raw === undefined) {
	        styles.push.apply(styles, args);
	      } else {
	        styles.push(args[0][0]);
	        var len = args.length;
	        var i = 1;
	        for (; i < len; i++) {
	          styles.push(args[i], args[0][i]);
	        }
	      }
	    }
	    var Styled = {
	      name: "Styled".concat(tag.name || identifierName || 'Component'),
	      functional: true,
	      inject: {
	        theme: {
	          from: 'theme_reactivesearch',
	          "default": null
	        }
	      },
	      props: propsDefinitions,
	      render: function render(h, _ref) {
	        var data = _ref.data,
	          children = _ref.children,
	          props = _ref.props,
	          injections = _ref.injections;
	        var className = '';
	        var classInterpolations = [];
	        var exisingClassName = stringifyClass(data["class"]);
	        var attrs = {};
	        for (var key in data.attrs) {
	          if (key[0] !== '$') {
	            attrs[key] = data.attrs[key];
	          }
	        }
	        if (exisingClassName) {
	          if (staticClassName === undefined) {
	            className += getRegisteredStyles(classInterpolations, exisingClassName);
	          } else {
	            className += "".concat(exisingClassName, " ");
	          }
	        }
	        if (staticClassName === undefined) {
	          var ctx = {
	            mergedProps: nanoAssign_common({
	              theme: injections.theme
	            }, props)
	          };
	          className += css.apply(ctx, styles.concat(classInterpolations));
	        } else {
	          className += staticClassName;
	        }
	        if (stableClassName !== undefined) {
	          className += " ".concat(stableClassName);
	        }
	        return h(tag, nanoAssign_common({}, data, {
	          attrs: attrs,
	          "class": className
	        }), children);
	      }
	    };
	    Styled[STYLES_KEY] = styles;
	    Styled.__emotion_base = baseTag;
	    Styled.__emotion_real = Styled;
	    Object.defineProperty(Styled, 'toString', {
	      enumerable: false,
	      value: function value() {
	        if ( stableClassName === undefined) {
	          return 'NO_COMPONENT_SELECTOR';
	        }
	        return ".".concat(stableClassName);
	      }
	    });
	    return Styled;
	  };
	};

	function _extends$1() {
	  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends$1.apply(this, arguments);
	}

	function colorToInt(color) {
	  return Math.round(color * 255);
	}
	function convertToInt(red, green, blue) {
	  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
	}
	function hslToRgb(hue, saturation, lightness, convert) {
	  if (convert === void 0) {
	    convert = convertToInt;
	  }
	  if (saturation === 0) {
	    // achromatic
	    return convert(lightness, lightness, lightness);
	  } // formular from https://en.wikipedia.org/wiki/HSL_and_HSV

	  var huePrime = hue % 360 / 60;
	  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
	  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
	  var red = 0;
	  var green = 0;
	  var blue = 0;
	  if (huePrime >= 0 && huePrime < 1) {
	    red = chroma;
	    green = secondComponent;
	  } else if (huePrime >= 1 && huePrime < 2) {
	    red = secondComponent;
	    green = chroma;
	  } else if (huePrime >= 2 && huePrime < 3) {
	    green = chroma;
	    blue = secondComponent;
	  } else if (huePrime >= 3 && huePrime < 4) {
	    green = secondComponent;
	    blue = chroma;
	  } else if (huePrime >= 4 && huePrime < 5) {
	    red = secondComponent;
	    blue = chroma;
	  } else if (huePrime >= 5 && huePrime < 6) {
	    red = chroma;
	    blue = secondComponent;
	  }
	  var lightnessModification = lightness - chroma / 2;
	  var finalRed = red + lightnessModification;
	  var finalGreen = green + lightnessModification;
	  var finalBlue = blue + lightnessModification;
	  return convert(finalRed, finalGreen, finalBlue);
	}
	var namedColorMap = {
	  aliceblue: 'f0f8ff',
	  antiquewhite: 'faebd7',
	  aqua: '00ffff',
	  aquamarine: '7fffd4',
	  azure: 'f0ffff',
	  beige: 'f5f5dc',
	  bisque: 'ffe4c4',
	  black: '000',
	  blanchedalmond: 'ffebcd',
	  blue: '0000ff',
	  blueviolet: '8a2be2',
	  brown: 'a52a2a',
	  burlywood: 'deb887',
	  cadetblue: '5f9ea0',
	  chartreuse: '7fff00',
	  chocolate: 'd2691e',
	  coral: 'ff7f50',
	  cornflowerblue: '6495ed',
	  cornsilk: 'fff8dc',
	  crimson: 'dc143c',
	  cyan: '00ffff',
	  darkblue: '00008b',
	  darkcyan: '008b8b',
	  darkgoldenrod: 'b8860b',
	  darkgray: 'a9a9a9',
	  darkgreen: '006400',
	  darkgrey: 'a9a9a9',
	  darkkhaki: 'bdb76b',
	  darkmagenta: '8b008b',
	  darkolivegreen: '556b2f',
	  darkorange: 'ff8c00',
	  darkorchid: '9932cc',
	  darkred: '8b0000',
	  darksalmon: 'e9967a',
	  darkseagreen: '8fbc8f',
	  darkslateblue: '483d8b',
	  darkslategray: '2f4f4f',
	  darkslategrey: '2f4f4f',
	  darkturquoise: '00ced1',
	  darkviolet: '9400d3',
	  deeppink: 'ff1493',
	  deepskyblue: '00bfff',
	  dimgray: '696969',
	  dimgrey: '696969',
	  dodgerblue: '1e90ff',
	  firebrick: 'b22222',
	  floralwhite: 'fffaf0',
	  forestgreen: '228b22',
	  fuchsia: 'ff00ff',
	  gainsboro: 'dcdcdc',
	  ghostwhite: 'f8f8ff',
	  gold: 'ffd700',
	  goldenrod: 'daa520',
	  gray: '808080',
	  green: '008000',
	  greenyellow: 'adff2f',
	  grey: '808080',
	  honeydew: 'f0fff0',
	  hotpink: 'ff69b4',
	  indianred: 'cd5c5c',
	  indigo: '4b0082',
	  ivory: 'fffff0',
	  khaki: 'f0e68c',
	  lavender: 'e6e6fa',
	  lavenderblush: 'fff0f5',
	  lawngreen: '7cfc00',
	  lemonchiffon: 'fffacd',
	  lightblue: 'add8e6',
	  lightcoral: 'f08080',
	  lightcyan: 'e0ffff',
	  lightgoldenrodyellow: 'fafad2',
	  lightgray: 'd3d3d3',
	  lightgreen: '90ee90',
	  lightgrey: 'd3d3d3',
	  lightpink: 'ffb6c1',
	  lightsalmon: 'ffa07a',
	  lightseagreen: '20b2aa',
	  lightskyblue: '87cefa',
	  lightslategray: '789',
	  lightslategrey: '789',
	  lightsteelblue: 'b0c4de',
	  lightyellow: 'ffffe0',
	  lime: '0f0',
	  limegreen: '32cd32',
	  linen: 'faf0e6',
	  magenta: 'f0f',
	  maroon: '800000',
	  mediumaquamarine: '66cdaa',
	  mediumblue: '0000cd',
	  mediumorchid: 'ba55d3',
	  mediumpurple: '9370db',
	  mediumseagreen: '3cb371',
	  mediumslateblue: '7b68ee',
	  mediumspringgreen: '00fa9a',
	  mediumturquoise: '48d1cc',
	  mediumvioletred: 'c71585',
	  midnightblue: '191970',
	  mintcream: 'f5fffa',
	  mistyrose: 'ffe4e1',
	  moccasin: 'ffe4b5',
	  navajowhite: 'ffdead',
	  navy: '000080',
	  oldlace: 'fdf5e6',
	  olive: '808000',
	  olivedrab: '6b8e23',
	  orange: 'ffa500',
	  orangered: 'ff4500',
	  orchid: 'da70d6',
	  palegoldenrod: 'eee8aa',
	  palegreen: '98fb98',
	  paleturquoise: 'afeeee',
	  palevioletred: 'db7093',
	  papayawhip: 'ffefd5',
	  peachpuff: 'ffdab9',
	  peru: 'cd853f',
	  pink: 'ffc0cb',
	  plum: 'dda0dd',
	  powderblue: 'b0e0e6',
	  purple: '800080',
	  rebeccapurple: '639',
	  red: 'f00',
	  rosybrown: 'bc8f8f',
	  royalblue: '4169e1',
	  saddlebrown: '8b4513',
	  salmon: 'fa8072',
	  sandybrown: 'f4a460',
	  seagreen: '2e8b57',
	  seashell: 'fff5ee',
	  sienna: 'a0522d',
	  silver: 'c0c0c0',
	  skyblue: '87ceeb',
	  slateblue: '6a5acd',
	  slategray: '708090',
	  slategrey: '708090',
	  snow: 'fffafa',
	  springgreen: '00ff7f',
	  steelblue: '4682b4',
	  tan: 'd2b48c',
	  teal: '008080',
	  thistle: 'd8bfd8',
	  tomato: 'ff6347',
	  turquoise: '40e0d0',
	  violet: 'ee82ee',
	  wheat: 'f5deb3',
	  white: 'fff',
	  whitesmoke: 'f5f5f5',
	  yellow: 'ff0',
	  yellowgreen: '9acd32'
	  /**
	   * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
	   * @private
	   */
	};

	function nameToHex(color) {
	  if (typeof color !== 'string') return color;
	  var normalizedColorName = color.toLowerCase();
	  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
	}
	var hexRegex = /^#[a-fA-F0-9]{6}$/;
	var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
	var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
	var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
	var rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
	var rgbaRegex = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/;
	var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*\)$/;
	var hslaRegex = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/;
	/**
	 * Returns an RgbColor or RgbaColor object. This utility function is only useful
	 * if want to extract a color component. With the color util `toColorString` you
	 * can convert a RgbColor or RgbaColor object back to a string.
	 *
	 * @example
	 * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
	 * const color1 = parseToRgb('rgb(255, 0, 0)');
	 * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
	 * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
	 */

	function parseToRgb(color) {
	  if (typeof color !== 'string') {
	    throw new Error('Passed an incorrect argument to a color function, please pass a string representation of a color.');
	  }
	  var normalizedColor = nameToHex(color);
	  if (normalizedColor.match(hexRegex)) {
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
	      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
	      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
	    };
	  }
	  if (normalizedColor.match(hexRgbaRegex)) {
	    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
	      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
	      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
	      alpha: alpha
	    };
	  }
	  if (normalizedColor.match(reducedHexRegex)) {
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
	      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
	      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
	    };
	  }
	  if (normalizedColor.match(reducedRgbaHexRegex)) {
	    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));
	    return {
	      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
	      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
	      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
	      alpha: _alpha
	    };
	  }
	  var rgbMatched = rgbRegex.exec(normalizedColor);
	  if (rgbMatched) {
	    return {
	      red: parseInt("" + rgbMatched[1], 10),
	      green: parseInt("" + rgbMatched[2], 10),
	      blue: parseInt("" + rgbMatched[3], 10)
	    };
	  }
	  var rgbaMatched = rgbaRegex.exec(normalizedColor);
	  if (rgbaMatched) {
	    return {
	      red: parseInt("" + rgbaMatched[1], 10),
	      green: parseInt("" + rgbaMatched[2], 10),
	      blue: parseInt("" + rgbaMatched[3], 10),
	      alpha: parseFloat("" + rgbaMatched[4])
	    };
	  }
	  var hslMatched = hslRegex.exec(normalizedColor);
	  if (hslMatched) {
	    var hue = parseInt("" + hslMatched[1], 10);
	    var saturation = parseInt("" + hslMatched[2], 10) / 100;
	    var lightness = parseInt("" + hslMatched[3], 10) / 100;
	    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
	    var hslRgbMatched = rgbRegex.exec(rgbColorString);
	    if (!hslRgbMatched) {
	      throw new Error("Couldn't generate valid rgb string from " + normalizedColor + ", it returned " + rgbColorString + ".");
	    }
	    return {
	      red: parseInt("" + hslRgbMatched[1], 10),
	      green: parseInt("" + hslRgbMatched[2], 10),
	      blue: parseInt("" + hslRgbMatched[3], 10)
	    };
	  }
	  var hslaMatched = hslaRegex.exec(normalizedColor);
	  if (hslaMatched) {
	    var _hue = parseInt("" + hslaMatched[1], 10);
	    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;
	    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;
	    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";
	    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);
	    if (!_hslRgbMatched) {
	      throw new Error("Couldn't generate valid rgb string from " + normalizedColor + ", it returned " + _rgbColorString + ".");
	    }
	    return {
	      red: parseInt("" + _hslRgbMatched[1], 10),
	      green: parseInt("" + _hslRgbMatched[2], 10),
	      blue: parseInt("" + _hslRgbMatched[3], 10),
	      alpha: parseFloat("" + hslaMatched[4])
	    };
	  }
	  throw new Error("Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.");
	}
	function rgbToHsl(color) {
	  // make sure rgb are contained in a set of [0, 255]
	  var red = color.red / 255;
	  var green = color.green / 255;
	  var blue = color.blue / 255;
	  var max = Math.max(red, green, blue);
	  var min = Math.min(red, green, blue);
	  var lightness = (max + min) / 2;
	  if (max === min) {
	    // achromatic
	    if (color.alpha !== undefined) {
	      return {
	        hue: 0,
	        saturation: 0,
	        lightness: lightness,
	        alpha: color.alpha
	      };
	    } else {
	      return {
	        hue: 0,
	        saturation: 0,
	        lightness: lightness
	      };
	    }
	  }
	  var hue;
	  var delta = max - min;
	  var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
	  switch (max) {
	    case red:
	      hue = (green - blue) / delta + (green < blue ? 6 : 0);
	      break;
	    case green:
	      hue = (blue - red) / delta + 2;
	      break;
	    default:
	      // blue case
	      hue = (red - green) / delta + 4;
	      break;
	  }
	  hue *= 60;
	  if (color.alpha !== undefined) {
	    return {
	      hue: hue,
	      saturation: saturation,
	      lightness: lightness,
	      alpha: color.alpha
	    };
	  }
	  return {
	    hue: hue,
	    saturation: saturation,
	    lightness: lightness
	  };
	}

	/**
	 * Returns an HslColor or HslaColor object. This utility function is only useful
	 * if want to extract a color component. With the color util `toColorString` you
	 * can convert a HslColor or HslaColor object back to a string.
	 *
	 * @example
	 * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1
	 * const color1 = parseToHsl('rgb(255, 0, 0)');
	 * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2
	 * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');
	 */
	function parseToHsl(color) {
	  // Note: At a later stage we can optimize this function as right now a hsl
	  // color would be parsed converted to rgb values and converted back to hsl.
	  return rgbToHsl(parseToRgb(color));
	}

	/**
	 * Reduces hex values if possible e.g. #ff8866 to #f86
	 * @private
	 */
	var reduceHexValue = function reduceHexValue(value) {
	  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
	    return "#" + value[1] + value[3] + value[5];
	  }
	  return value;
	};
	function numberToHex(value) {
	  var hex = value.toString(16);
	  return hex.length === 1 ? "0" + hex : hex;
	}
	function colorToHex(color) {
	  return numberToHex(Math.round(color * 255));
	}
	function convertToHex(red, green, blue) {
	  return reduceHexValue("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
	}
	function hslToHex(hue, saturation, lightness) {
	  return hslToRgb(hue, saturation, lightness, convertToHex);
	}

	/**
	 * Returns a string value for the color. The returned result is the smallest possible hex notation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: hsl(359, 0.75, 0.4),
	 *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${hsl(359, 0.75, 0.4)};
	 *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#b3191c";
	 *   background: "#b3191c";
	 * }
	 */
	function hsl(value, saturation, lightness) {
	  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {
	    return hslToHex(value, saturation, lightness);
	  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined) {
	    return hslToHex(value.hue, value.saturation, value.lightness);
	  }
	  throw new Error('Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).');
	}

	/**
	 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: hsla(359, 0.75, 0.4, 0.7),
	 *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
	 *   background: hsla(359, 0.75, 0.4, 1),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${hsla(359, 0.75, 0.4, 0.7)};
	 *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
	 *   background: ${hsla(359, 0.75, 0.4, 1)};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "rgba(179,25,28,0.7)";
	 *   background: "rgba(179,25,28,0.7)";
	 *   background: "#b3191c";
	 * }
	 */
	function hsla(value, saturation, lightness, alpha) {
	  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {
	    return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
	  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
	    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
	  }
	  throw new Error('Passed invalid arguments to hsla, please pass multiple numbers e.g. hsl(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).');
	}

	/**
	 * Returns a string value for the color. The returned result is the smallest possible hex notation.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: rgb(255, 205, 100),
	 *   background: rgb({ red: 255, green: 205, blue: 100 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${rgb(255, 205, 100)};
	 *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#ffcd64";
	 *   background: "#ffcd64";
	 * }
	 */
	function rgb(value, green, blue) {
	  if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
	    return reduceHexValue("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
	  } else if (typeof value === 'object' && green === undefined && blue === undefined) {
	    return reduceHexValue("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
	  }
	  throw new Error('Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).');
	}

	/**
	 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
	 *
	 * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: rgba(255, 205, 100, 0.7),
	 *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
	 *   background: rgba(255, 205, 100, 1),
	 *   background: rgba('#ffffff', 0.4),
	 *   background: rgba('black', 0.7),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${rgba(255, 205, 100, 0.7)};
	 *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
	 *   background: ${rgba(255, 205, 100, 1)};
	 *   background: ${rgba('#ffffff', 0.4)};
	 *   background: ${rgba('black', 0.7)};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "rgba(255,205,100,0.7)";
	 *   background: "rgba(255,205,100,0.7)";
	 *   background: "#ffcd64";
	 *   background: "rgba(255,255,255,0.4)";
	 *   background: "rgba(0,0,0,0.7)";
	 * }
	 */
	function rgba(firstValue, secondValue, thirdValue, fourthValue) {
	  if (typeof firstValue === 'string' && typeof secondValue === 'number') {
	    var rgbValue = parseToRgb(firstValue);
	    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
	  } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
	    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
	  } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
	    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
	  }
	  throw new Error('Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).');
	}
	var isRgb = function isRgb(color) {
	  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
	};
	var isRgba = function isRgba(color) {
	  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
	};
	var isHsl = function isHsl(color) {
	  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
	};
	var isHsla = function isHsla(color) {
	  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
	};
	var errMsg = 'Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.';
	/**
	 * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
	 * This util is useful in case you only know on runtime which color object is
	 * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: toColorString({ red: 255, green: 205, blue: 100 }),
	 *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
	 *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
	 *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
	 *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
	 *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
	 *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
	 * `
	 *
	 * // CSS in JS Output
	 * element {
	 *   background: "#ffcd64";
	 *   background: "rgba(255,205,100,0.72)";
	 *   background: "#00f";
	 *   background: "rgba(179,25,25,0.72)";
	 * }
	 */

	function toColorString(color) {
	  if (typeof color !== 'object') throw new Error(errMsg);
	  if (isRgba(color)) return rgba(color);
	  if (isRgb(color)) return rgb(color);
	  if (isHsla(color)) return hsla(color);
	  if (isHsl(color)) return hsl(color);
	  throw new Error(errMsg);
	}

	// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
	// eslint-disable-next-line no-unused-vars
	// eslint-disable-next-line no-unused-vars
	// eslint-disable-next-line no-redeclare
	function curried(f, length, acc) {
	  return function fn() {
	    // eslint-disable-next-line prefer-rest-params
	    var combined = acc.concat(Array.prototype.slice.call(arguments));
	    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
	  };
	} // eslint-disable-next-line no-redeclare

	function curry(f) {
	  // eslint-disable-line no-redeclare
	  return curried(f, f.length, []);
	}
	function guard(lowerBoundary, upperBoundary, value) {
	  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
	}

	/**
	 * Returns a string value for the darkened color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: darken(0.2, '#FFCD64'),
	 *   background: darken('0.2', 'rgba(255,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${darken(0.2, '#FFCD64')};
	 *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#ffbd31";
	 *   background: "rgba(255,189,49,0.7)";
	 * }
	 */

	function darken(amount, color) {
	  var hslColor = parseToHsl(color);
	  return toColorString(_extends$1({}, hslColor, {
	    lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
	  }));
	} // prettier-ignore

	var curriedDarken = /*#__PURE__*/
	curry
	/* ::<number | string, string, string> */(darken);

	/**
	 * Returns a string value for the lightened color.
	 *
	 * @example
	 * // Styles as object usage
	 * const styles = {
	 *   background: lighten(0.2, '#CCCD64'),
	 *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),
	 * }
	 *
	 * // styled-components usage
	 * const div = styled.div`
	 *   background: ${lighten(0.2, '#FFCD64')};
	 *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};
	 * `
	 *
	 * // CSS in JS Output
	 *
	 * element {
	 *   background: "#e5e6b1";
	 *   background: "rgba(229,230,177,0.7)";
	 * }
	 */

	function lighten(amount, color) {
	  var hslColor = parseToHsl(color);
	  return toColorString(_extends$1({}, hslColor, {
	    lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
	  }));
	} // prettier-ignore

	var curriedLighten = /*#__PURE__*/
	curry
	/* ::<number | string, string, string> */(lighten);

	var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
	var filters = function filters(_ref) {
	  var borderColor = _ref.colors.borderColor;
	  return css(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n\tmargin: 0 -3px;\n\tmax-width: 100%;\n\n\tbutton {\n\t\tmargin: 2px 3px;\n\t\tpadding: 5px 8px;\n\t\tfont-size: 0.85rem;\n\t\tposition: relative;\n\n\t\tspan:first-child {\n\t\t\tmax-width: 260px;\n\t\t\twhite-space: nowrap;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t\tmargin-right: 26px;\n\t\t}\n\n\t\tspan:last-child {\n\t\t\tdisplay: flex;\n\t\t\theight: 100%;\n\t\t\ttop: 0;\n\t\t\tright: 8px;\n\t\t\tposition: absolute;\n\t\t\talign-items: center;\n\t\t\tborder-left: 1px solid ", ";\n\t\t\tpadding-left: 8px;\n\t\t\tmargin-left: 8px;\n\t\t}\n\n\t\t&:hover,\n\t\t&:focus {\n\t\t\tspan:first-child {\n\t\t\t\ttext-decoration: line-through;\n\t\t\t}\n\t\t}\n\t}\n"])), borderColor || '#fff');
	};
	var pagination = css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n\tmargin: 10px -3px;\n\tmax-width: 100%;\n\ttext-align: center;\n\n\tbutton {\n\t\tmargin: 0 3px;\n\t}\n"])));
	var toggleButtons = css(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["\n\tmargin: 0 -3px;\n\tmax-width: 100%;\n\n\tbutton {\n\t\tmargin: 3px 3px;\n\t}\n"])));
	var numberBoxContainer = css(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose(["\n\tmargin: 0 -5px;\n\tbutton {\n\t\tmargin: 5px;\n\t}\n\tspan {\n\t\tmargin: 0 5px;\n\t}\n"])));
	var primary = function primary(_ref2) {
	  var theme = _ref2.theme;
	  return css(_templateObject5 || (_templateObject5 = _taggedTemplateLiteralLoose(["\n\tbackground-color: ", ";\n\tcolor: ", ";\n\n\t&:hover,\n\t&:focus {\n\t\tbackground-color: ", ";\n\t}\n"])), theme.colors.primaryColor, theme.colors.primaryTextColor, curriedDarken(0.1, theme.colors.primaryColor));
	};
	var large = function large() {
	  return css(_templateObject6 || (_templateObject6 = _taggedTemplateLiteralLoose(["\n\tmin-height: 40px;\n\tpadding: 10px 20px;\n"])));
	};
	var disabled = function disabled(_ref3) {
	  var theme = _ref3.theme;
	  return css(_templateObject7 || (_templateObject7 = _taggedTemplateLiteralLoose(["\n\tbackground-color: ", ";\n\tcolor: #ccc;\n\tcursor: not-allowed;\n\n\t&:hover,\n\t&:focus {\n\t\tbackground-color: ", ";\n\t}\n"])), theme.colors.backgroundColor ? curriedLighten(0.1, theme.colors.backgroundColor) : '#fafafa', theme.colors.backgroundColor ? curriedLighten(0.2, theme.colors.backgroundColor) : '#fafafa');
	};
	var Button = index$1('button')(_templateObject8 || (_templateObject8 = _taggedTemplateLiteralLoose(["\n\tdisplay: inline-flex;\n\tjustify-content: center;\n\talign-items: center;\n\tborder-radius: 3px;\n\tborder: 1px solid transparent;\n\tmin-height: 30px;\n\tword-wrap: break-word;\n\tpadding: 5px 12px;\n\tline-height: 1.2rem;\n\tbackground-color: ", ";\n\tcolor: ", ";\n\tcursor: pointer;\n\tuser-select: none;\n\ttransition: all 0.3s ease;\n\n\t&:hover,\n\t&:focus {\n\t\tbackground-color: ", ";\n\t}\n\n\t&:focus {\n\t\toutline: 0;\n\t\tborder-color: ", ";\n\t\tbox-shadow: ", ";\n\t}\n\n\t", ";\n\t", ";\n\t", ";\n\n\t&.enter-btn {\n\t\tborder-top-left-radius: 0px;\n\t\tborder-bottom-left-radius: 0px;\n\t\theight: 100%;\n\t}\n"])), function (_ref4) {
	  var theme = _ref4.theme;
	  return theme.colors.backgroundColor || '#eee';
	}, function (_ref5) {
	  var theme = _ref5.theme;
	  return theme.colors.textColor;
	}, function (_ref6) {
	  var theme = _ref6.theme;
	  return theme.colors.backgroundColor ? curriedDarken(0.1, theme.colors.backgroundColor) : '#ccc';
	}, function (_ref7) {
	  var theme = _ref7.theme;
	  return rgba(theme.colors.primaryColor, 0.6);
	}, function (_ref8) {
	  var theme = _ref8.theme;
	  return "0 0 0 2px " + rgba(theme.colors.primaryColor, 0.3);
	}, function (props) {
	  return props.primary ? primary : null;
	}, function (props) {
	  return props.disabled ? disabled : null;
	}, function (props) {
	  return props.large && large;
	});
	var loadMoreContainer = css({
	  margin: '5px 0',
	  display: 'flex',
	  justifyContent: 'center'
	});

	// import dateFormats from './dateFormats';

	VueTypes.sensibleDefaults = false;
	var reactKeyType = VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string), VueTypes.object, VueTypes.arrayOf(VueTypes.object)]);
	function validateLocation(value) {
	  if (!value || !value.lat || !value.lng) {
	    console.error(new Error('location must be an object with lat and lng keys defined'));
	    return false;
	  }
	  // eslint-disable-next-line
	  if (isNaN(value.lat)) {
	    console.error(new Error('lat value must be a number'));
	    return false;
	  }
	  // eslint-disable-next-line
	  if (isNaN(value.lat)) {
	    console.error(new Error('lng value must be a number'));
	    return false;
	  }
	  if (value.lat < -90 || value.lat > 90) {
	    console.error(new Error('lat value should be between -90 and 90.'));
	    return false;
	  }
	  if (value.lat < -180 || value.lat > 180) {
	    console.error(new Error('lng value should be between -180 and 180.'));
	    return false;
	  }
	  return true;
	}
	var types = {
	  any: VueTypes.any,
	  bool: VueTypes.bool,
	  boolRequired: VueTypes.bool.isRequired,
	  components: VueTypes.arrayOf(VueTypes.string),
	  children: VueTypes.any,
	  data: VueTypes.arrayOf(VueTypes.object),
	  dataFieldArray: VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string)]).isRequired,
	  dataNumberBox: VueTypes.shape({
	    label: VueTypes.string,
	    start: VueTypes.number.isRequired,
	    end: VueTypes.number.isRequired
	  }).isRequired,
	  date: VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string)]),
	  dateObject: VueTypes.object,
	  excludeFields: VueTypes.arrayOf(VueTypes.string),
	  fieldWeights: VueTypes.arrayOf(VueTypes.number),
	  filterLabel: VueTypes.string,
	  func: VueTypes.func,
	  funcRequired: VueTypes.func.isRequired,
	  fuzziness: VueTypes.oneOf([0, 1, 2, 'AUTO']),
	  headers: VueTypes.object,
	  hits: VueTypes.arrayOf(VueTypes.object),
	  iconPosition: VueTypes.oneOf(['left', 'right']),
	  includeFields: VueTypes.arrayOf(VueTypes.string),
	  labelPosition: VueTypes.oneOf(['left', 'right', 'top', 'bottom']),
	  number: VueTypes.number,
	  options: VueTypes.oneOfType([VueTypes.arrayOf(VueTypes.object), VueTypes.object]),
	  paginationAt: VueTypes.oneOf(['top', 'bottom', 'both']),
	  range: VueTypes.shape({
	    start: VueTypes.number.isRequired,
	    end: VueTypes.number.isRequired
	  }),
	  rangeLabels: VueTypes.shape({
	    start: VueTypes.string.isRequired,
	    end: VueTypes.string.isRequired
	  }),
	  react: VueTypes.shape({
	    and: reactKeyType,
	    or: reactKeyType,
	    not: reactKeyType
	  }),
	  selectedValues: VueTypes.object,
	  selectedValue: VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string), VueTypes.arrayOf(VueTypes.object), VueTypes.object, Number, VueTypes.arrayOf(Number)]),
	  suggestions: VueTypes.arrayOf(VueTypes.object),
	  supportedOrientations: VueTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']),
	  sortBy: VueTypes.oneOf(['asc', 'desc']),
	  sortOptions: VueTypes.arrayOf(VueTypes.shape({
	    label: VueTypes.string,
	    dataField: VueTypes.string,
	    sortBy: VueTypes.string
	  })),
	  sortByWithCount: VueTypes.oneOf(['asc', 'desc', 'count']),
	  stats: VueTypes.arrayOf(VueTypes.object),
	  string: VueTypes.string,
	  stringArray: VueTypes.arrayOf(VueTypes.string),
	  stringOrArray: VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string)]),
	  stringRequired: VueTypes.string.isRequired,
	  style: VueTypes.object,
	  themePreset: VueTypes.oneOf(['light', 'dark']),
	  // queryFormatDate: VueTypes.oneOf(VueTypes.object.keys(dateFormats)),
	  queryFormatSearch: VueTypes.oneOf(['and', 'or']),
	  queryFormatNumberBox: VueTypes.oneOf(['exact', 'lte', 'gte']),
	  params: VueTypes.object.isRequired,
	  props: VueTypes.object,
	  rangeLabelsAlign: VueTypes.oneOf(['left', 'right']),
	  title: VueTypes.oneOfType([VueTypes.string, VueTypes.any]),
	  tooltipTrigger: VueTypes.oneOf(['always', 'none', 'hover']),
	  location: VueTypes.custom(validateLocation),
	  unit: VueTypes.oneOf(['mi', 'miles', 'yd', 'yards', 'ft', 'feet', 'in', 'inch', 'km', 'kilometers', 'm', 'meters', 'cm', 'centimeters', 'mm', 'millimeters', 'NM', 'nmi', 'nauticalmiles']),
	  value: VueTypes.string.def(undefined),
	  analyticsConfig: VueTypes.shape({
	    emptyQuery: VueTypes.bool,
	    suggestionAnalytics: VueTypes.bool,
	    userId: VueTypes.string,
	    customEvents: VueTypes.object
	  }),
	  appbaseConfig: VueTypes.shape({
	    recordAnalytics: VueTypes.bool,
	    emptyQuery: VueTypes.bool,
	    suggestionAnalytics: VueTypes.bool,
	    enableQueryRules: VueTypes.bool,
	    enableSearchRelevancy: VueTypes.bool,
	    userId: VueTypes.string,
	    useCache: VueTypes.bool,
	    customEvents: VueTypes.object,
	    enableTelemetry: VueTypes.bool.def(true)
	  }).def({}),
	  mongodb: VueTypes.shape({
	    db: VueTypes.string,
	    collection: VueTypes.string
	  }),
	  endpointConfig: VueTypes.shape({
	    url: VueTypes.string.isRequired,
	    method: VueTypes.string,
	    headers: VueTypes.object,
	    body: VueTypes.object
	  })
	};

	var getClassName = lib_8.getClassName,
	  handleA11yAction = lib_8.handleA11yAction;
	function getStartPage(totalPages, currentPage, showEndPage) {
	  var midValue = parseInt(totalPages / 2, 10);
	  var start = currentPage - (showEndPage ? Math.ceil(midValue / 2) - 1 : midValue);
	  return start > 1 ? start : 2;
	}
	var Pagination = {
	  name: 'Pagination',
	  functional: true,
	  props: {
	    currentPage: types.number,
	    innerClass: types.style,
	    pages: types.number,
	    setPage: types.func,
	    totalPages: types.number,
	    showEndPage: VueTypes.bool,
	    prevLabel: types.string,
	    nextLabel: types.string
	  },
	  render: function render(createElement, context) {
	    var h = arguments[0];
	    var props = context.props;
	    var onPrevPage = function onPrevPage() {
	      if (props.currentPage) {
	        props.setPage(props.currentPage - 1);
	      }
	    };
	    var onNextPage = function onNextPage() {
	      if (props.currentPage < props.totalPages - 1) {
	        props.setPage(props.currentPage + 1);
	      }
	    };
	    if (!props.totalPages) {
	      return null;
	    }
	    var innerClassName = getClassName(props.innerClass, 'button');
	    var primary = props.currentPage === 0;
	    var className = innerClassName || primary ? innerClassName + " " + (primary ? 'active' : '') : '';
	    var buildPaginationDOM = function buildPaginationDOM(position) {
	      var pages = props.pages,
	        currentPage = props.currentPage,
	        totalPages = props.totalPages,
	        setPage = props.setPage,
	        showEndPage = props.showEndPage;
	      var start = position === 'start' ? getStartPage(pages, currentPage, showEndPage) : Math.max(2, Math.ceil(totalPages - (pages - 1) / 2 + 1));
	      var paginationButtons = [];
	      var endPage = start;
	      if (start <= totalPages) {
	        var totalPagesToShow = pages < totalPages ? start + (pages - 1) : totalPages + 1;
	        if (showEndPage) {
	          totalPagesToShow = position === 'start' ? start + (Math.ceil(pages / 2) - pages % 2) : totalPages + 1;
	        }
	        if (currentPage > totalPages - pages + 2) {
	          start = Math.max(2, totalPages - pages + 2);
	          totalPagesToShow = start + pages;
	        }
	        var _loop = function _loop(i) {
	          var activeButton = currentPage === i - 1;
	          var classNameBtn = innerClassName || activeButton ? innerClassName + " " + (activeButton ? 'active' : '') : '';
	          var pageBtn = h(Button, {
	            "class": classNameBtn,
	            "attrs": {
	              "primary": activeButton,
	              "tabIndex": "0",
	              "alt": "page-" + i
	            },
	            "on": {
	              "keyPress": function keyPress(event) {
	                return handleA11yAction(event, function () {
	                  return setPage(i - 1);
	                });
	              },
	              "click": function click() {
	                return setPage(i - 1);
	              }
	            }
	          }, [i]);
	          if (i <= totalPages + 1) {
	            paginationButtons.push(pageBtn);
	            if (i === Math.min(totalPages + 1, totalPagesToShow) - 1) {
	              endPage = i;
	            }
	          }
	        };
	        for (var i = start; i < Math.min(totalPages + 1, totalPagesToShow); i += 1) {
	          _loop(i);
	        }
	      }
	      return [paginationButtons, start, endPage];
	    };
	    var buildIntermediatePaginationDom = function buildIntermediatePaginationDom() {
	      var showEndPage = props.showEndPage,
	        currentPage = props.currentPage,
	        totalPages = props.totalPages,
	        pages = props.pages;
	      if (!showEndPage) return buildPaginationDOM('start')[0];
	      if (currentPage <= totalPages - pages + 2 || totalPages < pages) {
	        return buildPaginationDOM('start')[0];
	      }
	      return null;
	    };
	    return h("div", {
	      "class": pagination + " " + getClassName(props.innerClass, 'pagination')
	    }, [h(Button, {
	      "class": getClassName(props.innerClass, 'button') || '',
	      "attrs": {
	        "disabled": props.currentPage === 0,
	        "tabIndex": "0"
	      },
	      "on": {
	        "keyPress": function keyPress(event) {
	          return handleA11yAction(event, onPrevPage);
	        },
	        "click": onPrevPage
	      }
	    }, [props.prevLabel || 'Prev']), h(Button, {
	      "class": className,
	      "attrs": {
	        "primary": primary,
	        "tabIndex": "0"
	      },
	      "on": {
	        "keyPress": function keyPress(event) {
	          return handleA11yAction(event, function () {
	            return props.setPage(0);
	          });
	        },
	        "click": function click() {
	          return props.setPage(0);
	        }
	      }
	    }, ["1"]), props.showEndPage && props.currentPage >= Math.floor(props.pages / 2) + !!(props.pages % 2) && buildPaginationDOM('start')[1] !== 2 ? h("span", ["..."]) : null, buildIntermediatePaginationDom(), props.showEndPage && props.pages > 2 && props.currentPage <= props.totalPages - Math.ceil(props.pages * 0.75) && buildPaginationDOM('start')[2] !== buildPaginationDOM('end')[1] - 1 ? h("span", ["..."]) : null, props.showEndPage && props.totalPages >= props.pages && buildPaginationDOM('end')[0], h(Button, {
	      "class": getClassName(props.innerClass, 'button') || '',
	      "attrs": {
	        "disabled": props.currentPage >= props.totalPages - 1,
	        "tabIndex": "0"
	      },
	      "on": {
	        "keyPress": function keyPress(event) {
	          return handleA11yAction(event, onNextPage);
	        },
	        "click": onNextPage
	      }
	    }, [props.nextLabel || 'Next'])]);
	  }
	};
	Pagination.install = function (Vue) {
	  Vue.component(Pagination.name, Pagination);
	};

	var _templateObject$1;
	var PoweredByImage = index$1('img')(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["\n\twidth: 110px;\n"])));

	var PoweredBy = {
	  functional: true,
	  render: function render(h) {
	    return h("a", {
	      "attrs": {
	        "href": "https://appbase.io/",
	        "target": "_blank",
	        "rel": "noopener noreferrer"
	      }
	    }, [h(PoweredByImage, {
	      "attrs": {
	        "src": "https://cdn.jsdelivr.net/gh/appbaseio/cdn@d2ec210045e59104ee5485841fa17b23fc83f097/appbase/logos/rbc-logo.svg"
	      }
	    })]);
	  }
	};

	// Credit to React-Redux for this util function
	// https://github.com/reactjs/react-redux/blob/573db0bfc8d1d50fdb6e2a98bd8a7d4675fecf11/src/utils/shallowEqual.js

	var hasOwn$1 = Object.prototype.hasOwnProperty;
	function is(x, y) {
	  if (x === y) {
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  }
	  // eslint-disable-next-line
	  return x !== x && y !== y;
	}
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) return true;
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	  if (keysA.length !== keysB.length) return false;
	  for (var i = 0; i < keysA.length; i += 1) {
	    if (!hasOwn$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	  return true;
	}

	var defaultMapState = function defaultMapState() {
	  return {};
	};
	var defaultMapDispatch = {};
	var normalizeMapState = function normalizeMapState(mapState) {
	  if (typeof mapState === 'function') return mapState;
	  if (mapState === Object(mapState)) {
	    return function (state, ownProps) {
	      return Object.keys(mapState).filter(function (key) {
	        return typeof mapState[key] === 'function';
	      }).reduce(function (map, key) {
	        var _extends2;
	        return _extends({}, map, (_extends2 = {}, _extends2[key] = mapState[key](state, ownProps), _extends2));
	      }, {});
	    };
	  }
	  throw new Error('[revux] - mapState provided to connect is invalid');
	};

	// eslint-disable-next-line
	var connector = function connector(_mapState, mapDispatch) {
	  if (_mapState === void 0) {
	    _mapState = defaultMapState;
	  }
	  if (mapDispatch === void 0) {
	    mapDispatch = defaultMapDispatch;
	  }
	  return function (component) {
	    var mapState = normalizeMapState(_mapState);
	    return {
	      name: "connect-" + component.name,
	      mixins: [component],
	      inject: ['$$store'],
	      data: function data() {
	        var merged = _extends({}, mapState(this.$$store.getState(), this.$props || {}), bindActionCreators(mapDispatch, this.$$store.dispatch));
	        return Object.keys(merged).reduce(function (data, key) {
	          var _extends3;
	          return _extends({}, data, (_extends3 = {}, _extends3[key] = merged[key], _extends3));
	        }, {});
	      },
	      created: function created() {
	        var _this = this;
	        var getMappedState = function getMappedState(state) {
	          return mapState(state, _this.$props || {});
	        };
	        var observeStore = function observeStore(store, select, onChange) {
	          var currentState = select(store.getState());
	          return store.subscribe(function () {
	            var nextState = select(store.getState());
	            if (!shallowEqual(currentState, nextState)) {
	              var previousState = currentState;
	              currentState = nextState;
	              onChange(currentState, previousState);
	            }
	          });
	        };
	        this._unsubscribe = observeStore(this.$$store, getMappedState, function (newState) {
	          Object.keys(newState).forEach(function (key) {
	            _this.$set(_this, key, newState[key]);
	          });
	        });
	      },
	      beforeDestroy: function beforeDestroy() {
	        this._unsubscribe();
	      }
	    };
	  };
	};

	var defaultQueryUtil = lib_8.updateDefaultQuery,
	  customQueryUtil = lib_8.updateCustomQuery,
	  isEqual = lib_8.isEqual;

	// TODO
	// import { storeKey } from '@appbaseio/reactivecore';

	var connect = function connect() {
	  return connector.apply(void 0, arguments);
	};
	// connectToStore(...args, null, {
	//   storeKey,
	// });

	var X_SEARCH_CLIENT = 'ReactiveSearch Vue';
	var composeThemeObject = function composeThemeObject(ownTheme, userTheme) {
	  if (ownTheme === void 0) {
	    ownTheme = {};
	  }
	  if (userTheme === void 0) {
	    userTheme = {};
	  }
	  return {
	    typography: _extends({}, ownTheme.typography, userTheme.typography),
	    colors: _extends({}, ownTheme.colors, userTheme.colors),
	    component: _extends({}, ownTheme.component, userTheme.component)
	  };
	};
	/**
	 * To determine wether an element is a function
	 * @param {any} element
	 */
	var isFunction$1 = function isFunction(element) {
	  return typeof element === 'function';
	};

	// parses current array (i.e. this.$props.value) for `onChange` callback for multi-* components
	function parseValueArray(objectValues, currentValue) {
	  var selectedValues;
	  if (Array.isArray(objectValues)) {
	    selectedValues = [].concat(objectValues);
	  } else {
	    var keys = Object.keys(objectValues);
	    selectedValues = keys.map(function (key) {
	      return objectValues[key] ? key : null;
	    });
	  }
	  if (selectedValues.includes(currentValue)) {
	    return selectedValues.filter(function (item) {
	      return item !== currentValue;
	    });
	  }
	  return [].concat(selectedValues, [currentValue]);
	}

	/**
	 * Extracts the render prop from props or slot and returns a valid JSX element
	 * @param {Object} data
	 * @param _ref
	 */
	var getComponent = function getComponent(data, _ref) {
	  if (data === void 0) {
	    data = {};
	  }
	  if (_ref === void 0) {
	    _ref = {};
	  }
	  var _ref2 = _ref.$scopedSlots || _ref.$props,
	    render = _ref2.render;
	  if (render) return render(data);
	  return null;
	};
	/**
	 * To determine whether a component has render prop or slot defined or not
	 * @returns {Boolean}
	 */
	var hasCustomRenderer = function hasCustomRenderer(_ref) {
	  if (_ref === void 0) {
	    _ref = {};
	  }
	  var _ref3 = _ref.$scopedSlots || _ref.$props,
	    render = _ref3.render;
	  return Boolean(render);
	};
	var getValidPropsKeys = function getValidPropsKeys(props) {
	  if (props === void 0) {
	    props = {};
	  }
	  return Object.keys(props).filter(function (i) {
	    return constants_3$1.includes(i);
	  });
	};
	var isEvent = function isEvent(candidate) {
	  return !!(candidate && candidate.stopPropagation && candidate.preventDefault);
	};
	var updateDefaultQuery = function updateDefaultQuery(componentId, setDefaultQuery, props, value) {
	  defaultQueryUtil(componentId, _extends({}, props, {
	    setDefaultQuery: setDefaultQuery
	  }), value);
	};
	var updateCustomQuery = function updateCustomQuery(componentId, setCustomQuery, props, value) {
	  customQueryUtil(componentId, _extends({}, props, {
	    setCustomQuery: setCustomQuery
	  }), value);
	};

	/**
	 * @param {Function} newVal
	 * @param {Function} oldVal
	 * @param {any} value
	 * @param {Object} props
	 */
	var isQueryIdentical = function isQueryIdentical(newVal, oldVal, value, props) {
	  if (typeof newVal !== 'function' || typeof oldVal !== 'function') return true;
	  // to not call original defaultQuery and customQuery, as here we are only comparing
	  return isEqual(oldVal(value, props), newVal(value, props));
	};
	/**
	 * Extracts the renderPopularSuggestions prop from props or slot and returns a valid JSX element
	 * @param {Object} data
	 * @param _ref
	 */
	var getQuerySuggestionsComponent = function getQuerySuggestionsComponent(data, _ref) {
	  if (data === void 0) {
	    data = {};
	  }
	  if (_ref === void 0) {
	    _ref = {};
	  }
	  var _ref4 = _ref.$scopedSlots || _ref.$props,
	    renderQuerySuggestions = _ref4.renderQuerySuggestions,
	    renderPopularSuggestions = _ref4.renderPopularSuggestions;
	  var render = renderPopularSuggestions || renderQuerySuggestions;
	  if (render) return render(data);
	  return null;
	};
	/**
	 * To determine whether a component has renderQuerySuggestions prop or slot defined or not
	 * @returns {Boolean}
	 */
	var hasQuerySuggestionsRenderer = function hasQuerySuggestionsRenderer(_ref) {
	  if (_ref === void 0) {
	    _ref = {};
	  }
	  var _ref5 = _ref.$scopedSlots || _ref.$props,
	    renderQuerySuggestions = _ref5.renderQuerySuggestions,
	    renderPopularSuggestions = _ref5.renderPopularSuggestions;
	  return Boolean(renderPopularSuggestions) || Boolean(renderQuerySuggestions);
	};

	/**
	 * To get the camel case string from kebab case
	 * @returns {string}
	 */
	var getCamelCase = function getCamelCase(str) {
	  if (str === void 0) {
	    str = '';
	  }
	  var propsWhichRequirePascalCase = ['u-r-l-params'];
	  var arr = str.split('-');
	  var capital = arr.map(function (item, index) {
	    return index ? item.charAt(0).toUpperCase() + item.slice(1).toLowerCase() : item;
	  });
	  // ^-- change here.
	  var capitalString = capital.join('');
	  if (propsWhichRequirePascalCase.includes(str)) capitalString = capitalString[0].toUpperCase() + capitalString.substring(1);
	  return capitalString || '';
	};
	var isEmpty = function isEmpty(val) {
	  return !(val && val.length && Object.keys(val).length);
	};
	function isNumeric(value) {
	  return /^-?\d+$/.test(value);
	}

	// check if passed shortcut a key combination
	function isHotkeyCombination(hotkey) {
	  return typeof hotkey === 'string' && hotkey.indexOf('+') !== -1;
	}

	// used for getting correct string char from keycode passed
	// the below algebraic expression is used to get the correct ascii code out of the e.which || e.keycode returned value
	// since the keyboards doesn't understand ascii but scan codes and they differ for certain keys such as '/'
	// stackoverflow ref: https://stackoverflow.com/a/29811987/10822996
	function getCharFromCharCode(passedCharCode) {
	  var which = passedCharCode;
	  var chrCode = which - 48 * Math.floor(which / 48);
	  return String.fromCharCode(which >= 96 ? chrCode : which);
	}

	// used for parsing focusshortcuts for keycodes passed as string, eg: 'ctrl+/' is same as 'ctrl+47'
	// returns focusShortcuts containing appropriate key charsas depicted on keyboards
	function parseFocusShortcuts(focusShortcutsArray) {
	  if (isEmpty(focusShortcutsArray)) return [];
	  var parsedFocusShortcutsArray = [];
	  focusShortcutsArray.forEach(function (element) {
	    if (typeof element === 'string') {
	      if (isHotkeyCombination(element)) {
	        // splitting the combination into pieces
	        var splitCombination = element.split('+');
	        var parsedSplitCombination = [];
	        // parsedCombination would have all the keycodes converted into chars
	        var parsedCombination = '';
	        for (var i = 0; i < splitCombination.length; i += 1) {
	          if (isNumeric(splitCombination[i])) {
	            parsedSplitCombination.push(getCharFromCharCode(+splitCombination[i]));
	          } else {
	            parsedSplitCombination.push(splitCombination[i]);
	          }
	        }
	        parsedCombination = parsedSplitCombination.join('+');
	        parsedFocusShortcutsArray.push(parsedCombination);
	      } else if (isNumeric(element)) {
	        parsedFocusShortcutsArray.push(getCharFromCharCode(+element));
	      } else {
	        // single char shortcut, eg: '/'
	        parsedFocusShortcutsArray.push(element);
	      }
	    } else {
	      // if not a string the the shortcut is assumed to be a keycode
	      parsedFocusShortcutsArray.push(getCharFromCharCode(element));
	    }
	  });
	  return parsedFocusShortcutsArray;
	}
	var MODIFIER_KEYS = ['shift', 'ctrl', 'alt', 'control', 'option', 'cmd', 'command'];

	// filter out modifierkeys such as ctrl, alt, command, shift from focusShortcuts prop
	function extractModifierKeysFromFocusShortcuts(focusShortcutsArray) {
	  return focusShortcutsArray.filter(function (shortcutKey) {
	    return MODIFIER_KEYS.includes(shortcutKey);
	  });
	}
	function decodeHtml(str) {
	  if (typeof str !== 'string') {
	    return str;
	  }
	  return str.replace(/&#([0-9]{1,3});/gi, function (match, numStr) {
	    var num = parseInt(numStr, 10); // read num as normal number
	    return String.fromCharCode(num);
	  });
	}

	var addComponent = lib_5.addComponent,
	  removeComponent = lib_5.removeComponent,
	  watchComponent = lib_5.watchComponent,
	  setQueryListener = lib_5.setQueryListener,
	  setComponentProps = lib_5.setComponentProps,
	  updateComponentProps = lib_5.updateComponentProps;
	var pushToAndClause = lib_8.pushToAndClause,
	  checkPropChange = lib_8.checkPropChange,
	  checkSomePropChange = lib_8.checkSomePropChange;

	/**
	 * ComponentWrapper component is a wrapper component for each ReactiveSearch component
	 * which is responsible for following tasks:
	 * 1. Register a component on mount
	 * 2. Set query listener
	 * 3. Set react prop
	 * 4. Follow the [1-3] for the internal component if needed
	 * 5. Update component props in redux store
	 * 6. Unregister the component on un-mount
	 * Note: All components are using that except the DynamicRangeSlider
	 */
	var ComponentWrapper = function ComponentWrapper(component, options) {
	  if (options === void 0) {
	    options = {
	      componentType: null,
	      internalComponent: false
	    };
	  }
	  return {
	    name: 'ComponentWrapper',
	    $timestamp: null,
	    props: {
	      destroyOnUnmount: VueTypes.bool.def(true)
	    },
	    created: function created() {
	      // clone the props for component it is needed because attrs gets changed on time
	      var componentProps = _extends({}, this.$attrs);
	      // handle kebab case for props
	      var parsedProps = {};
	      Object.keys(componentProps).forEach(function (key) {
	        parsedProps[getCamelCase(key)] = componentProps[key];
	      });
	      this.componentProps = parsedProps;
	      this.componentId = this.componentProps.componentId;
	      this.react = this.componentProps.react;
	      this.$timestamp = new Date().getTime();
	    },
	    beforeMount: function beforeMount() {
	      var _this = this;
	      var components = [];
	      if (this.$$store) {
	        var _this$$$store$getStat = this.$$store.getState();
	        components = _this$$$store$getStat.components;
	      }
	      // Register a component only when `destroyOnUnmount` is `true`
	      // or component is not present in store
	      if (this.destroyOnUnmount || components.indexOf(this.componentProps.componentId) === -1) {
	        // Register  component
	        this.addComponent(this.componentId, this.$timestamp);
	        var onQueryChange = function onQueryChange() {
	          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	          _this.$emit.apply(_this, ['queryChange'].concat(args));
	          _this.$emit.apply(_this, ['query-change'].concat(args));
	        };
	        var onError = function onError(e) {
	          _this.$emit('error', e);
	        };
	        this.setQueryListener(this.componentId, onQueryChange, onError);
	        // Update props in store
	        this.setComponentProps(this.componentId, this.componentProps, options.componentType);
	      }

	      // if default query prop is defined and component is reactive component then register the internal component
	      if (options.internalComponent || this.componentProps.defaultQuery && options.componentType === constants_1$1.reactiveComponent) {
	        this.internalComponent = transform_11(this.componentId);
	      }
	      // Register internal component
	      if (this.internalComponent && (this.destroyOnUnmount || components.indexOf(this.internalComponent) === -1)) {
	        this.addComponent(this.internalComponent, this.$timestamp);
	        this.setComponentProps(this.internalComponent, this.componentProps, options.componentType);
	      }
	    },
	    mounted: function mounted() {
	      if (this.internalComponent) {
	        // Watch component after rendering the component to avoid the un-necessary calls
	        this.setReact(this.componentProps);
	      }
	    },
	    beforeDestroy: function beforeDestroy() {
	      if (this.destroyOnUnmount) {
	        var registeredComponentsTimestamps = {};
	        if (this.$$store) {
	          var _this$$$store$getStat2 = this.$$store.getState();
	          registeredComponentsTimestamps = _this$$$store$getStat2.registeredComponentsTimestamps;
	        }
	        // Unregister components
	        if (registeredComponentsTimestamps[this.componentId] === this.$timestamp) {
	          this.removeComponent(this.componentId);
	          if (this.internalComponent) {
	            this.removeComponent(this.internalComponent);
	          }
	        }
	      }
	    },
	    watch: {
	      $attrs: {
	        deep: true,
	        handler: function handler(newVal) {
	          var _this2 = this;
	          var propsKeys = getValidPropsKeys(newVal);
	          checkSomePropChange(newVal, this.savedComponentProps, propsKeys, function () {
	            _this2.updateComponentProps(_this2.componentId, newVal, options.componentType);
	            _this2.updateComponentProps(_this2.internalComponent, newVal, options.componentType);
	          });
	        }
	      },
	      react: function react(newVal, oldVal) {
	        var _this3 = this;
	        checkPropChange(newVal, oldVal, function () {
	          return _this3.setReact(_this3.componentProps);
	        });
	      }
	    },
	    methods: {
	      setReact: function setReact(props) {
	        var react = props.react,
	          executeInitialQuery = props.executeInitialQuery;
	        if (this.internalComponent) {
	          if (react) {
	            var newReact = pushToAndClause(react, this.internalComponent);
	            this.watchComponent(props.componentId, newReact, executeInitialQuery);
	          } else {
	            this.watchComponent(props.componentId, {
	              and: this.internalComponent
	            }, executeInitialQuery);
	          }
	        } else {
	          this.watchComponent(props.componentId, react, executeInitialQuery);
	        }
	      }
	    },
	    render: function render(h) {
	      return h(component, {
	        attrs: this.$attrs,
	        on: this.$listeners,
	        scopedSlots: this.$scopedSlots,
	        slots: this.$slots
	      });
	    }
	  };
	};
	var mapStateToProps = function mapStateToProps(state, props) {
	  return {
	    savedComponentProps: state.props[props.componentId]
	  };
	};
	var mapDispatchToProps = {
	  addComponent: addComponent,
	  removeComponent: removeComponent,
	  setQueryListener: setQueryListener,
	  watchComponent: watchComponent,
	  setComponentProps: setComponentProps,
	  updateComponentProps: updateComponentProps
	};
	var ComponentWrapper$1 = (function (component, options) {
	  if (options === void 0) {
	    options = {};
	  }
	  return connect(mapStateToProps, mapDispatchToProps)(ComponentWrapper(component, options));
	});

	var deepValue = function deepValue(o, p) {
	  return p.split('.').reduce(function (a, v) {
	    return a ? a[v] : null;
	  }, o);
	};
	/**
	 * PreferencesConsumer reads the preferences from SearchPreferencesContext
	 * and set the props from preferences to the component
	 *
	 */
	var PreferencesConsumer = function PreferencesConsumer(component) {
	  return {
	    name: 'PreferencesConsumer',
	    inject: {
	      $searchPreferences: {
	        "default": null
	      }
	    },
	    render: function render(h) {
	      var _this = this;
	      var userProps = Object.keys(this.$attrs).reduce(function (result, key) {
	        var _extends2;
	        return _extends({}, result, (_extends2 = {}, _extends2[getCamelCase(key)] = _this.$attrs[key], _extends2));
	      }, {});
	      var context = this.$searchPreferences;
	      if (!userProps || !userProps.componentId) {
	        throw Error('ReactiveSearch: componentId is required');
	      }
	      var componentId = userProps.componentId;
	      var preferencesPath = userProps.preferencesPath;
	      var preferences;
	      if (context) {
	        if (preferencesPath) {
	          // read preferences from path
	          preferences = deepValue(context, preferencesPath);
	        } else {
	          preferences = deepValue(context, ['componentSettings', componentId].join('.'));
	          // read preferences from componentSettings
	        }
	      }
	      // Retrieve component specific preferences
	      var componentProps = userProps;
	      if (preferences) {
	        if (preferences.rsConfig) {
	          componentProps = _extends({}, preferences.rsConfig, componentProps);
	        } else {
	          componentProps = _extends({}, preferences, componentProps);
	        }
	        if (preferences.enabled !== undefined && !preferences.enabled) {
	          return null;
	        }
	      }
	      // Parse component props
	      Object.keys(componentProps).forEach(function (p) {
	        if (typeof componentProps[p] === 'string') {
	          if (['defaultQuery', 'customQuery', 'setOption'].includes(p)) {
	            // eslint-disable-next-line
	            componentProps[p] = eval(componentProps[p]);
	          }
	        }
	      });
	      return h(component, {
	        attrs: componentProps,
	        on: this.$listeners,
	        scopedSlots: this.$scopedSlots,
	        slots: this.$slots
	      });
	    }
	  };
	};

	function _extends$2() {
	  return _extends$2 = Object.assign ? Object.assign.bind() : function (a) {
	    for (var b, c = 1; c < arguments.length; c++) {
	      for (var d in b = arguments[c], b) {
	        Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d]);
	      }
	    }
	    return a;
	  }, _extends$2.apply(this, arguments);
	}
	var normalMerge = ["attrs", "props", "domProps"],
	  toArrayMerge = ["class", "style", "directives"],
	  functionalMerge = ["on", "nativeOn"],
	  mergeJsxProps = function mergeJsxProps(a) {
	    return a.reduce(function (c, a) {
	      for (var b in a) {
	        if (!c[b]) c[b] = a[b];else if (-1 !== normalMerge.indexOf(b)) c[b] = _extends$2({}, c[b], a[b]);else if (-1 !== toArrayMerge.indexOf(b)) {
	          var d = c[b] instanceof Array ? c[b] : [c[b]],
	            e = a[b] instanceof Array ? a[b] : [a[b]];
	          c[b] = [].concat(d, e);
	        } else if (-1 !== functionalMerge.indexOf(b)) {
	          for (var f in a[b]) {
	            if (c[b][f]) {
	              var g = c[b][f] instanceof Array ? c[b][f] : [c[b][f]],
	                h = a[b][f] instanceof Array ? a[b][f] : [a[b][f]];
	              c[b][f] = [].concat(g, h);
	            } else c[b][f] = a[b][f];
	          }
	        } else if ("hook" === b) for (var i in a[b]) {
	          c[b][i] = c[b][i] ? mergeFn(c[b][i], a[b][i]) : a[b][i];
	        } else c[b] = a[b];
	      }
	      return c;
	    }, {});
	  },
	  mergeFn = function mergeFn(a, b) {
	    return function () {
	      a && a.apply(this, arguments), b && b.apply(this, arguments);
	    };
	  };
	var helper$1 = mergeJsxProps;

	var _templateObject$2;
	var Title = index$1('h2')(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose(["\n\tmargin: 0 0 8px;\n\tfont-size: 1rem;\n\tcolor: ", ";\n"])), function (_ref) {
	  var theme = _ref.theme;
	  return theme.colors.titleColor;
	});

	var _templateObject$3, _templateObject2$1, _templateObject3$1, _templateObject4$1;
	var container = css(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteralLoose(["\n\tdisplay: flex;\n\tflex-direction: column;\n\tmargin: 0;\n\tborder-radius: 0.25rem;\n\toverflow: hidden;\n"])));
	var smallImage = css(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose(["\n\twidth: 100px;\n\theight: 100px;\n"])));
	var Image = index$1('div')(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose(["\n\twidth: 160px;\n\theight: 160px;\n\t", ";\n\tmargin: 0;\n\tbackground-size: contain;\n\tbackground-position: center center;\n\tbackground-repeat: no-repeat;\n\tbackground-image: ", ";\n"])), function (props) {
	  return props.small ? smallImage : null;
	}, function (props) {
	  return "url(" + props.src + ")";
	});
	var ListItem = index$1('a')(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteralLoose(["\n\twidth: 100%;\n\theight: auto;\n\toutline: none;\n\ttext-decoration: none;\n\tborder-radius: 0;\n\tbackground-color: ", ";\n\tdisplay: flex;\n\tflex-direction: row;\n\tmargin: 0;\n\tpadding: 10px;\n\tborder-bottom: 1px solid ", ";\n\tcolor: ", ";\n\t", "; all 0.3s ease;\n\n\t&:hover, &:focus {\n\t\tbackground-color: ", ";\n\t}\n\n\t&:last-child {\n\t\tborder: 0;\n\t}\n\n\th2 {\n\t\twidth: 100%;\n\t\tline-height: 1.2rem;\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t\tmargin: 0;\n\t\tpadding: 0 0 8px;\n\t}\n\n\tp {\n\t\tmargin: 0;\n\t}\n\n\tarticle {\n\t\twidth: ", ";\n\t\tpadding-left: ", ";\n\t\tfont-size: 0.9rem;\n\t}\n\n\t&:hover, &:focus {\n\t\tbox-shadow: 0 0 0 0 rgba(0,0,0,0.10);\n\t}\n\n\t@media (max-width: 420px) {\n\t\tmin-width: 0;\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tbox-shadow: none;\n\t\tborder: 1px solid #eee;\n\n\t\t&:hover, &:focus {\n\t\t\tbox-shadow: 0;\n\t\t}\n\t}\n"])), function (_ref) {
	  var theme = _ref.theme;
	  return theme.colors.backgroundColor ? curriedLighten(0.1, theme.colors.backgroundColor) : '#fff';
	}, function (_ref2) {
	  var theme = _ref2.theme;
	  return theme.colors.backgroundColor ? curriedLighten(0.3, theme.colors.backgroundColor) : curriedLighten(0.68, theme.colors.textColor);
	}, function (_ref3) {
	  var theme = _ref3.theme;
	  return theme.colors.textColor;
	}, function (props) {
	  return props.href ? 'cursor: pointer' : null;
	}, function (_ref4) {
	  var theme = _ref4.theme;
	  return theme.colors.backgroundColor ? curriedLighten(0.2, theme.colors.backgroundColor) : '#fdfefd';
	}, function (props) {
	  if (props.image) {
	    return props.small ? 'calc(100% - 100px)' : 'calc(100% - 160px)';
	  }
	  return '100%';
	}, function (props) {
	  return props.image ? '10px' : 0;
	});

	var ResultListWrapper = {
	  name: 'ResultListWrapper',
	  functional: true,
	  render: function render(_, _ref) {
	    var props = _ref.props,
	      children = _ref.children;
	    var h = arguments[0];
	    return h("div", helper$1([{
	      "attrs": {
	        "className": container
	      }
	    }, props]), [children]);
	  }
	};
	ResultListWrapper.install = function (Vue) {
	  Vue.component(ResultListWrapper.name, ResultListWrapper);
	};

	var _templateObject$4, _templateObject2$2, _templateObject3$2;
	var container$1 = css(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteralLoose(["\n\tdisplay: flex;\n\tflex-direction: row;\n\tjustify-content: center;\n\tflex-wrap: wrap;\n\tmargin: 0 -8px;\n\n\t@media (max-width: 420px) {\n\t\tmargin: 0;\n\t}\n"])));
	var Image$1 = index$1('div')(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteralLoose(["\n\twidth: calc(100% + 20px);\n\theight: 220px;\n\tmargin: -10px -10px 0;\n\tbackground-color: ", ";\n\tbackground-size: contain;\n\tbackground-position: center center;\n\tbackground-repeat: no-repeat;\n"])), function (_ref) {
	  var colors = _ref.theme.colors;
	  return colors.backgroundColor || '#fcfcfc';
	});
	var Card = index$1('a')(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteralLoose(["\n\twidth: auto;\n\tflex-grow: 1;\n\toutline: none;\n\ttext-decoration: none;\n\tmin-width: 240px;\n\tmax-width: 250px;\n\tborder-radius: 0.25rem;\n\tbackground-color: ", ";\n\theight: 300px;\n\tdisplay: flex;\n\tflex-direction: column;\n\tjustify-content: space-between;\n\tmargin: 8px;\n\tpadding: 10px;\n\toverflow: hidden;\n\tbox-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.2);\n\tcolor: ", ";\n\t", ";\n\ttransition: all 0.3s ease;\n\n\th2 {\n\t\twidth: 100%;\n\t\tfont-size: 0.9rem;\n\t\tline-height: 1.2rem;\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t\tmargin: 0;\n\t\tpadding: 10px 0 8px;\n\t}\n\n\tp {\n\t\tmargin: 0;\n\t}\n\n\tarticle {\n\t\tflex-grow: 1;\n\t\tfont-size: 0.9rem;\n\t}\n\n\t&:hover,\n\t&:focus {\n\t\tbox-shadow: 0 0 8px 1px rgba(0, 0, 0, 0.3);\n\t}\n\n\t@media (max-width: 420px) {\n\t\twidth: 50%;\n\t\tmin-width: 0;\n\t\theight: 210px;\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tbox-shadow: none;\n\t\tborder: 1px solid #eee;\n\n\t\t&:hover,\n\t\t&:focus {\n\t\t\tbox-shadow: 0;\n\t\t}\n\t}\n"])), function (_ref2) {
	  var theme = _ref2.theme;
	  return theme.colors.backgroundColor ? curriedLighten(0.1, theme.colors.backgroundColor) : '#fff';
	}, function (_ref3) {
	  var theme = _ref3.theme;
	  return theme.colors.textColor;
	}, function (props) {
	  return props.href ? 'cursor: pointer' : null;
	});

	var ResultCardsWrapper = {
	  name: 'ResultCardsWrapper',
	  functional: true,
	  render: function render(_, _ref) {
	    var props = _ref.props,
	      children = _ref.children;
	    var h = arguments[0];
	    return h("div", helper$1([{
	      "attrs": {
	        "className": container$1
	      }
	    }, props]), [children]);
	  }
	};
	ResultCardsWrapper.install = function (Vue) {
	  Vue.component(ResultCardsWrapper.name, ResultCardsWrapper);
	};

	var _templateObject$5, _templateObject2$3, _templateObject3$3, _templateObject4$2, _templateObject5$1, _templateObject6$1, _templateObject7$1, _templateObject8$1, _templateObject9, _templateObject10, _templateObject11;
	var leftLabel = css(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteralLoose(["\n\tflex-direction: row;\n\talign-items: center;\n"])));
	var rightLabel = css(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteralLoose(["\n\tflex-direction: row-reverse;\n\talign-items: center;\n"])));
	var topLabel = css(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteralLoose(["\n\tflex-direction: column;\n"])));
	var bottomLabel = css(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteralLoose(["\n\tflex-direction: column-reverse;\n"])));
	var border = function border(_ref) {
	  var colors = _ref.theme.colors;
	  return css(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteralLoose(["\n\tborder: 1px solid ", ";\n"])), colors.borderColor || '#ccc');
	};
	var Flex = index$1('div')(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteralLoose(["\n\tdisplay: ", ";\n\t", ";\n\t", ";\n\t", ";\n\t", ";\n\t", ";\n\n\t", ";\n\t", ";\n\n\t", ";\n\t", ";\n\t", ";\n\n\tsvg.cancel-icon {\n\t\tcursor: pointer;\n\t\tfill: ", ";\n\t\tflex-basis: 30px;\n\n\t\t&:hover {\n\t\t\tfill: ", ";\n\t\t}\n\t}\n"])), function (props) {
	  return props.inline ? 'inline-flex' : 'flex';
	}, function (props) {
	  return (props.labelPosition === 'left' || props.iconPosition === 'right') && leftLabel;
	}, function (props) {
	  return (props.labelPosition === 'right' || props.iconPosition === 'left') && rightLabel;
	}, function (props) {
	  return props.labelPosition === 'top' && topLabel;
	}, function (props) {
	  return props.labelPosition === 'bottom' && bottomLabel;
	}, function (props) {
	  return props.showBorder && border;
	}, function (props) {
	  return props.justifyContent && css(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteralLoose(["\n\t\t\tjustify-content: ", ";\n\t\t"])), props.justifyContent);
	}, function (props) {
	  return props.alignItems && css(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteralLoose(["\n\t\t\talign-items: ", ";\n\t\t"])), props.alignItems);
	}, function (props) {
	  return props.flex && css(_templateObject9 || (_templateObject9 = _taggedTemplateLiteralLoose(["\n\t\t\tflex: ", ";\n\t\t"])), props.flex);
	}, function (props) {
	  return props.direction && css(_templateObject10 || (_templateObject10 = _taggedTemplateLiteralLoose(["\n\t\t\tflex-direction: ", ";\n\t\t"])), props.direction);
	}, function (props) {
	  return props.basis && css(_templateObject11 || (_templateObject11 = _taggedTemplateLiteralLoose(["\n\t\t\tflex-basis: ", ";\n\t\t"])), props.basis);
	}, function (_ref2) {
	  var colors = _ref2.theme.colors;
	  return colors.borderColor || curriedLighten(0.3, colors.textColor);
	}, function (_ref3) {
	  var theme = _ref3.theme;
	  return theme.colors.textColor;
	});

	var _templateObject$6, _templateObject2$4;
	var resultStats = css(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteralLoose(["\n\tflex-grow: 1;\n\tfont-size: 0.82rem;\n"])));
	var sortOptions = css(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteralLoose(["\n\tcolor: #424242;\n\theight: 32px;\n\tfont-size: 0.82rem;\n\tpadding: 0 25px 0 10px;\n\tbackground: url(data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0Ljk1IDEwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6IzQ0NDt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPmFycm93czwvdGl0bGU+PHJlY3QgY2xhc3M9ImNscy0xIiB3aWR0aD0iNC45NSIgaGVpZ2h0PSIxMCIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSIxLjQxIDQuNjcgMi40OCAzLjE4IDMuNTQgNC42NyAxLjQxIDQuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTIiIHBvaW50cz0iMy41NCA1LjMzIDIuNDggNi44MiAxLjQxIDUuMzMgMy41NCA1LjMzIi8+PC9zdmc+)\n\t\tno-repeat 95% 50%;\n\tbackground-color: #fff;\n\t-moz-appearance: none;\n\t-webkit-appearance: none;\n\tappearance: none;\n\t-webkit-border-radius: 0;\n\tborder-radius: 0;\n\tborder: 0;\n\toutline: 1px solid #ddd;\n\toutline-offset: -1px;\n"])));

	var recordImpressions = lib_5.recordImpressions;
	var isEqual$1 = lib_8.isEqual;
	var debounce = function debounce(method, delay) {
	  clearTimeout(method._tId);
	  // eslint-disable-next-line
	  method._tId = setTimeout(function () {
	    method();
	  }, delay);
	};
	var ImpressionTracker = {
	  name: 'ImpressionTracker',
	  inject: ['$$store'],
	  props: {
	    hits: types.hits
	  },
	  created: function created() {
	    // Represents the list of hits returned by the query
	    this.currentHits = []; // An array of hits objects
	    // An object to track the recorded impressions
	    // It can have the values in following shape
	    // { "hit_id": { "index": "test" }}
	    this.trackedIds = {};
	    // An object to know the the un-tracked impression i.e not recorded by BE
	    // It can have the values in following shape
	    // { "query_id": [{ "id": "hit_id", "index": "test"}]}
	    this.waitingToBeTracked = {};
	  },
	  mounted: function mounted() {
	    this.setCurrentHits(this.hits);
	    // Add scroll events to track the impressions
	    if (window) {
	      window.addEventListener('scroll', this.tracker);
	    }
	  },
	  destroy: function destroy() {
	    // Clear the interval
	    this.clearTrackerInterval();
	  },
	  watch: {
	    hits: function hits(newVal, oldVal) {
	      if (newVal && newVal !== oldVal) {
	        // Only compare hit ids for performance reasons
	        var prevHitIds = oldVal.map(function (hit) {
	          return hit._id;
	        });
	        var currentHitIds = newVal.map(function (hit) {
	          return hit._id;
	        });
	        if (!isEqual$1(currentHitIds, prevHitIds)) {
	          this.setCurrentHits(newVal);
	        }
	      }
	    }
	  },
	  methods: {
	    inViewPort: function inViewPort(el) {
	      var rect = el.getBoundingClientRect();
	      return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
	    },
	    setCurrentHits: function setCurrentHits(hits) {
	      this.currentHits = hits;
	      // Reset the tracked Ids for new hits
	      this.trackedIds = {};
	      if (hits && hits.length) {
	        this.tracker();
	        // Run the tracker function on an interval of 1s to track the impressions for
	        // non-scroll views for e.g on tab change
	        this.setTrackerInterval();
	      }
	    },
	    recordImpression: function recordImpression() {
	      var _this = this;
	      if (Object.keys(this.waitingToBeTracked).length) {
	        var unTrackedHits = _extends({}, this.waitingToBeTracked);
	        Object.keys(unTrackedHits).forEach(function (queryId) {
	          if (unTrackedHits[queryId] && unTrackedHits[queryId].length) {
	            _this.trackImpressions(queryId, unTrackedHits[queryId]);
	            // Removed tracked impressions from waiting list
	            delete _this.waitingToBeTracked[queryId];
	          }
	        });
	      }
	    },
	    addToWaitingList: function addToWaitingList(hitObject) {
	      var queryId = this.getQueryId();
	      if (hitObject && queryId) {
	        var impression = {
	          id: hitObject._id,
	          index: hitObject._index
	        };
	        // Check if query id already present in waiting list
	        if (this.waitingToBeTracked[queryId]) {
	          this.waitingToBeTracked[queryId].push(impression);
	        } else {
	          this.waitingToBeTracked[queryId] = [impression];
	        }
	      }
	    },
	    tracker: function tracker() {
	      var _this2 = this;
	      if (!this.getHitIds().length) {
	        this.clearTrackerInterval();
	        return;
	      }
	      // only run at client-side
	      if (window && document) {
	        this.getHitIds().forEach(function (id) {
	          var element = document.getElementById(id);
	          if (element) {
	            if (_this2.inViewPort(element)) {
	              // Add the hit id in the list of tracked ids
	              var hitObject = _this2.currentHits.find(function (hit) {
	                return hit._id === id;
	              });
	              _this2.trackedIds[id] = true;
	              // Add hit to waiting list to be recorded
	              _this2.addToWaitingList(hitObject);
	            }
	          }
	        });
	      }
	      debounce(this.recordImpression, 300);
	    },
	    setTrackerInterval: function setTrackerInterval() {
	      this.intervalID = setInterval(this.tracker, 1000);
	    },
	    clearTrackerInterval: function clearTrackerInterval() {
	      if (this.intervalID) {
	        clearInterval(this.intervalID);
	        // Reset interval ID
	        this.intervalID = null;
	      }
	    },
	    getQueryId: function getQueryId() {
	      var state = this.$$store ? this.$$store.getState() : null;
	      return state ? state.analytics.searchId : null;
	    },
	    getHitIds: function getHitIds() {
	      var _this3 = this;
	      return this.currentHits.map(function (hit) {
	        return hit._id;
	      }).filter(function (id) {
	        return !_this3.trackedIds[id];
	      });
	    }
	  },
	  render: function render() {
	    return this.$slots["default"];
	  }
	};
	var mapDispatchToProps$1 = {
	  trackImpressions: recordImpressions
	};
	var ImpressionTracker$1 = connect(function () {
	  return null;
	}, mapDispatchToProps$1)(ImpressionTracker);

	var setQueryOptions = lib_5.setQueryOptions,
	  updateQuery = lib_5.updateQuery,
	  loadMore = lib_5.loadMore,
	  setValue = lib_5.setValue,
	  updateComponentProps$1 = lib_5.updateComponentProps,
	  setDefaultQuery = lib_5.setDefaultQuery,
	  recordResultClick = lib_5.recordResultClick;
	var isEqual$2 = lib_8.isEqual,
	  getQueryOptions = lib_8.getQueryOptions,
	  getClassName$1 = lib_8.getClassName,
	  parseHits = lib_8.parseHits,
	  getCompositeAggsQuery = lib_8.getCompositeAggsQuery,
	  getResultStats = lib_8.getResultStats,
	  extractQueryFromCustomQuery = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery = lib_8.getOptionsForCustomQuery;
	var ReactiveList = {
	  name: 'ReactiveList',
	  components: {
	    ResultListWrapper: ResultListWrapper,
	    ResultCardsWrapper: ResultCardsWrapper
	  },
	  data: function data() {
	    var currentPageState = 0;
	    var defaultPage = this.defaultPage || -1;
	    if (defaultPage >= 0) {
	      currentPageState = defaultPage;
	    } else if (this.currentPage) {
	      currentPageState = Math.max(this.currentPage - 1, 0);
	    }
	    this.__state = {
	      from: currentPageState * this.size,
	      currentPageState: currentPageState
	    };
	    return this.__state;
	  },
	  created: function created() {
	    var _this = this;
	    var _this$$props = this.$props,
	      distinctField = _this$$props.distinctField,
	      distinctFieldConfig = _this$$props.distinctFieldConfig,
	      index = _this$$props.index;
	    // no support for pagination and aggregationField together
	    if (this.pagination && this.aggregationField) {
	      console.warn('Pagination is not supported when aggregationField is present. The list will be rendered with infinite scroll');
	    }
	    if (this.enableAppbase && this.aggregationField && this.aggregationField !== '') {
	      console.warn('Warning(ReactiveSearch): The `aggregationField` prop has been marked as deprecated, please use the `distinctField` prop instead.');
	    }
	    if (!this.enableAppbase && (distinctField || distinctFieldConfig)) {
	      console.warn('Warning(ReactiveSearch): In order to use the `distinctField` and `distinctFieldConfig` props, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    if (!this.enableAppbase && index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    var defaultPage = this.defaultPage || -1;
	    if (defaultPage >= 0) {
	      this.currentPageState = defaultPage;
	      this.from = this.currentPageState * this.$props.size;
	    }
	    this.internalComponent = this.$props.componentId + "__internal";
	    this.sortOptionIndex = 0;
	    if (this.defaultSortOption && this.sortOptions && Array.isArray(this.sortOptions)) {
	      this.sortOptionIndex = this.sortOptions.findIndex(function (s) {
	        return s.label === _this.defaultSortOption;
	      });
	    }
	    if (this.urlSortOption) {
	      this.sortOptionIndex = this.$props.sortOptions.findIndex(function (s) {
	        return s.label === _this.urlSortOption;
	      }) || 0;
	    }
	    this.updateComponentProps(this.componentId, {
	      from: this.from
	    }, constants_1$1.reactiveList);
	    this.updateComponentProps(this.internalComponent, {
	      from: this.from
	    }, constants_1$1.reactiveList);
	  },
	  props: {
	    currentPage: VueTypes.number.def(0),
	    includeFields: types.includeFields,
	    // component props
	    className: types.string,
	    componentId: types.stringRequired,
	    dataField: types.stringRequired,
	    aggregationField: types.string,
	    aggregationSize: VueTypes.number,
	    defaultQuery: types.func,
	    defaultSortOption: types.string,
	    excludeFields: types.excludeFields,
	    innerClass: types.style,
	    listClass: VueTypes.string.def(''),
	    loader: types.title,
	    render: types.func,
	    renderItem: types.func,
	    renderNoResults: VueTypes.any.def('No Results found.'),
	    renderError: types.title,
	    renderResultStats: types.func,
	    pages: VueTypes.number.def(5),
	    pagination: VueTypes.bool.def(false),
	    infiniteScroll: VueTypes.bool.def(true),
	    paginationAt: VueTypes.oneOf(['top', 'bottom', 'both']).def('bottom'),
	    react: types.react,
	    scrollOnChange: VueTypes.bool.def(true),
	    showResultStats: VueTypes.bool.def(true),
	    showEndPage: VueTypes.bool.def(false),
	    size: VueTypes.number.def(10),
	    sortBy: types.sortBy,
	    sortOptions: types.sortOptions,
	    URLParams: VueTypes.bool.def(false),
	    prevLabel: types.string,
	    nextLabel: types.string,
	    distinctField: types.string,
	    distinctFieldConfig: types.props,
	    index: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  computed: {
	    shouldRenderPagination: function shouldRenderPagination() {
	      return this.pagination && !this.aggregationField;
	    },
	    totalPages: function totalPages() {
	      return Math.ceil(this.total / this.$props.size) || 0;
	    },
	    hasPageChangeListener: function hasPageChangeListener() {
	      return this.$listeners && this.$listeners.pageChange;
	    },
	    hasResultStatsListener: function hasResultStatsListener() {
	      return this.$listeners && this.$listeners.resultStats;
	    },
	    stats: function stats() {
	      return _extends({}, getResultStats(this), {
	        currentPage: this.currentPageState,
	        displayedResults: this.data.length
	      });
	    },
	    hasCustomRender: function hasCustomRender() {
	      return hasCustomRenderer(this);
	    },
	    showInfiniteScroll: function showInfiniteScroll() {
	      // Pagination has higher priority then infinite scroll
	      return this.infiniteScroll && !this.shouldRenderPagination;
	    },
	    data: function data() {
	      var results = parseHits(this.hits) || [];
	      var parsedPromotedResults = parseHits(this.promotedResults) || [];
	      var filteredResults = results;
	      if (parsedPromotedResults.length) {
	        var ids = parsedPromotedResults.map(function (item) {
	          return item._id;
	        }).filter(Boolean);
	        if (ids) {
	          filteredResults = filteredResults.filter(function (item) {
	            return !ids.includes(item._id);
	          });
	        }
	        filteredResults = [].concat(parsedPromotedResults, filteredResults);
	      }
	      return helper_15(filteredResults);
	    }
	  },
	  watch: {
	    sortOptions: function sortOptions(newVal, oldVal) {
	      if (!isEqual$2(oldVal, newVal)) {
	        this.updateQueryOptions(this.$props);
	      }
	    },
	    sortBy: function sortBy(newVal, oldVal) {
	      if (oldVal !== newVal) {
	        this.updateQueryOptions(this.$props);
	      }
	    },
	    size: function size(newVal, oldVal) {
	      if (oldVal !== newVal) {
	        this.updateQueryOptions(this.$props);
	      }
	    },
	    dataField: function dataField(newVal, oldVal) {
	      if (oldVal !== newVal) {
	        this.updateQueryOptions(this.$props);
	      }
	    },
	    includeFields: function includeFields(newVal, oldVal) {
	      if (oldVal !== newVal) {
	        this.updateQueryOptions(this.$props);
	      }
	    },
	    excludeFields: function excludeFields(newVal, oldVal) {
	      if (oldVal !== newVal) {
	        this.updateQueryOptions(this.$props);
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, null, this.$props)) {
	        var options = getQueryOptions(this.$props);
	        options.from = 0;
	        this.$defaultQuery = newVal(null, this.$props);
	        var query = extractQueryFromCustomQuery(this.$defaultQuery);
	        var queryOptions = getOptionsForCustomQuery(this.$defaultQuery);
	        if (queryOptions) {
	          options = _extends({}, options, queryOptions);
	        }
	        // Update calculated default query in store
	        updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props);
	        this.setQueryOptions(this.$props.componentId, _extends({}, options, this.getAggsQuery()), !query);
	        this.updateQuery({
	          componentId: this.internalComponent,
	          query: query
	        }, true); // reset page because of query change
	        this.currentPageState = 0;
	        this.from = 0;
	      }
	    },
	    promotedResults: function promotedResults(newVal, oldVal) {
	      if (!isEqual$2(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    hidden: function hidden(newVal, oldVal) {
	      if (!isEqual$2(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    time: function time(newVal, oldVal) {
	      if (!isEqual$2(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    hits: function hits(newVal, oldVal) {
	      this.$emit('data', this.getData());
	      if (this.shouldRenderPagination) {
	        // called when page is changed
	        if (this.isLoading && (oldVal || newVal)) {
	          if (this.hasPageChangeListener) {
	            this.$emit('pageChange', this.currentPageState + 1, this.totalPages);
	            this.$emit('page-change', this.currentPageState + 1, this.totalPages);
	          } else if (this.scrollOnChange) {
	            window.scrollTo(0, 0);
	          }
	        }
	      } else if (oldVal && newVal) {
	        if (oldVal.length !== newVal.length || newVal.length === this.$props.total) {
	          if (newVal.length < oldVal.length) {
	            // query has changed
	            if (this.scrollOnChange) {
	              window.scrollTo(0, 0);
	            }
	            this.from = 0;
	          }
	        }
	      }
	    },
	    rawData: function rawData(newVal, oldVal) {
	      if (!isEqual$2(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    currentPage: function currentPage(newVal, oldVal) {
	      if (oldVal !== newVal && newVal > 0 && newVal <= this.totalPages) {
	        this.setPage(newVal - 1);
	      }
	    },
	    infiniteScroll: function infiniteScroll(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        if (newVal && !this.pagination) {
	          window.addEventListener('scroll', this.scrollHandler);
	        } else {
	          window.removeEventListener('scroll', this.scrollHandler);
	        }
	      }
	    },
	    pagination: function pagination(newVal, oldVal) {
	      if (newVal !== oldVal) {
	        if (!newVal && this.infiniteScroll) {
	          window.addEventListener('scroll', this.scrollHandler);
	        } else {
	          window.removeEventListener('scroll', this.scrollHandler);
	        }
	      } // handle window url history change (on native back and forth interactions)
	    },
	    defaultPage: function defaultPage(newVal, oldVal) {
	      if (this.currentPageState !== newVal && oldVal !== newVal) {
	        this.setPage(newVal >= 0 ? newVal : 0);
	      }
	    }
	  },
	  mounted: function mounted() {
	    if (this.defaultPage < 0 && this.currentPage > 0) {
	      this.setPageURL(this.$props.componentId, this.currentPage, this.$props.componentId, false, this.URLParams);
	    }
	    var options = getQueryOptions(this.$props);
	    options.from = this.$data.from;
	    if (this.sortOptions && this.sortOptions[this.sortOptionIndex]) {
	      var _ref;
	      var sortField = this.sortOptions[this.sortOptionIndex].dataField;
	      var sortBy = this.sortOptions[this.sortOptionIndex].sortBy;
	      options.sort = [(_ref = {}, _ref[sortField] = {
	        order: sortBy
	      }, _ref)];
	      // To handle sort options for RS API
	      this.updateComponentProps(this.componentId, {
	        dataField: sortField,
	        sortBy: sortBy
	      }, constants_1$1.reactiveList);
	    } else if (this.$props.sortBy) {
	      var _ref2;
	      options.sort = [(_ref2 = {}, _ref2[this.$props.dataField] = {
	        order: this.$props.sortBy
	      }, _ref2)];
	    } // Override sort query with defaultQuery's sort if defined

	    this.$defaultQuery = null;
	    if (this.$props.defaultQuery) {
	      this.$defaultQuery = this.$props.defaultQuery();
	      options = _extends({}, options, getOptionsForCustomQuery(this.$defaultQuery));

	      // Update calculated default query in store
	      updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props);
	    }
	    // execute is set to false at the time of mount
	    var query = extractQueryFromCustomQuery(this.$defaultQuery);
	    var execute = false;
	    this.setQueryOptions(this.$props.componentId, _extends({}, options, this.getAggsQuery()), execute);
	    if (this.$defaultQuery) {
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query
	      }, execute);
	    } else {
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: null
	      }, execute);
	    } // query will be executed here

	    if (this.showInfiniteScroll) {
	      window.addEventListener('scroll', this.scrollHandler);
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.showInfiniteScroll) {
	      window.removeEventListener('scroll', this.scrollHandler);
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var hits = this.$data.hits;
	    var results = parseHits(hits) || [];
	    return h("div", {
	      "style": this.$props.style,
	      "class": this.$props.className
	    }, [this.isLoading && this.shouldRenderPagination && this.showInfiniteScroll && (this.$scopedSlots.loader || this.$props.loader), this.renderErrorComponent(), h(Flex, {
	      "attrs": {
	        "labelPosition": this.sortOptions ? 'right' : 'left'
	      },
	      "class": getClassName$1(this.$props.innerClass, 'resultsInfo')
	    }, [this.sortOptions ? this.renderSortOptions() : null, this.$props.showResultStats && results.length ? this.renderStats() : null]), !this.isLoading && hits && hits.length === 0 ? this.renderNoResult() : null, this.shouldRenderPagination && (this.$props.paginationAt === 'top' || this.$props.paginationAt === 'both') ? h(Pagination, {
	      "attrs": {
	        "pages": this.$props.pages,
	        "totalPages": this.totalPages,
	        "currentPage": this.currentPageState,
	        "setPage": this.setPage,
	        "innerClass": this.$props.innerClass,
	        "prevLabel": this.$props.prevLabel,
	        "nextLabel": this.$props.nextLabel
	      }
	    }) : null, this.renderResults(), this.isLoading && !this.shouldRenderPagination ? this.$scopedSlots.loader || this.$props.loader || h("div", {
	      "style": {
	        textAlign: 'center',
	        margin: '20px 0',
	        color: '#666'
	      }
	    }, ["Loading..."]) : null, this.shouldRenderPagination && (this.$props.paginationAt === 'bottom' || this.$props.paginationAt === 'both') ? h(Pagination, {
	      "attrs": {
	        "pages": this.$props.pages,
	        "totalPages": Math.ceil(this.$data.total / this.$props.size),
	        "currentPage": this.currentPageState,
	        "setPage": this.setPage,
	        "showEndPage": this.$props.showEndPage,
	        "innerClass": this.$props.innerClass,
	        "prevLabel": this.$props.prevLabel,
	        "nextLabel": this.$props.nextLabel
	      }
	    }) : null, this.url.endsWith('appbase.io') && results.length ? h(Flex, {
	      "attrs": {
	        "direction": "row-reverse"
	      },
	      "class": getClassName$1(this.$props.innerClass, 'poweredBy')
	    }, [h(PoweredBy)]) : null]);
	  },
	  methods: {
	    renderErrorComponent: function renderErrorComponent() {
	      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
	      if (renderError && this.error && !this.isLoading) {
	        return isFunction$1(renderError) ? renderError(this.error) : renderError;
	      }
	      return null;
	    },
	    renderResults: function renderResults() {
	      var _this2 = this;
	      var h = this.$createElement;
	      var size = this.$props.size;
	      var renderItem = this.$scopedSlots.renderItem || this.$props.renderItem;
	      var element = this.hasCustomRender ? this.getComponent() : h("div", {
	        "class": this.$props.listClass + " " + getClassName$1(this.$props.innerClass, 'list')
	      }, [this.data.map(function (item, index) {
	        return renderItem({
	          item: item,
	          count: _this2.currentPageState * size + index + 1,
	          triggerClickAnalytics: function triggerClickAnalytics() {
	            return _this2.triggerClickAnalytics(_this2.currentPageState * size + index);
	          }
	        });
	      })]);
	      // If analytics is set to true then render with impression tracker
	      return this.analytics ? h(ImpressionTracker$1, {
	        "attrs": {
	          "hits": this.data
	        }
	      }, [element]) : element;
	    },
	    updateQueryOptions: function updateQueryOptions(props) {
	      var options = getQueryOptions(props);
	      options.from = this.$data.from;
	      if (props.sortOptions && Array.isArray(props.sortOptions)) {
	        var sortOptionIndex = props.defaultSortOption ? props.sortOptions.findIndex(function (s) {
	          return s.label === props.defaultSortOption;
	        }) : 0;
	        if (props.sortOptions[sortOptionIndex]) {
	          var _ref3;
	          options.sort = [(_ref3 = {}, _ref3[props.sortOptions[sortOptionIndex].dataField] = {
	            order: props.sortOptions[sortOptionIndex].sortBy
	          }, _ref3)];
	        }
	      } else if (props.sortBy) {
	        var _ref4;
	        options.sort = [(_ref4 = {}, _ref4[props.dataField] = {
	          order: props.sortBy
	        }, _ref4)];
	      }
	      this.setQueryOptions(this.$props.componentId, _extends({}, options, this.getAggsQuery()), true);
	    },
	    getAggsQuery: function getAggsQuery() {
	      var _this$$props2 = this.$props,
	        size = _this$$props2.size,
	        aggregationField = _this$$props2.aggregationField;
	      var afterKey = this.$data.afterKey;
	      var queryOptions = {
	        size: size
	      };
	      if (aggregationField) {
	        queryOptions.aggs = getCompositeAggsQuery({
	          props: this.$props,
	          after: afterKey || null,
	          showTopHits: true
	        }).aggs;
	      }
	      return queryOptions;
	    },
	    scrollHandler: function scrollHandler() {
	      if (!this.isLoading && window.innerHeight + window.pageYOffset + 300 >= document.body.scrollHeight) {
	        this.loadMore();
	      }
	    },
	    loadMore: function loadMore() {
	      if (this.aggregationField && !this.afterKey) return;
	      if (this.hits && !this.shouldRenderPagination && this.total > this.hits.length) {
	        var value = this.$data.from + this.$props.size;
	        // If current hits length is less than the current from then it means
	        // that there are no results present.
	        // It can happen because of many reasons some of them are:
	        // 1. Using the `collapse` query to remove results
	        // 2. Shard failure
	        // In above cases infinite scroll should not load more results that can
	        // cause the resetting of the `from` value

	        if (this.hits.length < value) {
	          return;
	        }
	        var options = _extends({}, getQueryOptions(this.$props), this.getAggsQuery());
	        this.from = value;
	        // Update default query to support pagination for aggregationField
	        updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props);
	        this.loadMoreAction(this.$props.componentId, _extends({}, options, {
	          from: value
	        }), true, !!this.aggregationField);
	      }
	    },
	    setPage: function setPage(page) {
	      // pageClick will be called every time a pagination button is clicked
	      if (page !== this.currentPageState) {
	        this.$emit('pageClick', page + 1);
	        this.$emit('page-click', page + 1);
	        var value = this.$props.size * page;
	        var options = getQueryOptions(this.$props);
	        options.from = this.$data.from;
	        this.from = value;
	        this.currentPageState = page;
	        this.loadMoreAction(this.$props.componentId, _extends({}, options, {
	          from: value
	        }), false);
	        this.setPageURL(this.$props.componentId, page + 1, this.$props.componentId, false, this.URLParams);
	      }
	    },
	    renderStats: function renderStats() {
	      var h = this.$createElement;
	      var renderResultStats = this.$scopedSlots.renderResultStats || this.$props.renderResultStats;
	      if (renderResultStats && this.$data.total) {
	        return renderResultStats(this.stats);
	      }
	      if (this.stats.numberOfResults) {
	        return h("p", {
	          "class": resultStats + " " + getClassName$1(this.$props.innerClass, 'resultStats')
	        }, [this.stats.numberOfResults, " results found in ", this.stats.time || 0, "ms"]);
	      }
	      return null;
	    },
	    renderNoResult: function renderNoResult() {
	      var h = this.$createElement;
	      var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
	      if (this.$scopedSlots.renderNoResults) {
	        return isFunction$1(renderNoResults) ? renderNoResults() : renderNoResults;
	      }
	      return h("p", {
	        "class": getClassName$1(this.$props.innerClass, 'noResults') || null
	      }, [isFunction$1(renderNoResults) ? renderNoResults() : renderNoResults]);
	    },
	    handleSortChange: function handleSortChange(e) {
	      var index = e.target.value;
	      if (this.sortOptions && this.sortOptions[index]) {
	        var _ref5;
	        // This fixes issue #371 (where sorting a multi-result page with infinite loader breaks)
	        var options = getQueryOptions(this.$props);
	        options.from = 0;
	        var sortField = this.sortOptions[index].dataField;
	        var sortBy = this.sortOptions[index].sortBy;
	        options.sort = [(_ref5 = {}, _ref5[sortField] = {
	          order: sortBy
	        }, _ref5)];
	        this.sortOptionIndex = index;
	        // To handle sort options for RS API
	        this.updateComponentProps(this.componentId, {
	          dataField: sortField,
	          sortBy: sortBy
	        }, constants_1$1.reactiveList);
	        this.setQueryOptions(this.$props.componentId, options, true);
	        this.setPage(0);
	        this.currentPageState = 0;
	        this.from = 0;
	        var sortOption = this.$props.sortOptions[this.sortOptionIndex] ? this.$props.sortOptions[this.sortOptionIndex].label : null;
	        this.setPageURL(this.$props.componentId + "sortOption", sortOption, this.$props.componentId + "sortOption", false, this.$props.URLParams);
	      }
	    },
	    triggerClickAnalytics: function triggerClickAnalytics(searchPosition, documentId) {
	      var docId = documentId;
	      if (!docId) {
	        var _this$getData = this.getData(),
	          data = _this$getData.data;
	        var hitData = data.find(function (hit) {
	          return hit._click_id === searchPosition;
	        });
	        if (hitData && hitData._id) {
	          docId = hitData._id;
	        }
	      }
	      this.recordResultClick(searchPosition, docId);
	    },
	    renderSortOptions: function renderSortOptions() {
	      var h = this.$createElement;
	      return h("select", {
	        "class": sortOptions + " " + getClassName$1(this.$props.innerClass, 'sortOptions'),
	        "attrs": {
	          "name": "sort-options",
	          "aria-label": "Sort options"
	        },
	        "on": {
	          "change": this.handleSortChange
	        },
	        "domProps": {
	          "value": this.sortOptionIndex
	        }
	      }, [this.sortOptions.map(function (sort, index) {
	        return h("option", {
	          "key": sort.label,
	          "domProps": {
	            "value": index
	          }
	        }, [sort.label]);
	      })]);
	    },
	    withClickIds: function withClickIds(results) {
	      var _this$getAllData = this.getAllData(),
	        base = _this$getAllData.base;
	      return results.map(function (result, index) {
	        return _extends({}, result, {
	          _click_id: base + index
	        });
	      });
	    },
	    // Shape of the object to be returned in onData & render
	    getAllData: function getAllData() {
	      var size = this.size,
	        promotedResults = this.promotedResults,
	        aggregationData = this.aggregationData,
	        customData = this.customData,
	        currentPage = this.currentPage,
	        hits = this.hits;
	      var results = parseHits(hits) || [];
	      var parsedPromotedResults = parseHits(promotedResults) || [];
	      var base = currentPage * size;
	      return {
	        results: results,
	        customData: customData || {},
	        promotedResults: parsedPromotedResults,
	        aggregationData: aggregationData,
	        loadMore: this.loadMore,
	        base: base,
	        triggerClickAnalytics: this.triggerClickAnalytics
	      };
	    },
	    getData: function getData() {
	      var _this$getAllData2 = this.getAllData(),
	        promotedResults = _this$getAllData2.promotedResults,
	        aggregationData = _this$getAllData2.aggregationData,
	        customData = _this$getAllData2.customData;
	      return {
	        data: this.data,
	        aggregationData: this.withClickIds(aggregationData || []),
	        promotedData: this.withClickIds(promotedResults || []),
	        rawData: this.rawData,
	        resultStats: this.stats,
	        customData: customData
	      };
	    },
	    getComponent: function getComponent$1() {
	      var error = this.error,
	        isLoading = this.isLoading;
	      var data = _extends({
	        error: error,
	        loading: isLoading || false,
	        loadMore: this.loadMore,
	        triggerClickAnalytics: this.triggerClickAnalytics,
	        setPage: this.setPage
	      }, this.getData());
	      return getComponent(data, this);
	    }
	  }
	};
	var mapStateToProps$1 = function mapStateToProps(state, props) {
	  return {
	    defaultPage: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value - 1,
	    urlSortOption: state.selectedValues[props.componentId + "sortOption"] && state.selectedValues[props.componentId + "sortOption"].value,
	    hits: state.hits[props.componentId] && state.hits[props.componentId].hits,
	    rawData: state.rawData[props.componentId],
	    aggregationData: state.compositeAggregations[props.componentId],
	    promotedResults: state.promotedResults[props.componentId],
	    customData: state.customData[props.componentId],
	    time: state.hits[props.componentId] && state.hits[props.componentId].time,
	    total: state.hits[props.componentId] && state.hits[props.componentId].total,
	    hidden: state.hits[props.componentId] && state.hits[props.componentId].hidden,
	    analytics: state.config && state.config.analytics,
	    enableAppbase: state.config.enableAppbase,
	    url: state.config.url,
	    error: state.error[props.componentId],
	    afterKey: state.aggregations[props.componentId] && state.aggregations[props.componentId][props.aggregationField] && state.aggregations[props.componentId][props.aggregationField].after_key,
	    componentProps: state.props[props.componentId],
	    isLoading: state.isLoading[props.componentId]
	  };
	};
	var mapDispatchtoProps = {
	  loadMoreAction: loadMore,
	  setPageURL: setValue,
	  setQueryOptions: setQueryOptions,
	  updateQuery: updateQuery,
	  updateComponentProps: updateComponentProps$1,
	  setDefaultQuery: setDefaultQuery,
	  recordResultClick: recordResultClick
	};
	// Only used for SSR
	ReactiveList.generateQueryOptions = function (props) {
	  var options = getQueryOptions(props);
	  var size = props.size,
	    dataField = props.dataField,
	    defaultSortOption = props.defaultSortOption,
	    sortOptionsNew = props.sortOptions,
	    currentPage = props.currentPage,
	    sortBy = props.sortBy;
	  options.from = currentPage ? (currentPage - 1) * (size || 10) : 0;
	  options.size = size || 10;
	  var getSortOption = function getSortOption() {
	    var _ref7;
	    if (defaultSortOption) {
	      var sortOption = sortOptionsNew.find(function (option) {
	        return option.label === defaultSortOption;
	      });
	      if (sortOption) {
	        var _ref6;
	        return _ref6 = {}, _ref6[sortOption.dataField] = {
	          order: sortOption.sortBy
	        }, _ref6;
	      }
	    }
	    return _ref7 = {}, _ref7[sortOptionsNew[0].dataField] = {
	      order: sortOptionsNew[0].sortBy
	    }, _ref7;
	  };
	  if (sortOptionsNew) {
	    options.sort = [getSortOption()];
	  } else if (sortBy) {
	    var _ref8;
	    options.sort = [(_ref8 = {}, _ref8[dataField] = {
	      order: sortBy
	    }, _ref8)];
	  }
	  return options;
	};
	ReactiveList.hasInternalComponent = function () {
	  return true;
	};
	var RLConnected = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$1, mapDispatchtoProps)(ReactiveList), {
	  componentType: constants_1$1.reactiveList,
	  internalComponent: ReactiveList.hasInternalComponent()
	}));
	RLConnected.name = ReactiveList.name;
	RLConnected.generateQueryOptions = ReactiveList.generateQueryOptions;
	RLConnected.hasInternalComponent = ReactiveList.hasInternalComponent;
	RLConnected.install = function (Vue) {
	  Vue.component(RLConnected.name, RLConnected);
	  Vue.component(ResultListWrapper.name, ResultListWrapper);
	  Vue.component(ResultCardsWrapper.name, ResultCardsWrapper);
	};
	// Add componentType for SSR
	RLConnected.componentType = constants_1$1.reactiveList;

	function URL$1(url) {
	  var pattern = RegExp("^(([^:/?#]*)?://)?(((.*)?@)?([^/?#]*)?)([^?#]*)(\\?([^#]*))?(#(.*))?");
	  var matches = url.match(pattern);
	  return {
	    protocol: matches[2],
	    auth: matches[5],
	    host: matches[6],
	    path: matches[7],
	    query: matches[9],
	    hash: matches[11]
	  };
	}
	var urlParserLite = URL$1;

	// Copyright Joyent, Inc. and other Node contributors.

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	var decode = function decode(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	      idx = x.indexOf(eq),
	      kstr,
	      vstr,
	      k,
	      v;
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	  return obj;
	};

	// Copyright Joyent, Inc. and other Node contributors.

	var stringifyPrimitive = function stringifyPrimitive(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	    case 'boolean':
	      return v ? 'true' : 'false';
	    case 'number':
	      return isFinite(v) ? v : '';
	    default:
	      return '';
	  }
	};
	var encode = function encode(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function (k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function (v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).filter(Boolean).join(sep);
	  }
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
	};

	var querystring = createCommonjsModule(function (module, exports) {

	  exports.decode = exports.parse = decode;
	  exports.encode = exports.stringify = encode;
	});
	var querystring_1 = querystring.decode;
	var querystring_2 = querystring.parse;
	var querystring_3 = querystring.encode;
	var querystring_4 = querystring.stringify;

	var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};
	function contains(string, substring) {
	  return string.indexOf(substring) !== -1;
	}
	function isAppbase(url) {
	  return contains(url, 'scalr.api.appbase.io');
	}
	function btoa$1() {
	  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	  var str = input;
	  var output = '';

	  // eslint-disable-next-line
	  for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1);
	  // eslint-disable-line no-bitwise
	  output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
	  ) {
	    charCode = str.charCodeAt(i += 3 / 4);
	    if (charCode > 0xff) {
	      throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
	    }
	    block = block << 8 | charCode; // eslint-disable-line no-bitwise
	  }

	  return output;
	}
	function validateRSQuery(query) {
	  if (query && Object.prototype.toString.call(query) === '[object Array]') {
	    for (var i = 0; i < query.length; i += 1) {
	      var q = query[i];
	      if (q) {
	        if (!q.id) {
	          return new Error("'id' field must be present in query object");
	        }
	      } else {
	        return new Error('query object can not have an empty value');
	      }
	    }
	    return true;
	  }
	  return new Error("invalid query value, 'query' value must be an array");
	}
	function validate(object, fields) {
	  var invalid = [];
	  var emptyFor = {
	    object: null,
	    string: '',
	    number: 0
	  };
	  var keys = Object.keys(fields);
	  keys.forEach(function (key) {
	    var types = fields[key].split('|');
	    var matchedType = types.find(function (type) {
	      return (
	        // eslint-disable-next-line
	        _typeof$1(object[key]) === type
	      );
	    });
	    if (!matchedType || object[key] === emptyFor[matchedType]) {
	      invalid.push(key);
	    }
	  });
	  var missing = '';
	  for (var i = 0; i < invalid.length; i += 1) {
	    missing += invalid[i] + ', ';
	  }
	  if (invalid.length > 0) {
	    return new Error('fields missing: ' + missing);
	  }
	  return true;
	}
	function removeUndefined() {
	  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  if (value || !(Object.keys(value).length === 0 && value.constructor === Object)) {
	    return JSON.parse(JSON.stringify(value));
	  }
	  return null;
	}
	function encodeHeaders() {
	  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var shouldEncode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	  // Encode headers
	  var encodedHeaders = {};
	  if (shouldEncode) {
	    Object.keys(headers).forEach(function (header) {
	      encodedHeaders[header] = encodeURI(headers[header]);
	    });
	  } else {
	    encodedHeaders = headers;
	  }
	  return encodedHeaders;
	}
	function getMongoRequest(app, mongo) {
	  var mongodb = {};
	  if (app) {
	    mongodb.index = app;
	  }
	  if (mongo) {
	    if (mongo.db) {
	      mongodb.db = mongo.db;
	    }
	    if (mongo.collection) {
	      mongodb.collection = mongo.collection;
	    }
	  }
	  return mongodb;
	}
	function getTelemetryHeaders(enableTelemetry, shouldSetHeaders) {
	  var headers = {};
	  if (!shouldSetHeaders) {
	    return headers;
	  }
	  Object.assign(headers, {
	    'X-Search-Client': 'Appbase JS'
	  });
	  if (enableTelemetry === false) {
	    Object.assign(headers, {
	      'X-Enable-Telemetry': enableTelemetry
	    });
	  }
	  return headers;
	}
	var backendAlias = {
	  MONGODB: 'mongodb',
	  // mongodb
	  ELASTICSEARCH: 'elasticsearch' // elasticsearch
	};

	var dataTypes = {
	  ARRAY: 'array',
	  FUNCTION: 'function',
	  OBJECT: 'object',
	  NUMBER: 'number',
	  BOOLEAN: 'boolean',
	  STRING: 'string'
	};
	var checkDataType = function checkDataType(temp) {
	  // eslint-disable-next-line
	  if ((typeof temp === 'undefined' ? 'undefined' : _typeof$1(temp)) === dataTypes.OBJECT) {
	    if (Array.isArray(temp)) {
	      return dataTypes.ARRAY;
	    }
	    return dataTypes.OBJECT;
	  }
	  return typeof temp === 'undefined' ? 'undefined' : _typeof$1(temp);
	};
	function validateSchema() {
	  var passedProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var backendName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	  var passedPropertiesKeys = Object.keys(passedProperties).filter(function (propertyKey) {
	    return !!passedProperties[propertyKey];
	  });
	  var acceptedProperties = Object.keys(schema);
	  var requiredProperties = [];
	  // fetch required properties
	  acceptedProperties.forEach(function (propName) {
	    var currentProperty = schema[propName];
	    if (currentProperty.required) {
	      requiredProperties.push(propName);
	    }
	  });
	  // check for required properties
	  requiredProperties.forEach(function (requiredProperty) {
	    if (!passedPropertiesKeys.includes(requiredProperty)) {
	      throw new Error(requiredProperty + ' is required when using the ' + backendName + ' Search backend.');
	    }
	  });

	  // check for accepted properties
	  passedPropertiesKeys.forEach(function (passedPropertyKey) {
	    if (!acceptedProperties.includes(passedPropertyKey)) {
	      throw new Error(passedPropertyKey + ' property isn\'t accepted property by ' + backendName + ' backend.');
	    }
	    var acceptedTypes = Array.isArray(schema[passedPropertyKey].type) ? schema[passedPropertyKey].type : [].concat(schema[passedPropertyKey].type);
	    var receivedPropertyType = checkDataType(passedProperties[passedPropertyKey]);
	    if (!acceptedTypes.includes(receivedPropertyType)) {
	      throw new Error('The property ' + passedPropertyKey + ' is expected with type(s) [' + acceptedTypes.join(', ') + '], but type was set as ' + receivedPropertyType + '.');
	    }
	  });
	}
	function isValidHttpUrl(string) {
	  var url = void 0;
	  try {
	    url = new URL(string);
	  } catch (_) {
	    return false;
	  }
	  return url.protocol === 'http:' || url.protocol === 'https:';
	}
	var mongodb = {
	  url: {
	    type: dataTypes.STRING,
	    required: true
	  },
	  app: {
	    type: dataTypes.STRING,
	    required: false
	  },
	  credentials: {
	    type: dataTypes.STRING,
	    required: false
	  },
	  enableTelemetry: {
	    type: dataTypes.BOOLEAN,
	    required: false
	  },
	  mongodb: {
	    type: dataTypes.OBJECT,
	    required: true
	  },
	  username: {
	    type: dataTypes.STRING,
	    required: false
	  },
	  password: {
	    type: dataTypes.STRING,
	    required: false
	  }
	};
	var elasticsearch = {
	  url: {
	    type: dataTypes.STRING,
	    required: true
	  },
	  app: {
	    type: dataTypes.STRING,
	    required: true
	  },
	  credentials: {
	    type: dataTypes.STRING,
	    required: false
	  },
	  enableTelemetry: {
	    type: dataTypes.BOOLEAN,
	    required: false
	  },
	  username: {
	    type: dataTypes.STRING,
	    required: false
	  },
	  password: {
	    type: dataTypes.STRING,
	    required: false
	  }
	};
	var SCHEMA = {
	  mongodb: mongodb,
	  elasticsearch: elasticsearch
	};

	/**
	 * Returns an instance of Appbase client
	 * @param {Object} config To configure properties
	 * @param {String} config.url
	 * @param {String} config.app
	 * @param {String} config.credentials
	 * @param {String} config.username
	 * @param {String} config.password
	 * @param {Boolean} config.enableTelemetry
	 * @param {Object} config.mongodb
	 * @param {Object} config.endpoint
	 * A callback function which will be invoked before a fetch request made
	 */
	function AppBase(config) {
	  var _URL = urlParserLite((config.endpoint ? config.endpoint.url : config.url) || ''),
	    _URL$auth = _URL.auth,
	    auth = _URL$auth === undefined ? null : _URL$auth,
	    _URL$host = _URL.host,
	    host = _URL$host === undefined ? '' : _URL$host,
	    _URL$path = _URL.path,
	    path = _URL$path === undefined ? '' : _URL$path,
	    _URL$protocol = _URL.protocol,
	    protocol = _URL$protocol === undefined ? '' : _URL$protocol;
	  var url = config.url;
	  url = host + path;
	  // Parse url
	  if (url.slice(-1) === '/') {
	    url = url.slice(0, -1);
	  }
	  var backendName = backendAlias[config.mongodb ? 'MONGODB' : 'ELASTICSEARCH'];
	  // eslint-disable-next-line
	  var schema = SCHEMA[backendName];
	  if (config.endpoint && isValidHttpUrl(config.endpoint.url)) {
	    schema.url.required = false;
	    schema.app.required = false;
	    schema.credentials.required = false;
	  }
	  validateSchema({
	    url: config.url,
	    app: config.app,
	    credentials: config.credentials,
	    username: config.username,
	    password: config.password,
	    enableTelemetry: config.enableTelemetry,
	    mongodb: config.mongodb
	  }, schema, backendName);
	  if (typeof protocol !== 'string' || protocol === '') {
	    throw new Error('Protocol is not present in url. URL should be of the form https://appbase-demo-ansible-abxiydt-arc.searchbase.io');
	  }
	  var credentials = auth || null;
	  /**
	   * Credentials can be provided as a part of the URL,
	   * as username, password args or as a credentials argument directly */
	  if (typeof config.credentials === 'string' && config.credentials !== '') {
	    // eslint-disable-next-line
	    credentials = config.credentials;
	  } else if (typeof config.username === 'string' && config.username !== '' && typeof config.password === 'string' && config.password !== '') {
	    credentials = config.username + ':' + config.password;
	  }
	  if (!config.mongodb) {
	    if (isAppbase(url) && credentials === null) {
	      throw new Error('Authentication information is not present. Did you add credentials?');
	    }
	  }
	  this.url = url;
	  this.protocol = protocol;
	  this.app = config.app;
	  this.credentials = credentials;
	  if (config.mongodb) {
	    this.mongodb = config.mongodb;
	  }
	  if (typeof config.enableTelemetry === 'boolean') {
	    this.enableTelemetry = config.enableTelemetry;
	  }
	}

	/**
	 * To perform fetch request
	 * @param {Object} args
	 * @param {String} args.method
	 * @param {String} args.path
	 * @param {Object} args.params
	 * @param {Object} args.body
	 * @param {Object} args.headers
	 * @param {boolean} args.isSuggestionsAPI
	 */
	function fetchRequest(args) {
	  var _this = this;
	  return new Promise(function (resolve, reject) {
	    var parsedArgs = removeUndefined(args);
	    try {
	      var method = parsedArgs.method,
	        path = parsedArgs.path,
	        params = parsedArgs.params,
	        body = parsedArgs.body,
	        isRSAPI = parsedArgs.isRSAPI,
	        isSuggestionsAPI = parsedArgs.isSuggestionsAPI,
	        _parsedArgs$isMongoRe = parsedArgs.isMongoRequest,
	        isMongoRequest = _parsedArgs$isMongoRe === undefined ? false : _parsedArgs$isMongoRe;
	      var app = isSuggestionsAPI ? '.suggestions' : _this.app;
	      var bodyCopy = body;
	      var contentType = path.endsWith('msearch') || path.endsWith('bulk') ? 'application/x-ndjson' : 'application/json';
	      var headers = Object.assign({}, {
	        Accept: 'application/json',
	        'Content-Type': contentType
	      }, args.headers, _this.headers);
	      var timestamp = Date.now();
	      if (_this.credentials) {
	        headers.Authorization = 'Basic ' + btoa$1(_this.credentials);
	      }
	      var requestOptions = {
	        method: method,
	        headers: headers
	      };
	      if (Array.isArray(bodyCopy)) {
	        var arrayBody = '';
	        bodyCopy.forEach(function (item) {
	          arrayBody += JSON.stringify(item);
	          arrayBody += '\n';
	        });
	        bodyCopy = arrayBody;
	      } else {
	        bodyCopy = JSON.stringify(bodyCopy) || {};
	      }
	      if (Object.keys(bodyCopy).length !== 0) {
	        requestOptions.body = bodyCopy;
	      }
	      var handleTransformRequest = function handleTransformRequest(res) {
	        if (_this.transformRequest && typeof _this.transformRequest === 'function') {
	          var tarnsformRequestPromise = _this.transformRequest(res);
	          return tarnsformRequestPromise instanceof Promise ? tarnsformRequestPromise : Promise.resolve(tarnsformRequestPromise);
	        }
	        return Promise.resolve(res);
	      };
	      var responseHeaders = {};
	      var paramsString = '';
	      if (params) {
	        paramsString = '?' + querystring.stringify(params);
	      }
	      var finalURL = isMongoRequest ? _this.protocol + '://' + _this.url : _this.protocol + '://' + _this.url + '/' + app + '/' + path + paramsString;
	      return handleTransformRequest(Object.assign({}, {
	        url: finalURL
	      }, requestOptions)).then(function (ts) {
	        var transformedRequest = Object.assign({}, ts);
	        var url = transformedRequest.url;
	        delete transformedRequest.url;
	        return fetch$1(url || finalURL, Object.assign({}, transformedRequest, {
	          // apply timestamp header for RS API
	          headers: isRSAPI && !isMongoRequest ? Object.assign({}, transformedRequest.headers, {
	            'x-timestamp': new Date().getTime()
	          }) : transformedRequest.headers
	        })).then(function (res) {
	          if (res.status >= 500) {
	            return reject(res);
	          }
	          responseHeaders = res.headers;
	          return res.json().then(function (data) {
	            if (res.status >= 400) {
	              return reject(res);
	            }
	            if (data && data.error) {
	              return reject(data);
	            }
	            // Handle error from RS API RESPONSE
	            if (isRSAPI && data && Object.prototype.toString.call(data) === '[object Object]') {
	              if (body && body.query && body.query instanceof Array) {
	                var errorResponses = 0;
	                var allResponses = body.query.filter(function (q) {
	                  return q.execute || q.execute === undefined;
	                }).length;
	                if (data) {
	                  Object.keys(data).forEach(function (key) {
	                    if (data[key] && Object.prototype.hasOwnProperty.call(data[key], 'error') && !!data[key].error) {
	                      errorResponses += 1;
	                    }
	                  });
	                }
	                // reject only when all responses has error
	                if (errorResponses > 0 && allResponses === errorResponses) {
	                  return reject(data);
	                }
	              }
	            }

	            // Handle error from _msearch response
	            if (data && data.responses instanceof Array) {
	              var _allResponses = data.responses.length;
	              var _errorResponses = data.responses.filter(function (entry) {
	                return Object.prototype.hasOwnProperty.call(entry, 'error');
	              }).length;
	              // reject only when all responses has error
	              if (_allResponses === _errorResponses) {
	                return reject(data);
	              }
	            }
	            var response = Object.assign({}, data, {
	              _timestamp: timestamp,
	              _headers: responseHeaders
	            });
	            return resolve(response);
	          })["catch"](function (e) {
	            return reject(e);
	          });
	        })["catch"](function (e) {
	          return reject(e);
	        });
	      })["catch"](function (err) {
	        return reject(err);
	      });
	    } catch (e) {
	      return reject(e);
	    }
	  });
	}

	/**
	 * Index Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {Object} args.body
	 * @param {String} args.id
	 */
	function indexApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    body: 'object'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var _parsedArgs$type = parsedArgs.type,
	    type = _parsedArgs$type === undefined ? '_doc' : _parsedArgs$type,
	    id = parsedArgs.id,
	    body = parsedArgs.body;
	  delete parsedArgs.type;
	  delete parsedArgs.body;
	  delete parsedArgs.id;
	  var path = void 0;
	  if (id) {
	    path = type ? type + '/' + encodeURIComponent(id) : encodeURIComponent(id);
	  } else {
	    path = type;
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: path,
	    params: parsedArgs,
	    body: body
	  });
	}

	/**
	 * Get Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {String} args.id
	 */
	function getApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    id: 'string|number'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var _parsedArgs$type = parsedArgs.type,
	    type = _parsedArgs$type === undefined ? '_doc' : _parsedArgs$type,
	    id = parsedArgs.id;
	  delete parsedArgs.type;
	  delete parsedArgs.id;
	  var path = type + '/' + encodeURIComponent(id);
	  return this.performFetchRequest({
	    method: 'GET',
	    path: path,
	    params: parsedArgs
	  });
	}

	/**
	 * Update Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {Object} args.body
	 * @param {String} args.id
	 */
	function updateApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    id: 'string|number',
	    body: 'object'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var _parsedArgs$type = parsedArgs.type,
	    type = _parsedArgs$type === undefined ? '_doc' : _parsedArgs$type,
	    id = parsedArgs.id,
	    body = parsedArgs.body;
	  delete parsedArgs.type;
	  delete parsedArgs.id;
	  delete parsedArgs.body;
	  var path = type + '/' + encodeURIComponent(id) + '/_update';
	  return this.performFetchRequest({
	    method: 'POST',
	    path: path,
	    params: parsedArgs,
	    body: body
	  });
	}

	/**
	 * Delete Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {String} args.id
	 */
	function deleteApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    id: 'string|number'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var _parsedArgs$type = parsedArgs.type,
	    type = _parsedArgs$type === undefined ? '_doc' : _parsedArgs$type,
	    id = parsedArgs.id;
	  delete parsedArgs.type;
	  delete parsedArgs.id;
	  var path = type + '/' + encodeURIComponent(id);
	  return this.performFetchRequest({
	    method: 'DELETE',
	    path: path,
	    params: parsedArgs
	  });
	}

	/**
	 * Bulk Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {Object} args.body
	 */
	function bulkApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    body: 'object'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var type = parsedArgs.type,
	    body = parsedArgs.body;
	  delete parsedArgs.type;
	  delete parsedArgs.body;
	  var path = void 0;
	  if (type) {
	    path = type + '/_bulk';
	  } else {
	    path = '_bulk';
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: path,
	    params: parsedArgs,
	    body: body
	  });
	}

	/**
	 * Search Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {Object} args.body
	 */
	function searchApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    body: 'object'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var type = void 0;
	  if (Array.isArray(parsedArgs.type)) {
	    type = parsedArgs.type.join();
	  } else {
	    // eslint-disable-next-line
	    type = parsedArgs.type;
	  }
	  var body = parsedArgs.body;
	  delete parsedArgs.type;
	  delete parsedArgs.body;
	  var path = void 0;
	  if (type) {
	    path = type + '/_search';
	  } else {
	    path = '_search';
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: path,
	    params: parsedArgs,
	    body: body
	  });
	}

	/**
	 * Msearch Service
	 * @param {Object} args
	 * @param {String} args.type
	 * @param {Object} args.body
	 */
	function msearchApi(args) {
	  var parsedArgs = removeUndefined(args);
	  // Validate arguments
	  var valid = validate(parsedArgs, {
	    body: 'object'
	  });
	  if (valid !== true) {
	    throw valid;
	  }
	  var type = void 0;
	  if (Array.isArray(parsedArgs.type)) {
	    type = parsedArgs.type.join();
	  } else {
	    type = parsedArgs.type;
	  }
	  var body = parsedArgs.body;
	  delete parsedArgs.type;
	  delete parsedArgs.body;
	  var path = void 0;
	  if (type) {
	    path = type + '/_msearch';
	  } else {
	    path = '_msearch';
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: path,
	    params: parsedArgs,
	    body: body
	  });
	}

	/**
	 * ReactiveSearch API Service for v3
	 * @param {Array<Object>} query
	 * @param {Object} settings
	 * @param {boolean} settings.recordAnalytics
	 * @param {boolean} settings.userId
	 * @param {boolean} settings.enableQueryRules
	 * @param {boolean} settings.customEvents
	 */
	function reactiveSearchApi(query, settings, params) {
	  var parsedSettings = removeUndefined(settings);

	  // Validate query
	  var valid = validateRSQuery(query);
	  if (valid !== true) {
	    throw valid;
	  }
	  var body = {
	    settings: parsedSettings,
	    query: query
	  };
	  if (this.mongodb) {
	    Object.assign(body, {
	      mongodb: getMongoRequest(this.app, this.mongodb)
	    });
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: '_reactivesearch',
	    body: body,
	    headers: getTelemetryHeaders(this.enableTelemetry, !this.mongodb),
	    isRSAPI: true,
	    isMongoRequest: !!this.mongodb,
	    params: params
	  });
	}

	/**
	 * ReactiveSearch API Service for v3
	 * @param {Array<Object>} query
	 * @param {Object} settings
	 * @param {boolean} settings.recordAnalytics
	 * @param {boolean} settings.userId
	 * @param {boolean} settings.enableQueryRules
	 * @param {boolean} settings.customEvents
	 */
	function reactiveSearchv3Api(query, settings, params) {
	  var parsedSettings = removeUndefined(settings);

	  // Validate query
	  var valid = validateRSQuery(query);
	  if (valid !== true) {
	    throw valid;
	  }
	  var body = {
	    settings: parsedSettings,
	    query: query
	  };
	  if (this.mongodb) {
	    Object.assign(body, {
	      mongodb: getMongoRequest(this.app, this.mongodb)
	    });
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: '_reactivesearch.v3',
	    body: body,
	    headers: getTelemetryHeaders(this.enableTelemetry, !this.mongodb),
	    isRSAPI: true,
	    isMongoRequest: !!this.mongodb,
	    params: params
	  });
	}

	/**
	 * To get mappings
	 */
	function getMappings() {
	  return this.performFetchRequest({
	    method: 'GET',
	    path: '_mapping'
	  });
	}

	/**
	 * ReactiveSearch suggestions API for v3
	 * @param {Array<Object>} query
	 * @param {Object} settings
	 * @param {boolean} settings.recordAnalytics
	 * @param {boolean} settings.userId
	 * @param {boolean} settings.enableQueryRules
	 * @param {boolean} settings.customEvents
	 */
	function getSuggestionsv3Api(query, settings) {
	  var parsedSettings = removeUndefined(settings);

	  // Validate query
	  var valid = validateRSQuery(query);
	  if (valid !== true) {
	    throw valid;
	  }
	  var body = {
	    settings: parsedSettings,
	    query: query
	  };
	  if (this.mongodb) {
	    Object.assign(body, {
	      mongodb: getMongoRequest(this.app, this.mongodb)
	    });
	  }
	  return this.performFetchRequest({
	    method: 'POST',
	    path: '_reactivesearch.v3',
	    body: body,
	    headers: getTelemetryHeaders(this.enableTelemetry),
	    isRSAPI: true,
	    isSuggestionsAPI: true,
	    isMongoRequest: !!this.mongodb
	  });
	}
	function appbasejs(config) {
	  var client = new AppBase(config);
	  AppBase.prototype.performFetchRequest = fetchRequest;
	  AppBase.prototype.index = indexApi;
	  AppBase.prototype.get = getApi;
	  AppBase.prototype.update = updateApi;
	  AppBase.prototype["delete"] = deleteApi;
	  AppBase.prototype.bulk = bulkApi;
	  AppBase.prototype.search = searchApi;
	  AppBase.prototype.msearch = msearchApi;
	  AppBase.prototype.reactiveSearch = reactiveSearchApi;
	  AppBase.prototype.reactiveSearchv3 = reactiveSearchv3Api;
	  AppBase.prototype.getQuerySuggestions = getSuggestionsv3Api;
	  AppBase.prototype.getMappings = getMappings;
	  AppBase.prototype.setHeaders = function setHeaders() {
	    var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var shouldEncode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    // Encode headers
	    if (shouldEncode) {
	      this.headers = encodeHeaders(headers);
	    } else {
	      this.headers = headers;
	    }
	  };
	  if (typeof window !== 'undefined') {
	    window.Appbase = client;
	  }
	  return client;
	}

	function _extends$3() {
	  _extends$3 = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends$3.apply(this, arguments);
	}

	// Function to parse the URL
	function btoa$2(input) {
	  if (input === void 0) {
	    input = '';
	  }
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	  var str = input;
	  var output = ''; // eslint-disable-next-line

	  for (var block = 0, charCode, i = 0, map = chars; str.charAt(i | 0) || (map = '=', i % 1);
	  // eslint-disable-line no-bitwise
	  output += map.charAt(63 & block >> 8 - i % 1 * 8) // eslint-disable-line no-bitwise
	  ) {
	    charCode = str.charCodeAt(i += 3 / 4);
	    if (charCode > 0xff) {
	      throw new Error('"btoa" failed: The string to be encoded contains characters outside of the Latin1 range.');
	    }
	    block = block << 8 | charCode; // eslint-disable-line no-bitwise
	  }

	  return output;
	}
	function validateIndex(index) {
	  if (!index) {
	    throw new Error('appbase-analytics: A valid index must be present to record analytics events.');
	  }
	}
	function validateCredentials(credentials) {
	  if (!credentials) {
	    throw new Error('appbase-analytics: Auth credentials is missing.');
	  }
	}
	function validateURL(url) {
	  if (!url) {
	    throw new Error('appbase-analytics: URL is missing.');
	  }
	}
	function validateQuery(query, queryID) {
	  if ((query === undefined || query === null) && !queryID) {
	    throw new Error('appbase-analytics: query or queryID must be present to register a click/conversion event');
	  }
	}
	function validateQueryID(queryID) {
	  if (!queryID) {
	    throw new Error('appbase-analytics: queryID must be present to save search/favorite');
	  }
	}
	function validateClickObjects(objects) {
	  if (!objects || Object.keys(objects).length < 1) {
	    throw new Error('appbase-analytics: at least one click object must be present to register a click event');
	  }
	}
	function validateConversionObjects(objects) {
	  if (!objects || Object.keys(objects).length < 1) {
	    throw new Error('appbase-analytics: at least one click object must be present to register a click event');
	  }
	}
	function initClient(config) {
	  if (config === void 0) {
	    config = {};
	  }
	  var metrics = {
	    credentials: config.credentials,
	    index: config.index,
	    url: config.url,
	    userID: config.userID,
	    globalCustomEvents: config.globalCustomEvents,
	    queryID: '',
	    headers: null,
	    _request: function _request(method, url, body, queryParams, callback) {
	      var finalBody = _extends$3({
	        user_id: metrics.userID
	      }, body, {
	        custom_events: _extends$3({}, body && body.custom_events, {}, metrics.globalCustomEvents)
	      });
	      var queryParamsString = '';
	      if (queryParams) {
	        queryParamsString = Object.keys(queryParams).map(function (param) {
	          return param + "=" + queryParams[param];
	        }).join('&');
	      }
	      return fetch$1(metrics.url + "/" + url + "?" + queryParamsString, {
	        method: method,
	        headers: _extends$3({}, metrics.headers, {
	          'Content-Type': 'application/json',
	          Authorization: "Basic " + btoa$2(metrics.credentials)
	        }),
	        body: method === 'GET' ? null : JSON.stringify(finalBody)
	      }).then(function (response) {
	        if (callback) {
	          callback(null, response);
	        }
	      })["catch"](function (err) {
	        if (callback) {
	          callback(err, null);
	        }
	      });
	    }
	  };
	  validateIndex(metrics.index);
	  validateCredentials(metrics.credentials);
	  validateURL(metrics.url); // To register a search

	  metrics.search = function (searchConfig, callback) {
	    validateQuery(searchConfig.query, searchConfig.queryID);
	    var captureQueryID = function captureQueryID(err, res) {
	      if (res) {
	        res.json().then(function (response) {
	          if (response && response.query_id) {
	            metrics.queryID = response.query_id;
	          }
	          if (callback) {
	            callback(err, res);
	          }
	        })["catch"](function (err2) {
	          if (callback) {
	            callback(err2, res);
	          }
	        });
	      } else if (callback) {
	        callback(err, res);
	      }
	    }; // just to avoid the flow type error

	    if (metrics._request) {
	      var requestBody = {
	        query: searchConfig.query,
	        query_id: searchConfig.queryID,
	        custom_events: searchConfig.customEvents,
	        filters: searchConfig.filters,
	        hits: searchConfig.hits,
	        impressions: searchConfig.impressions
	      };
	      metrics._request('PUT', metrics.index + "/_analytics/search", requestBody, null, captureQueryID);
	    }
	  }; // To register a click

	  metrics.click = function (clickConfig, callback) {
	    validateQuery(clickConfig.query, clickConfig.queryID);
	    validateClickObjects(clickConfig.objects); // just to avoid the flow type error

	    if (metrics._request) {
	      var requestBody = {
	        click_on: clickConfig.objects,
	        click_type: clickConfig.isSuggestionClick ? 'suggestion' : 'result',
	        query: clickConfig.query,
	        query_id: clickConfig.queryID,
	        custom_events: clickConfig.customEvents,
	        meta: clickConfig.meta
	      };
	      metrics._request('PUT', metrics.index + "/_analytics/click", requestBody, null, callback);
	    }
	  }; // To register a conversion

	  metrics.conversion = function (conversionConfig, callback) {
	    validateQuery(null, conversionConfig.queryID);
	    validateConversionObjects(conversionConfig.objects); // just to avoid the flow type error

	    if (metrics._request) {
	      var requestBody = {
	        conversion_on: conversionConfig.objects,
	        query_id: conversionConfig.queryID,
	        meta: conversionConfig.meta
	      };
	      metrics._request('PUT', metrics.index + "/_analytics/conversion", requestBody, null, callback);
	    }
	  }; // To save search

	  metrics.saveSearch = function (saveSearchConfig, callback) {
	    validateQueryID(saveSearchConfig.queryID);
	    var requestBody = {
	      query_id: saveSearchConfig.queryID,
	      save_search_id: saveSearchConfig.saveSearchID,
	      save_search_meta: saveSearchConfig.saveSearchMeta,
	      user_id: saveSearchConfig.userID,
	      custom_events: saveSearchConfig.customEvents
	    };
	    metrics._request('PUT', '_analytics/save-search', requestBody, null, callback);
	  }; // To delete save search

	  metrics.deleteSavedSearch = function (saveSearchId, callback) {
	    metrics._request('DELETE', '_analytics/save-search/' + saveSearchId, null, null, callback);
	  }; // To retrieve saved searches

	  metrics.getSavedSearches = function (filters, callback) {
	    // just to avoid the flow type error
	    if (metrics._request) {
	      metrics._request('GET', '_analytics/saved-searches', null, filters, callback);
	    }
	  }; // To record a favorite document

	  metrics.favorite = function (favoriteConfig, callback) {
	    validateQueryID(favoriteConfig.queryID);
	    if (!favoriteConfig.favoriteOn || favoriteConfig.favoriteOn === '') {
	      throw new Error('appbase-analytics: favoriteOn property is required');
	    }
	    if (!favoriteConfig.source) {
	      throw new Error('appbase-analytics: source property is required');
	    }
	    var requestBody = {
	      query_id: favoriteConfig.queryID,
	      favorite_on: favoriteConfig.favoriteOn,
	      source: favoriteConfig.source,
	      id: favoriteConfig.id,
	      meta: favoriteConfig.meta,
	      user_id: favoriteConfig.userID,
	      custom_events: favoriteConfig.customEvents
	    };
	    metrics._request('PUT', '_analytics/favorite', requestBody, null, callback);
	  }; // To retrieve favorites

	  metrics.getFavorites = function (filters, callback) {
	    // just to avoid the flow type error
	    if (metrics._request) {
	      metrics._request('GET', '_analytics/favorites', null, filters, callback);
	    }
	  }; // Sets the userID

	  metrics.setUserID = function (userID) {
	    metrics.userID = userID;
	  }; // Sets the global events

	  metrics.setGlobalCustomEvents = function (globalEvents) {
	    metrics.globalCustomEvents = globalEvents;
	  }; // Sets the headers

	  metrics.setHeaders = function (headers) {
	    metrics.headers = headers;
	  }; // get queryID

	  metrics.getQueryID = function () {
	    return metrics.queryID;
	  };
	  return metrics;
	}
	var index$2 = {
	  init: initClient
	};

	/**
	 *
	 *
	 * @author Jerry Bendy <jerry@icewingcc.com>
	 * @licence MIT
	 *
	 */

	(function (self) {

	  var nativeURLSearchParams = self.URLSearchParams && self.URLSearchParams.prototype.get ? self.URLSearchParams : null,
	    isSupportObjectConstructor = nativeURLSearchParams && new nativeURLSearchParams({
	      a: 1
	    }).toString() === 'a=1',
	    // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.
	    decodesPlusesCorrectly = nativeURLSearchParams && new nativeURLSearchParams('s=%2B').get('s') === '+',
	    __URLSearchParams__ = "__URLSearchParams__",
	    // Fix bug in Edge which cannot encode ' &' correctly
	    encodesAmpersandsCorrectly = nativeURLSearchParams ? function () {
	      var ampersandTest = new nativeURLSearchParams();
	      ampersandTest.append('s', ' &');
	      return ampersandTest.toString() === 's=+%26';
	    }() : true,
	    prototype = URLSearchParamsPolyfill.prototype,
	    iterable = !!(self.Symbol && self.Symbol.iterator);
	  if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
	    return;
	  }

	  /**
	   * Make a URLSearchParams instance
	   *
	   * @param {object|string|URLSearchParams} search
	   * @constructor
	   */
	  function URLSearchParamsPolyfill(search) {
	    search = search || "";

	    // support construct object with another URLSearchParams instance
	    if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
	      search = search.toString();
	    }
	    this[__URLSearchParams__] = parseToDict(search);
	  }

	  /**
	   * Appends a specified key/value pair as a new search parameter.
	   *
	   * @param {string} name
	   * @param {string} value
	   */
	  prototype.append = function (name, value) {
	    appendTo(this[__URLSearchParams__], name, value);
	  };

	  /**
	   * Deletes the given search parameter, and its associated value,
	   * from the list of all search parameters.
	   *
	   * @param {string} name
	   */
	  prototype['delete'] = function (name) {
	    delete this[__URLSearchParams__][name];
	  };

	  /**
	   * Returns the first value associated to the given search parameter.
	   *
	   * @param {string} name
	   * @returns {string|null}
	   */
	  prototype.get = function (name) {
	    var dict = this[__URLSearchParams__];
	    return name in dict ? dict[name][0] : null;
	  };

	  /**
	   * Returns all the values association with a given search parameter.
	   *
	   * @param {string} name
	   * @returns {Array}
	   */
	  prototype.getAll = function (name) {
	    var dict = this[__URLSearchParams__];
	    return name in dict ? dict[name].slice(0) : [];
	  };

	  /**
	   * Returns a Boolean indicating if such a search parameter exists.
	   *
	   * @param {string} name
	   * @returns {boolean}
	   */
	  prototype.has = function (name) {
	    return name in this[__URLSearchParams__];
	  };

	  /**
	   * Sets the value associated to a given search parameter to
	   * the given value. If there were several values, delete the
	   * others.
	   *
	   * @param {string} name
	   * @param {string} value
	   */
	  prototype.set = function set(name, value) {
	    this[__URLSearchParams__][name] = ['' + value];
	  };

	  /**
	   * Returns a string containg a query string suitable for use in a URL.
	   *
	   * @returns {string}
	   */
	  prototype.toString = function () {
	    var dict = this[__URLSearchParams__],
	      query = [],
	      i,
	      key,
	      name,
	      value;
	    for (key in dict) {
	      name = encode(key);
	      for (i = 0, value = dict[key]; i < value.length; i++) {
	        query.push(name + '=' + encode(value[i]));
	      }
	    }
	    return query.join('&');
	  };

	  // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.
	  var forSureUsePolyfill = !decodesPlusesCorrectly;
	  var useProxy = !forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy;
	  /*
	   * Apply polifill to global object and append other prototype into it
	   */
	  Object.defineProperty(self, 'URLSearchParams', {
	    value: useProxy ?
	    // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
	    new Proxy(nativeURLSearchParams, {
	      construct: function construct(target, args) {
	        return new target(new URLSearchParamsPolyfill(args[0]).toString());
	      }
	    }) : URLSearchParamsPolyfill
	  });
	  var USPProto = self.URLSearchParams.prototype;
	  USPProto.polyfill = true;

	  /**
	   *
	   * @param {function} callback
	   * @param {object} thisArg
	   */
	  USPProto.forEach = USPProto.forEach || function (callback, thisArg) {
	    var dict = parseToDict(this.toString());
	    Object.getOwnPropertyNames(dict).forEach(function (name) {
	      dict[name].forEach(function (value) {
	        callback.call(thisArg, value, name, this);
	      }, this);
	    }, this);
	  };

	  /**
	   * Sort all name-value pairs
	   */
	  USPProto.sort = USPProto.sort || function () {
	    var dict = parseToDict(this.toString()),
	      keys = [],
	      k,
	      i,
	      j;
	    for (k in dict) {
	      keys.push(k);
	    }
	    keys.sort();
	    for (i = 0; i < keys.length; i++) {
	      this['delete'](keys[i]);
	    }
	    for (i = 0; i < keys.length; i++) {
	      var key = keys[i],
	        values = dict[key];
	      for (j = 0; j < values.length; j++) {
	        this.append(key, values[j]);
	      }
	    }
	  };

	  /**
	   * Returns an iterator allowing to go through all keys of
	   * the key/value pairs contained in this object.
	   *
	   * @returns {function}
	   */
	  USPProto.keys = USPProto.keys || function () {
	    var items = [];
	    this.forEach(function (item, name) {
	      items.push(name);
	    });
	    return makeIterator(items);
	  };

	  /**
	   * Returns an iterator allowing to go through all values of
	   * the key/value pairs contained in this object.
	   *
	   * @returns {function}
	   */
	  USPProto.values = USPProto.values || function () {
	    var items = [];
	    this.forEach(function (item) {
	      items.push(item);
	    });
	    return makeIterator(items);
	  };

	  /**
	   * Returns an iterator allowing to go through all key/value
	   * pairs contained in this object.
	   *
	   * @returns {function}
	   */
	  USPProto.entries = USPProto.entries || function () {
	    var items = [];
	    this.forEach(function (item, name) {
	      items.push([name, item]);
	    });
	    return makeIterator(items);
	  };
	  if (iterable) {
	    USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;
	  }
	  function encode(str) {
	    var replace = {
	      '!': '%21',
	      "'": '%27',
	      '(': '%28',
	      ')': '%29',
	      '~': '%7E',
	      '%20': '+',
	      '%00': '\x00'
	    };
	    return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function (match) {
	      return replace[match];
	    });
	  }
	  function decode(str) {
	    return str.replace(/[ +]/g, '%20').replace(/(%[a-f0-9]{2})+/ig, function (match) {
	      return decodeURIComponent(match);
	    });
	  }
	  function makeIterator(arr) {
	    var iterator = {
	      next: function next() {
	        var value = arr.shift();
	        return {
	          done: value === undefined,
	          value: value
	        };
	      }
	    };
	    if (iterable) {
	      iterator[self.Symbol.iterator] = function () {
	        return iterator;
	      };
	    }
	    return iterator;
	  }
	  function parseToDict(search) {
	    var dict = {};
	    if (typeof search === "object") {
	      // if `search` is an array, treat it as a sequence
	      if (isArray(search)) {
	        for (var i = 0; i < search.length; i++) {
	          var item = search[i];
	          if (isArray(item) && item.length === 2) {
	            appendTo(dict, item[0], item[1]);
	          } else {
	            throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
	          }
	        }
	      } else {
	        for (var key in search) {
	          if (search.hasOwnProperty(key)) {
	            appendTo(dict, key, search[key]);
	          }
	        }
	      }
	    } else {
	      // remove first '?'
	      if (search.indexOf("?") === 0) {
	        search = search.slice(1);
	      }
	      var pairs = search.split("&");
	      for (var j = 0; j < pairs.length; j++) {
	        var value = pairs[j],
	          index = value.indexOf('=');
	        if (-1 < index) {
	          appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
	        } else {
	          if (value) {
	            appendTo(dict, decode(value), '');
	          }
	        }
	      }
	    }
	    return dict;
	  }
	  function appendTo(dict, name, value) {
	    var val = typeof value === 'string' ? value : value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value);
	    if (name in dict) {
	      dict[name].push(val);
	    } else {
	      dict[name] = [val];
	    }
	  }
	  function isArray(val) {
	    return !!val && '[object Array]' === Object.prototype.toString.call(val);
	  }
	})(typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : commonjsGlobal);

	var Provider = {
	  name: 'Provider',
	  props: {
	    store: {
	      type: Object,
	      required: true,
	      validator: function validator(store) {
	        if (!store.dispatch && !store.subscribe && !store.getState) {
	          throw new Error('[reactivesearch-vue] - store provided is not a valid redux store');
	        }
	        return true;
	      }
	    },
	    analyticsRef: {
	      type: Object,
	      required: false
	    }
	  },
	  provide: function provide() {
	    return {
	      $$store: this.store,
	      $analytics: this.analyticsRef
	    };
	  },
	  render: function render(h) {
	    if (this.$slots["default"].length > 1) {
	      return h('div', this.$slots["default"]);
	    }
	    return this.$slots["default"][0];
	  }
	};

	var _templateObject$7;
	var Base = {
	  functional: true,
	  render: function render(h, _ref) {
	    var _ref$data$attrs$as = _ref.data.attrs.as,
	      T = _ref$data$attrs$as === void 0 ? 'div' : _ref$data$attrs$as,
	      props = _ref.data,
	      children = _ref.children;
	    delete props.attrs.as;
	    return h(T, helper$1([{}, props]), [children]);
	  }
	};
	var Base$1 = index$1(Base)(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteralLoose(["\n\tfont-family: ", ";\n\tfont-size: ", ";\n\tcolor: ", ";\n\twidth: 100%;\n\n\tinput,\n\tbutton,\n\ttextarea,\n\tselect {\n\t\tfont-family: ", ";\n\t}\n\n\t*,\n\t*:before,\n\t*:after {\n\t\tbox-sizing: border-box;\n\t}\n"])), function (_ref2) {
	  var theme = _ref2.theme;
	  return theme.typography.fontFamily;
	}, function (_ref3) {
	  var theme = _ref3.theme;
	  return theme.typography.fontSize;
	}, function (_ref4) {
	  var theme = _ref4.theme;
	  return theme.colors.textColor;
	}, function (_ref5) {
	  var theme = _ref5.theme;
	  return theme.typography.fontFamily;
	});

	var setHeaders = lib_5.setHeaders,
	  setValue$1 = lib_5.setValue;
	var isEqual$3 = lib_8.isEqual;
	var URLParamsProvider = {
	  name: 'URLParamsProvider',
	  props: {
	    className: types.string,
	    headers: types.headers,
	    getSearchParams: types.func,
	    setSearchParams: types.func,
	    as: VueTypes.string.def('div')
	  },
	  mounted: function mounted() {
	    var _this = this;
	    this.init();
	    window.onpopstate = function () {
	      _this.init();
	      var activeComponents = Array.from(_this.params.keys());
	      // remove inactive components from selectedValues
	      Object.keys(_this.currentSelectedState).filter(function (item) {
	        return !activeComponents.includes(item);
	      }).forEach(function (component) {
	        _this.setValue(component, null, undefined, undefined, undefined, undefined, undefined, undefined, 'URL');
	      });
	      // update active components in selectedValues
	      Array.from(_this.params.entries()).forEach(function (item) {
	        try {
	          var component = item[0],
	            value = item[1];
	          var _ref = _this.selectedValues[component] || {
	              label: component
	            },
	            label = _ref.label,
	            showFilter = _ref.showFilter,
	            URLParams = _ref.URLParams;
	          _this.setValue(component, JSON.parse(value), label, showFilter, URLParams, undefined, undefined, undefined, 'URL');
	        } catch (e) {
	          // Do not set value if JSON parsing fails.
	          console.error(e);
	        }
	      });
	    };
	  },
	  watch: {
	    $route: function $route() {
	      // this ensures the url params change are handled
	      // when the url changes, which enables us to
	      // make `onpopstate` event handler work with history.pushState updates
	      this.checkForURLParamsChange();
	    },
	    selectedValues: function selectedValues(newVal, oldVal) {
	      var _this2 = this;
	      if (!isEqual$3(newVal, oldVal)) {
	        this.searchString = this.$props.getSearchParams ? this.$props.getSearchParams() : window.location.search;
	        this.params = new URLSearchParams(this.searchString);
	        var currentComponents = Object.keys(newVal);
	        var urlComponents = Array.from(this.params.keys());
	        var shouldPushHistory = false;
	        currentComponents.filter(function (component) {
	          return newVal[component].URLParams;
	        }).forEach(function (component) {
	          var selectedValues = newVal[component];
	          // prevents empty history pollution on initial load
	          if (_this2.hasValidValue(newVal[component]) || _this2.hasValidValue(oldVal[component])) {
	            if (selectedValues.URLParams) {
	              if (selectedValues.category) {
	                var shouldUpdateHistory = _this2.setURL(component, _this2.getValue({
	                  category: selectedValues.category,
	                  value: selectedValues.value
	                }));
	                if (shouldUpdateHistory) {
	                  shouldPushHistory = true;
	                }
	              } else {
	                var _shouldUpdateHistory = _this2.setURL(component, _this2.getValue(selectedValues.value));
	                if (_shouldUpdateHistory) {
	                  shouldPushHistory = true;
	                }
	              }
	            } else {
	              _this2.params["delete"](component);
	              shouldPushHistory = true;
	            }
	          } else if (!_this2.hasValidValue(newVal[component]) && urlComponents.includes(component)) {
	            // doesn't have a valid value, but the url has a (stale) valid value set
	            _this2.params["delete"](component);
	            shouldPushHistory = true;
	          }
	        });

	        // remove unmounted components
	        Object.keys(newVal).filter(function (component) {
	          return !currentComponents.includes(component);
	        }).forEach(function (component) {
	          _this2.params["delete"](component);
	          shouldPushHistory = true;
	        });
	        if (!currentComponents.length) {
	          Array.from(this.params.keys()).forEach(function (item) {
	            if (_this2.searchComponents && _this2.searchComponents.includes(item)) {
	              _this2.params["delete"](item);
	              shouldPushHistory = true;
	            }
	          });
	        }
	        if (shouldPushHistory) {
	          this.pushToHistory();
	        }
	      }
	    },
	    headers: function headers(newVal, oldVal) {
	      if (!isEqual$3(oldVal, newVal)) {
	        this.setHeaders(newVal);
	      }
	    }
	  },
	  methods: {
	    init: function init() {
	      this.searchString = this.$props.getSearchParams ? this.$props.getSearchParams() : window.location.search;
	      this.params = new URLSearchParams(this.searchString);
	      this.currentSelectedState = this.selectedValues || {};
	    },
	    checkForURLParamsChange: function checkForURLParamsChange() {
	      // we only compare the search string (window.location.search by default)
	      // to see if the route has changed (or) not. This handles the following usecase:
	      // search on homepage -> route changes -> search results page with same search query
	      if (window) {
	        var searchString = this.$props.getSearchParams ? this.$props.getSearchParams() : window.location.search;
	        if (searchString !== this.searchString) {
	          var event;
	          if (typeof Event === 'function') {
	            event = new Event('popstate');
	          } else {
	            // Correctly fire popstate event on IE11 to prevent app crash.
	            event = document.createEvent('Event');
	            event.initEvent('popstate', true, true);
	          }
	          window.dispatchEvent(event);
	        }
	      }
	    },
	    hasValidValue: function hasValidValue(component) {
	      if (!component) return false;
	      if (Array.isArray(component.value)) return !!component.value.length;
	      return !!component.value;
	    },
	    getValue: function getValue(value) {
	      var _this3 = this;
	      if (Array.isArray(value) && value.length) {
	        return value.map(function (item) {
	          return _this3.getValue(item);
	        });
	      }
	      if (value && typeof value === 'object') {
	        // TODO: support for NestedList
	        if (value.location) return value;
	        if (value.category) return value;
	        return value.label || value.key || null;
	      }
	      return value;
	    },
	    setURL: function setURL(component, value) {
	      if (!value || typeof value === 'string' && value.trim() === '' || Array.isArray(value) && value.length === 0) {
	        this.params["delete"](component);
	        return true;
	      }
	      var data = JSON.stringify(value);
	      if (data !== this.params.get(component)) {
	        this.params.set(component, data);
	        return true;
	      }
	      return false;
	    },
	    pushToHistory: function pushToHistory() {
	      var paramsSting = this.params.toString() ? "?" + this.params.toString() : '';
	      var base = window.location.href.split('?')[0];
	      var newURL = "" + base + paramsSting;
	      if (this.$props.setSearchParams) {
	        this.$props.setSearchParams(newURL);
	      } else if (window.history.pushState) {
	        window.history.pushState({
	          path: newURL
	        }, '', newURL);
	      }
	      this.init();
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var children = this.$slots["default"];
	    return h(Base$1, {
	      "attrs": {
	        "as": this.$props.as
	      },
	      "class": this.$props.className
	    }, [children]);
	  }
	};
	var mapStateToProps$2 = function mapStateToProps(state) {
	  return {
	    selectedValues: state.selectedValues,
	    searchComponents: state.components
	  };
	};
	var mapDispatchtoProps$1 = {
	  setHeaders: setHeaders,
	  setValue: setValue$1
	};
	URLParamsProvider.install = function (Vue) {
	  Vue.component(URLParamsProvider.name, URLParamsProvider);
	};
	var URLParamsProvider$1 = connect(mapStateToProps$2, mapDispatchtoProps$1)(URLParamsProvider);

	var typography = {
	  fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Noto Sans", "Ubuntu", "Droid Sans", "Helvetica Neue", sans-serif',
	  fontSize: '16px'
	};
	var light = {
	  typography: typography,
	  colors: {
	    textColor: '#424242',
	    primaryTextColor: '#fff',
	    primaryColor: '#0B6AFF',
	    titleColor: '#424242',
	    alertColor: '#d9534f',
	    borderColor: '#595959'
	  }
	};
	var dark = {
	  typography: typography,
	  colors: {
	    textColor: '#fff',
	    backgroundColor: '#212121',
	    primaryTextColor: '#fff',
	    primaryColor: '#2196F3',
	    titleColor: '#fff',
	    alertColor: '#d9534f',
	    borderColor: '#666'
	  }
	};
	function getTheme(preset) {
	  if (preset === 'light') {
	    return light;
	  }
	  return dark;
	}

	var ReactiveBase = {
	  name: 'ReactiveBase',
	  data: function data() {
	    this.state = {
	      key: '__REACTIVE_BASE__'
	    };
	    return this.state;
	  },
	  created: function created() {
	    this.setStore(this.$props);
	  },
	  mounted: function mounted() {
	    var enableAppbase = this.enableAppbase,
	      endpoint = this.endpoint;
	    if (!enableAppbase && endpoint) {
	      console.warn('Warning(ReactiveSearch): The `endpoint` prop works only when `enableAppbase` prop is set to true.');
	    }
	  },
	  props: {
	    app: types.string,
	    analytics: VueTypes.bool,
	    appbaseConfig: types.appbaseConfig,
	    enableAppbase: VueTypes.bool.def(false),
	    credentials: types.string,
	    headers: types.headers,
	    queryParams: types.string,
	    theme: VueTypes.object.def({}),
	    themePreset: VueTypes.string.def('light'),
	    type: types.string,
	    url: types.string,
	    mapKey: types.string,
	    initialQueriesSyncTime: types.number,
	    className: types.string,
	    initialState: VueTypes.object.def({}),
	    transformRequest: types.func,
	    transformResponse: types.func,
	    as: VueTypes.string.def('div'),
	    getSearchParams: types.func,
	    setSearchParams: types.func,
	    mongodb: types.mongodb,
	    endpoint: types.endpointConfig,
	    preferences: VueTypes.object
	  },
	  provide: function provide() {
	    return {
	      theme_reactivesearch: composeThemeObject(getTheme(this.$props.themePreset), this.$props.theme),
	      store: this.store,
	      $searchPreferences: this.preferences
	    };
	  },
	  watch: {
	    app: function app() {
	      this.updateState(this.$props);
	    },
	    url: function url() {
	      this.updateState(this.$props);
	    },
	    type: function type() {
	      this.updateState(this.$props);
	    },
	    credentials: function credentials() {
	      this.updateState(this.$props);
	    },
	    mapKey: function mapKey() {
	      this.updateState(this.$props);
	    },
	    headers: function headers() {
	      this.updateState(this.$props);
	    },
	    appbaseConfig: function appbaseConfig(newVal, oldVal) {
	      if (!helper_33(newVal, oldVal)) {
	        if (this.store) {
	          this.store.dispatch(analytics_3$1(newVal));
	        }
	      }
	    },
	    mongodb: function mongodb() {
	      this.updateState(this.$props);
	    }
	  },
	  computed: {
	    getHeaders: function getHeaders() {
	      var _this$$props = this.$props,
	        enableAppbase = _this$$props.enableAppbase,
	        headers = _this$$props.headers,
	        appbaseConfig = _this$$props.appbaseConfig,
	        mongodb = _this$$props.mongodb,
	        endpoint = _this$$props.endpoint;
	      var _ref = appbaseConfig || {},
	        enableTelemetry = _ref.enableTelemetry;
	      return _extends({}, enableAppbase && !mongodb && _extends({
	        'X-Search-Client': X_SEARCH_CLIENT
	      }, enableTelemetry === false && {
	        'X-Enable-Telemetry': false
	      }), headers, enableAppbase && endpoint && endpoint.headers && _extends({}, endpoint.headers));
	    }
	  },
	  methods: {
	    updateState: function updateState(props) {
	      this.setStore(props);
	      this.key = this.state.key + "-0";
	    },
	    setStore: function setStore(props) {
	      var credentials = props.url && props.url.trim() !== '' && !props.credentials ? null : props.credentials;
	      var url = props.url && props.url.trim() !== '' ? props.url : '';
	      if (props.enableAppbase && props.endpoint) {
	        if (props.endpoint.url) {
	          // eslint-disable-next-line prefer-destructuring
	          url = props.endpoint.url;
	        } else {
	          throw Error('Error(ReactiveSearch): The `endpoint` prop object requires `url` property.');
	        }
	      }
	      var config = {
	        url: url,
	        app: props.app,
	        credentials: credentials,
	        type: props.type ? props.type : '*',
	        transformRequest: props.transformRequest,
	        transformResponse: props.transformResponse,
	        enableAppbase: props.enableAppbase,
	        analytics: props.appbaseConfig ? props.appbaseConfig.recordAnalytics : props.analytics,
	        analyticsConfig: props.appbaseConfig,
	        mongodb: props.mongodb,
	        endpoint: props.endpoint
	      };
	      var queryParams = '';
	      if (typeof window !== 'undefined') {
	        queryParams = window.location.search;
	      } else {
	        queryParams = props.queryParams || '';
	      }
	      var params = new URLSearchParams(queryParams);
	      var selectedValues = {};
	      var urlValues = {};
	      Array.from(params.keys()).forEach(function (key) {
	        try {
	          var _extends2, _extends3;
	          var parsedParams = JSON.parse(params.get(key));
	          var selectedValue = {};
	          if (parsedParams.value) {
	            selectedValue.value = parsedParams.value;
	          } else {
	            selectedValue.value = parsedParams;
	          }
	          if (parsedParams.category) selectedValue.category = parsedParams.category;
	          selectedValue.reference = 'URL';
	          selectedValues = _extends({}, selectedValues, (_extends2 = {}, _extends2[key] = selectedValue, _extends2));
	          urlValues = _extends({}, urlValues, (_extends3 = {}, _extends3[key] = selectedValue.value, _extends3));
	        } catch (e) {
	          // Do not add to selectedValues if JSON parsing fails.
	        }
	      });
	      var themePreset = props.themePreset,
	        enableAppbase = props.enableAppbase,
	        endpoint = props.endpoint;
	      var appbaseRef = appbasejs(config);
	      appbaseRef.transformRequest = function (request) {
	        var modifiedRequest = enableAppbase ? helper_1(request, endpoint) : request;
	        if (props.transformRequest) return props.transformRequest(modifiedRequest);
	        return modifiedRequest;
	      };
	      if (this.$props.transformResponse) {
	        appbaseRef.transformResponse = this.$props.transformResponse;
	      }
	      var analyticsInitConfig = {
	        url: url && url.replace(/\/\/.*@/, '//'),
	        credentials: appbaseRef.credentials,
	        // When endpoint prop is used index is not defined, so we use _default
	        index: appbaseRef.app || '_default',
	        globalCustomEvents: this.$props.appbaseConfig && this.$props.appbaseConfig.customEvents
	      };
	      try {
	        if (this.$props.endpoint && this.$props.endpoint.url) {
	          // Remove parts between '//' and first '/' in the url
	          analyticsInitConfig.url = this.$props.endpoint.url.replace(/\/\/(.*?)\/.*/, '//$1');
	          var headerCredentials = this.$props.endpoint.headers && this.$props.endpoint.headers.Authorization;
	          analyticsInitConfig.credentials = headerCredentials && headerCredentials.replace('Basic ', '');
	          // Decode the credentials
	          analyticsInitConfig.credentials = analyticsInitConfig.credentials && atob(analyticsInitConfig.credentials);
	        }
	      } catch (e) {
	        console.error('Endpoint not set correctly for analytics');
	        console.error(e);
	      }
	      var analyticsRef = null;
	      if (config.analytics) {
	        analyticsRef = index$2.init(analyticsInitConfig);
	      }
	      var initialState = _extends({
	        config: _extends({}, config, {
	          initialQueriesSyncTime: props.initialQueriesSyncTime,
	          initialTimestamp: new Date().getTime(),
	          mapKey: props.mapKey,
	          themePreset: themePreset
	        }),
	        appbaseRef: appbaseRef,
	        analyticsRef: analyticsRef,
	        selectedValues: selectedValues,
	        urlValues: urlValues,
	        headers: this.getHeaders
	      }, this.$props.initialState);
	      this.store = configureStore(initialState);
	      this.analyticsRef = analyticsRef;
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var children = this.$slots["default"];
	    var _this$$props2 = this.$props,
	      style = _this$$props2.style,
	      className = _this$$props2.className;
	    return h(Provider, {
	      "attrs": {
	        "store": this.store,
	        "analyticsRef": this.analyticsRef
	      }
	    }, [h(URLParamsProvider$1, {
	      "attrs": {
	        "as": this.$props.as,
	        "headers": this.getHeaders,
	        "className": className,
	        "getSearchParams": this.getSearchParams,
	        "setSearchParams": this.setSearchParams
	      },
	      "style": style
	    }, [children])]);
	  }
	};
	ReactiveBase.install = function (Vue) {
	  Vue.component(ReactiveBase.name, ReactiveBase);
	};

	/**! 
	 * hotkeys-js v3.10.1 
	 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. 
	 * 
	 * Copyright (c) 2022 kenny wong <wowohoo@qq.com> 
	 * http://jaywcjlove.github.io/hotkeys 
	 * Licensed under the MIT license 
	 */

	var isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件

	function addEvent(object, event, method, useCapture) {
	  if (object.addEventListener) {
	    object.addEventListener(event, method, useCapture);
	  } else if (object.attachEvent) {
	    object.attachEvent("on".concat(event), function () {
	      method(window.event);
	    });
	  }
	} // 修饰键转换成对应的键码

	function getMods(modifier, key) {
	  var mods = key.slice(0, key.length - 1);
	  for (var i = 0; i < mods.length; i++) {
	    mods[i] = modifier[mods[i].toLowerCase()];
	  }
	  return mods;
	} // 处理传的key字符串转换成数组

	function getKeys(key) {
	  if (typeof key !== 'string') key = '';
	  key = key.replace(/\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等

	  var keys = key.split(','); // 同时设置多个快捷键，以','分割

	  var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理

	  for (; index >= 0;) {
	    keys[index - 1] += ',';
	    keys.splice(index, 1);
	    index = keys.lastIndexOf('');
	  }
	  return keys;
	} // 比较修饰键的数组

	function compareArray(a1, a2) {
	  var arr1 = a1.length >= a2.length ? a1 : a2;
	  var arr2 = a1.length >= a2.length ? a2 : a1;
	  var isIndex = true;
	  for (var i = 0; i < arr1.length; i++) {
	    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
	  }
	  return isIndex;
	}
	var _keyMap = {
	  backspace: 8,
	  '⌫': 8,
	  tab: 9,
	  clear: 12,
	  enter: 13,
	  '↩': 13,
	  "return": 13,
	  esc: 27,
	  escape: 27,
	  space: 32,
	  left: 37,
	  up: 38,
	  right: 39,
	  down: 40,
	  del: 46,
	  "delete": 46,
	  ins: 45,
	  insert: 45,
	  home: 36,
	  end: 35,
	  pageup: 33,
	  pagedown: 34,
	  capslock: 20,
	  num_0: 96,
	  num_1: 97,
	  num_2: 98,
	  num_3: 99,
	  num_4: 100,
	  num_5: 101,
	  num_6: 102,
	  num_7: 103,
	  num_8: 104,
	  num_9: 105,
	  num_multiply: 106,
	  num_add: 107,
	  num_enter: 108,
	  num_subtract: 109,
	  num_decimal: 110,
	  num_divide: 111,
	  '⇪': 20,
	  ',': 188,
	  '.': 190,
	  '/': 191,
	  '`': 192,
	  '-': isff ? 173 : 189,
	  '=': isff ? 61 : 187,
	  ';': isff ? 59 : 186,
	  '\'': 222,
	  '[': 219,
	  ']': 221,
	  '\\': 220
	}; // Modifier Keys

	var _modifier = {
	  // shiftKey
	  '⇧': 16,
	  shift: 16,
	  // altKey
	  '⌥': 18,
	  alt: 18,
	  option: 18,
	  // ctrlKey
	  '⌃': 17,
	  ctrl: 17,
	  control: 17,
	  // metaKey
	  '⌘': 91,
	  cmd: 91,
	  command: 91
	};
	var modifierMap = {
	  16: 'shiftKey',
	  18: 'altKey',
	  17: 'ctrlKey',
	  91: 'metaKey',
	  shiftKey: 16,
	  ctrlKey: 17,
	  altKey: 18,
	  metaKey: 91
	};
	var _mods = {
	  16: false,
	  18: false,
	  17: false,
	  91: false
	};
	var _handlers = {}; // F1~F12 special key

	for (var k = 1; k < 20; k++) {
	  _keyMap["f".concat(k)] = 111 + k;
	}
	var _downKeys = []; // 记录摁下的绑定键

	var winListendFocus = false; // window是否已经监听了focus事件

	var _scope = 'all'; // 默认热键范围

	var elementHasBindEvent = []; // 已绑定事件的节点记录
	// 返回键码

	var code = function code(x) {
	  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
	};
	var getKey = function getKey(x) {
	  return Object.keys(_keyMap).find(function (k) {
	    return _keyMap[k] === x;
	  });
	};
	var getModifier = function getModifier(x) {
	  return Object.keys(_modifier).find(function (k) {
	    return _modifier[k] === x;
	  });
	}; // 设置获取当前范围（默认为'所有'）

	function setScope(scope) {
	  _scope = scope || 'all';
	} // 获取当前范围

	function getScope() {
	  return _scope || 'all';
	} // 获取摁下绑定键的键值

	function getPressedKeyCodes() {
	  return _downKeys.slice(0);
	}
	function getPressedKeyString() {
	  return _downKeys.map(function (c) {
	    return getKey(c) || getModifier(c) || String.fromCharCode(c);
	  });
	} // 表单控件控件判断 返回 Boolean
	// hotkey is effective only when filter return true

	function filter(event) {
	  var target = event.target || event.srcElement;
	  var tagName = target.tagName;
	  var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>

	  if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {
	    flag = false;
	  }
	  return flag;
	} // 判断摁下的键是否为某个键，返回true或者false

	function isPressed(keyCode) {
	  if (typeof keyCode === 'string') {
	    keyCode = code(keyCode); // 转换成键码
	  }

	  return _downKeys.indexOf(keyCode) !== -1;
	} // 循环删除handlers中的所有 scope(范围)

	function deleteScope(scope, newScope) {
	  var handlers;
	  var i; // 没有指定scope，获取scope

	  if (!scope) scope = getScope();
	  for (var key in _handlers) {
	    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
	      handlers = _handlers[key];
	      for (i = 0; i < handlers.length;) {
	        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;
	      }
	    }
	  } // 如果scope被删除，将scope重置为all

	  if (getScope() === scope) setScope(newScope || 'all');
	} // 清除修饰键

	function clearModifier(event) {
	  var key = event.keyCode || event.which || event.charCode;
	  var i = _downKeys.indexOf(key); // 从列表中清除按压过的键

	  if (i >= 0) {
	    _downKeys.splice(i, 1);
	  } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题

	  if (event.key && event.key.toLowerCase() === 'meta') {
	    _downKeys.splice(0, _downKeys.length);
	  } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除

	  if (key === 93 || key === 224) key = 91;
	  if (key in _mods) {
	    _mods[key] = false; // 将修饰键重置为false

	    for (var k in _modifier) {
	      if (_modifier[k] === key) hotkeys[k] = false;
	    }
	  }
	}
	function unbind(keysInfo) {
	  // unbind(), unbind all keys
	  if (typeof keysInfo === 'undefined') {
	    Object.keys(_handlers).forEach(function (key) {
	      return delete _handlers[key];
	    });
	  } else if (Array.isArray(keysInfo)) {
	    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])
	    keysInfo.forEach(function (info) {
	      if (info.key) eachUnbind(info);
	    });
	  } else if (typeof keysInfo === 'object') {
	    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})
	    if (keysInfo.key) eachUnbind(keysInfo);
	  } else if (typeof keysInfo === 'string') {
	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    // support old method
	    // eslint-disable-line
	    var scope = args[0],
	      method = args[1];
	    if (typeof scope === 'function') {
	      method = scope;
	      scope = '';
	    }
	    eachUnbind({
	      key: keysInfo,
	      scope: scope,
	      method: method,
	      splitKey: '+'
	    });
	  }
	} // 解除绑定某个范围的快捷键

	var eachUnbind = function eachUnbind(_ref) {
	  var key = _ref.key,
	    scope = _ref.scope,
	    method = _ref.method,
	    _ref$splitKey = _ref.splitKey,
	    splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;
	  var multipleKeys = getKeys(key);
	  multipleKeys.forEach(function (originKey) {
	    var unbindKeys = originKey.split(splitKey);
	    var len = unbindKeys.length;
	    var lastKey = unbindKeys[len - 1];
	    var keyCode = lastKey === '*' ? '*' : code(lastKey);
	    if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围

	    if (!scope) scope = getScope();
	    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
	    _handlers[keyCode] = _handlers[keyCode].filter(function (record) {
	      // 通过函数判断，是否解除绑定，函数相等直接返回
	      var isMatchingMethod = method ? record.method === method : true;
	      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
	    });
	  });
	}; // 对监听对应快捷键的回调函数进行处理

	function eventHandler(event, handler, scope, element) {
	  if (handler.element !== element) {
	    return;
	  }
	  var modifiersMatch; // 看它是否在当前范围

	  if (handler.scope === scope || handler.scope === 'all') {
	    // 检查是否匹配修饰符（如果有返回true）
	    modifiersMatch = handler.mods.length > 0;
	    for (var y in _mods) {
	      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
	        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
	          modifiersMatch = false;
	        }
	      }
	    } // 调用处理程序，如果是修饰键不做处理

	    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {
	      if (handler.method(event, handler) === false) {
	        if (event.preventDefault) event.preventDefault();else event.returnValue = false;
	        if (event.stopPropagation) event.stopPropagation();
	        if (event.cancelBubble) event.cancelBubble = true;
	      }
	    }
	  }
	} // 处理keydown事件

	function dispatch(event, element) {
	  var asterisk = _handlers['*'];
	  var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键

	  if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致
	  // Webkit左右 command 键值不一样

	  if (key === 93 || key === 224) key = 91;
	  /**
	   * Collect bound keys
	   * If an Input Method Editor is processing key input and the event is keydown, return 229.
	   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229
	   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
	   */

	  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
	  /**
	   * Jest test cases are required.
	   * ===============================
	   */

	  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {
	    var keyNum = modifierMap[keyName];
	    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
	      _downKeys.push(keyNum);
	    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
	      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
	    } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {
	      /**
	       * Fix if Command is pressed:
	       * ===============================
	       */
	      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
	        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
	      }
	    }
	  });
	  /**
	   * -------------------------------
	   */

	  if (key in _mods) {
	    _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上

	    for (var k in _modifier) {
	      if (_modifier[k] === key) hotkeys[k] = true;
	    }
	    if (!asterisk) return;
	  } // 将 modifierMap 里面的修饰键绑定到 event 中

	  for (var e in _mods) {
	    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
	      _mods[e] = event[modifierMap[e]];
	    }
	  }
	  /**
	   * https://github.com/jaywcjlove/hotkeys/pull/129
	   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.
	   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.
	   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate
	   */

	  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {
	    if (_downKeys.indexOf(17) === -1) {
	      _downKeys.push(17);
	    }
	    if (_downKeys.indexOf(18) === -1) {
	      _downKeys.push(18);
	    }
	    _mods[17] = true;
	    _mods[18] = true;
	  } // 获取范围 默认为 `all`

	  var scope = getScope(); // 对任何快捷键都需要做的处理

	  if (asterisk) {
	    for (var i = 0; i < asterisk.length; i++) {
	      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {
	        eventHandler(event, asterisk[i], scope, element);
	      }
	    }
	  } // key 不在 _handlers 中返回

	  if (!(key in _handlers)) return;
	  for (var _i = 0; _i < _handlers[key].length; _i++) {
	    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {
	      if (_handlers[key][_i].key) {
	        var record = _handlers[key][_i];
	        var splitKey = record.splitKey;
	        var keyShortcut = record.key.split(splitKey);
	        var _downKeysCurrent = []; // 记录当前按键键值

	        for (var a = 0; a < keyShortcut.length; a++) {
	          _downKeysCurrent.push(code(keyShortcut[a]));
	        }
	        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {
	          // 找到处理内容
	          eventHandler(event, record, scope, element);
	        }
	      }
	    }
	  }
	} // 判断 element 是否已经绑定事件

	function isElementBind(element) {
	  return elementHasBindEvent.indexOf(element) > -1;
	}
	function hotkeys(key, option, method) {
	  _downKeys = [];
	  var keys = getKeys(key); // 需要处理的快捷键列表

	  var mods = [];
	  var scope = 'all'; // scope默认为all，所有范围都有效

	  var element = document; // 快捷键事件绑定节点

	  var i = 0;
	  var keyup = false;
	  var keydown = true;
	  var splitKey = '+';
	  var capture = false; // 对为设定范围的判断

	  if (method === undefined && typeof option === 'function') {
	    method = option;
	  }
	  if (Object.prototype.toString.call(option) === '[object Object]') {
	    if (option.scope) scope = option.scope; // eslint-disable-line

	    if (option.element) element = option.element; // eslint-disable-line

	    if (option.keyup) keyup = option.keyup; // eslint-disable-line

	    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line

	    if (option.capture !== undefined) capture = option.capture; // eslint-disable-line

	    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line
	  }

	  if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理

	  for (; i < keys.length; i++) {
	    key = keys[i].split(splitKey); // 按键列表

	    mods = []; // 如果是组合快捷键取得组合快捷键

	    if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码

	    key = key[key.length - 1];
	    key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键
	    // 判断key是否在_handlers中，不在就赋一个空数组

	    if (!(key in _handlers)) _handlers[key] = [];
	    _handlers[key].push({
	      keyup: keyup,
	      keydown: keydown,
	      scope: scope,
	      mods: mods,
	      shortcut: keys[i],
	      method: method,
	      key: keys[i],
	      splitKey: splitKey,
	      element: element
	    });
	  } // 在全局document上设置快捷键

	  if (typeof element !== 'undefined' && !isElementBind(element) && window) {
	    elementHasBindEvent.push(element);
	    addEvent(element, 'keydown', function (e) {
	      dispatch(e, element);
	    }, capture);
	    if (!winListendFocus) {
	      winListendFocus = true;
	      addEvent(window, 'focus', function () {
	        _downKeys = [];
	      }, capture);
	    }
	    addEvent(element, 'keyup', function (e) {
	      dispatch(e, element);
	      clearModifier(e);
	    }, capture);
	  }
	}
	function trigger(shortcut) {
	  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';
	  Object.keys(_handlers).forEach(function (key) {
	    var dataList = _handlers[key].filter(function (item) {
	      return item.scope === scope && item.shortcut === shortcut;
	    });
	    dataList.forEach(function (data) {
	      if (data && data.method) {
	        data.method();
	      }
	    });
	  });
	}
	var _api = {
	  getPressedKeyString: getPressedKeyString,
	  setScope: setScope,
	  getScope: getScope,
	  deleteScope: deleteScope,
	  getPressedKeyCodes: getPressedKeyCodes,
	  isPressed: isPressed,
	  filter: filter,
	  trigger: trigger,
	  unbind: unbind,
	  keyMap: _keyMap,
	  modifier: _modifier,
	  modifierMap: modifierMap
	};
	for (var a in _api) {
	  if (Object.prototype.hasOwnProperty.call(_api, a)) {
	    hotkeys[a] = _api[a];
	  }
	}
	if (typeof window !== 'undefined') {
	  var _hotkeys = window.hotkeys;
	  hotkeys.noConflict = function (deep) {
	    if (deep && window.hotkeys === hotkeys) {
	      window.hotkeys = _hotkeys;
	    }
	    return hotkeys;
	  };
	  window.hotkeys = hotkeys;
	}

	var _templateObject$8;
	var InputGroup = index$1('div')(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: stretch;\n  width: 100%;\n"])));
	InputGroup.defaultProps = {
	  className: 'input-group'
	};

	var _templateObject$9;
	var InputWrapper = index$1('span')(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteralLoose(["\n  flex: 1;\n  position: relative;\n"])));

	var _templateObject$a;
	var InputAddon = index$1('span')(_templateObject$a || (_templateObject$a = _taggedTemplateLiteralLoose(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: #fafafa;\n  border: 1px solid #ccc;\n  border-radius: 2px;\n  color: rgba(0, 0, 0, 0.85);\n  font-size: 14px;\n  font-weight: 400;\n  padding: 0 11px;\n  position: relative;\n  transition: all 0.3s;\n  box-sizing: border-box;\n  overflow: hidden;\n\n  &:first-of-type {\n    border-right: none;\n  }\n  &:last-of-type {\n    border-left: none;\n  }\n"])));
	InputAddon.defaultProps = {
	  className: 'input-addon'
	};

	var _templateObject$b, _templateObject2$5, _templateObject3$4, _templateObject4$3, _templateObject5$2, _templateObject6$2, _templateObject7$2, _templateObject8$2, _templateObject9$1, _templateObject10$1, _templateObject11$1, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16;
	var alertBorder = function alertBorder(_ref) {
	  var theme = _ref.theme;
	  return css(_templateObject$b || (_templateObject$b = _taggedTemplateLiteralLoose(["\n\tborder: 1px solid ", ";\n"])), theme.colors.alertColor);
	};
	var input = css(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteralLoose(["\n\twidth: 100%;\n\tline-height: 1.5;\n\tmin-height: 42px;\n\tpadding: 8px 12px;\n\tborder: 1px solid #ccc;\n\tbackground-color: #fafafa;\n\tfont-size: 0.9rem;\n\toutline: none;\n\theight: 100%;\n\n\t&:focus {\n\t\tbackground-color: #fff;\n\t}\n"])));
	var dark$1 = function dark(theme) {
	  return css(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteralLoose(["\n\tborder-color: ", ";\n"])), theme.colors.borderColor);
	};
	var darkInput = function darkInput(_ref2) {
	  var theme = _ref2.theme;
	  return css(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteralLoose(["\n\tbackground-color: ", ";\n\tcolor: ", ";\n\t", ";\n\n\t&:focus {\n\t\tbackground-color: ", ";\n\t}\n"])), theme.colors.backgroundColor, theme.colors.textColor, dark$1(theme), theme.colors.backgroundColor);
	};
	var Input = index$1('input')(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteralLoose(["\n\t", ";\n\t", ";\n\n\t", ";\n\n\t", ";\n\n\t", ";\n\t", ";\n\n\t", ";\n\n\t", ";\n\t", ";\n\t", ";\n\n\t", ";\n"])), input, function (_ref3) {
	  var themePreset = _ref3.themePreset,
	    theme = _ref3.theme;
	  return themePreset === 'dark' && darkInput({
	    theme: theme
	  });
	}, function (props) {
	  return props.showIcon && props.iconPosition === 'left' && css(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-left: 36px;\n\t\t"])));
	}, function (props) {
	  return props.showIcon && props.iconPosition === 'right' && css(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 36px;\n\t\t"])));
	}, function (props) {
	  return (
	    // for clear icon
	    props.showClear && css(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 36px;\n\t\t"])))
	  );
	}, function (props) {
	  return (
	    // for voice search icon
	    props.showVoiceSearch && css(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 36px;\n\t\t"])))
	  );
	}, function (props) {
	  return (
	    // for clear icon with search icon
	    props.showClear && props.showIcon && props.iconPosition === 'right' && css(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 66px;\n\t\t"])))
	  );
	}, function (props) {
	  return (
	    // for voice search icon with search icon
	    props.showVoiceSearch && props.showIcon && props.iconPosition === 'right' && css(_templateObject11$1 || (_templateObject11$1 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 66px;\n\t\t"])))
	  );
	}, function (props) {
	  return (
	    // for voice search icon with clear icon
	    props.showVoiceSearch && props.showIcon && css(_templateObject12 || (_templateObject12 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 66px;\n\t\t"])))
	  );
	}, function (props) {
	  return (
	    // for clear icon with search icon and voice search
	    props.showClear && props.showIcon && props.showVoiceSearch && props.iconPosition === 'right' && css(_templateObject13 || (_templateObject13 = _taggedTemplateLiteralLoose(["\n\t\t\tpadding-right: 90px;\n\t\t"])))
	  );
	}, function (props) {
	  return props.alert && alertBorder;
	});
	var suggestions$1 = function suggestions(themePreset, theme) {
	  return css(_templateObject14 || (_templateObject14 = _taggedTemplateLiteralLoose(["\n\tdisplay: block;\n\twidth: 100%;\n\tborder: 1px solid #ccc;\n\tborder-top: none;\n\tbackground-color: #fff;\n\tfont-size: 0.9rem;\n\tz-index: 3;\n\tposition: absolute;\n\tmargin: 0;\n\tpadding: 0;\n\tlist-style: none;\n\tmax-height: min(100vh, 402px);\n\toverflow-y: auto;\n\n\t&.small {\n\t\ttop: 30px;\n\t}\n\n\tli {\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\tcursor: pointer;\n\t\tpadding: 10px;\n\t\tuser-select: none;\n\n\t\t& > .trim {\n\t\t\tdisplay: -webkit-box;\n\t\t\tdisplay: block;\n\t\t\twidth: 100%;\n\t\t\tmax-height: 2.3rem;\n\t\t\tline-height: 1.2rem;\n\t\t\t-webkit-line-clamp: 2;\n\t\t\t-webkit-box-orient: vertical;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t\twhite-space: nowrap;\n\t\t}\n\n\t\t&:hover,\n\t\t&:focus {\n\t\t\tbackground-color: #eee;\n\t\t}\n\t}\n\n\t", ";\n"])), themePreset === 'dark' && theme && dark$1(theme));
	};
	var suggestionsContainer = css(_templateObject15 || (_templateObject15 = _taggedTemplateLiteralLoose(["\n\tposition: relative;\n\t.cancel-icon {\n\t\tcursor: pointer;\n\t}\n"])));
	var noSuggestions = function noSuggestions(themePreset, theme) {
	  return css(_templateObject16 || (_templateObject16 = _taggedTemplateLiteralLoose(["\n\tdisplay: block;\n\twidth: 100%;\n\tborder: 1px solid #ccc;\n\tborder-top: none;\n\tbackground-color: #fff;\n\tfont-size: 0.9rem;\n\tz-index: 3;\n\tposition: absolute;\n\tmargin: 0;\n\tpadding: 0;\n\tlist-style: none;\n\tmax-height: 260px;\n\toverflow-y: auto;\n\n\t&.small {\n\t\ttop: 30px;\n\t}\n\n\tli {\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\tpadding: 10px;\n\t\tuser-select: none;\n\n\t\t& > .trim {\n\t\t\tdisplay: -webkit-box;\n\t\t\tdisplay: block;\n\t\t\twidth: 100%;\n\t\t\tmax-height: 2.3rem;\n\t\t\tline-height: 1.2rem;\n\t\t\t-webkit-line-clamp: 2;\n\t\t\t-webkit-box-orient: vertical;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t\twhite-space: nowrap;\n\t\t}\n\t}\n\n\t", "\n"])), themePreset === 'dark' && theme && dark$1(theme));
	};

	var _templateObject$c, _templateObject2$6, _templateObject3$5, _templateObject4$4;
	var IconGroup = index$1('div')(_templateObject$c || (_templateObject$c = _taggedTemplateLiteralLoose(["\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tgrid-gap: 6px;\n\tmargin: 0 10px;\n\theight: 100%;\n\n\t", ";\n\n\t", ";\n"])), function (_ref) {
	  var positionType = _ref.positionType;
	  if (positionType === 'absolute') {
	    return css(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteralLoose(["\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 50%;\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t"])));
	  }
	  return null;
	}, function (_ref2) {
	  var groupPosition = _ref2.groupPosition;
	  return groupPosition === 'right' ? css(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteralLoose(["\n\t\t\t\t\tright: 0;\n\t\t\t  "]))) : css(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteralLoose(["\n\t\t\t\t\tleft: 0;\n\t\t\t  "])));
	});

	var _templateObject$d;
	var IconWrapper = index$1('div')(_templateObject$d || (_templateObject$d = _taggedTemplateLiteralLoose(["\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tmax-width: 23px;\n\twidth: max-content;\n\tcursor: pointer;\n\theight: 100%;min-width:20px;\n\n\tsvg.search-icon {\n\t\tfill: ", ";\n\t\ttransform:scale(1.5);\n\t}\n\n\tsvg.cancel-icon {\n\t\tfill: ", ";\n\t}\n"])), function (_ref) {
	  var theme = _ref.theme;
	  return theme.colors.primaryColor;
	}, function (_ref2) {
	  var theme = _ref2.theme;
	  return theme.colors.borderColor || '#000';
	});

	function t(t) {
	  return "object" == typeof t && null != t && 1 === t.nodeType;
	}
	function e(t, e) {
	  return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t;
	}
	function n(t, n) {
	  if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
	    var r = getComputedStyle(t, null);
	    return e(r.overflowY, n) || e(r.overflowX, n) || function (t) {
	      var e = function (t) {
	        if (!t.ownerDocument || !t.ownerDocument.defaultView) return null;
	        try {
	          return t.ownerDocument.defaultView.frameElement;
	        } catch (t) {
	          return null;
	        }
	      }(t);
	      return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth);
	    }(t);
	  }
	  return !1;
	}
	function r(t, e, n, r, i, o, l, d) {
	  return o < t && l > e || o > t && l < e ? 0 : o <= t && d <= n || l >= e && d >= n ? o - t - r : l > e && d < n || o < t && d > n ? l - e + i : 0;
	}
	function computeScrollIntoView (e, i) {
	  var o = window,
	    l = i.scrollMode,
	    d = i.block,
	    u = i.inline,
	    h = i.boundary,
	    a = i.skipOverflowHiddenElements,
	    c = "function" == typeof h ? h : function (t) {
	      return t !== h;
	    };
	  if (!t(e)) throw new TypeError("Invalid target");
	  for (var f = document.scrollingElement || document.documentElement, s = [], p = e; t(p) && c(p);) {
	    if ((p = p.parentElement) === f) {
	      s.push(p);
	      break;
	    }
	    null != p && p === document.body && n(p) && !n(document.documentElement) || null != p && n(p, a) && s.push(p);
	  }
	  for (var m = o.visualViewport ? o.visualViewport.width : innerWidth, g = o.visualViewport ? o.visualViewport.height : innerHeight, w = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, W = e.getBoundingClientRect(), b = W.height, H = W.width, y = W.top, E = W.right, M = W.bottom, V = W.left, x = "start" === d || "nearest" === d ? y : "end" === d ? M : y + b / 2, I = "center" === u ? V + H / 2 : "end" === u ? E : V, C = [], T = 0; T < s.length; T++) {
	    var k = s[T],
	      B = k.getBoundingClientRect(),
	      D = B.height,
	      O = B.width,
	      R = B.top,
	      X = B.right,
	      Y = B.bottom,
	      L = B.left;
	    if ("if-needed" === l && y >= 0 && V >= 0 && M <= g && E <= m && y >= R && M <= Y && V >= L && E <= X) return C;
	    var S = getComputedStyle(k),
	      j = parseInt(S.borderLeftWidth, 10),
	      q = parseInt(S.borderTopWidth, 10),
	      z = parseInt(S.borderRightWidth, 10),
	      A = parseInt(S.borderBottomWidth, 10),
	      F = 0,
	      G = 0,
	      J = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - j - z : 0,
	      K = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - q - A : 0;
	    if (f === k) F = "start" === d ? x : "end" === d ? x - g : "nearest" === d ? r(v, v + g, g, q, A, v + x, v + x + b, b) : x - g / 2, G = "start" === u ? I : "center" === u ? I - m / 2 : "end" === u ? I - m : r(w, w + m, m, j, z, w + I, w + I + H, H), F = Math.max(0, F + v), G = Math.max(0, G + w);else {
	      F = "start" === d ? x - R - q : "end" === d ? x - Y + A + K : "nearest" === d ? r(R, Y, D, q, A + K, x, x + b, b) : x - (R + D / 2) + K / 2, G = "start" === u ? I - L - j : "center" === u ? I - (L + O / 2) + J / 2 : "end" === u ? I - X + z + J : r(L, X, O, j, z + J, I, I + H, H);
	      var N = k.scrollLeft,
	        P = k.scrollTop;
	      x += P - (F = Math.max(0, Math.min(P + F, k.scrollHeight - D + K))), I += N - (G = Math.max(0, Math.min(N + G, k.scrollWidth - O + J)));
	    }
	    C.push({
	      el: k,
	      top: F,
	      left: G
	    });
	  }
	  return C;
	}

	/**
	 * Scroll node into view if necessary
	 * @param {HTMLElement} node the element that should scroll into view
	 * @param {HTMLElement} rootNode the root element of the component
	 */
	// eslint-disable-next-line
	var scrollIntoView = function scrollIntoView(node, rootNode) {
	  if (node === null) {
	    return;
	  }
	  var actions = computeScrollIntoView(node, {
	    boundary: rootNode,
	    block: 'nearest',
	    scrollMode: 'if-needed'
	  });
	  actions.forEach(function (_ref) {
	    var el = _ref.el,
	      top = _ref.top,
	      left = _ref.left;
	    el.scrollTop = top;
	    el.scrollLeft = left;
	  });
	};

	var Downshift = {
	  // eslint-disable-next-line
	  props: ['isOpen', 'inputValue', 'selectedItem', 'highlightedIndex', 'handleChange', 'itemToString', 'handleMouseup'],
	  data: function data() {
	    return {
	      isMouseDown: false,
	      internal_isOpen: false,
	      internal_inputValue: '',
	      internal_selectedItem: null,
	      internal_highlightedIndex: null
	    };
	  },
	  computed: {
	    mergedState: function mergedState() {
	      var _this = this;
	      return Object.keys(this.$props).reduce(function (state, key) {
	        var _extends2;
	        return _extends({}, state, (_extends2 = {}, _extends2[key] = _this.isControlledProp(key) ? _this.$props[key] : _this["internal_" + key], _extends2));
	      }, {});
	    },
	    internalItemCount: function internalItemCount() {
	      return this.items.length;
	    }
	  },
	  mounted: function mounted() {
	    window.addEventListener('mousedown', this.handleWindowMousedown);
	    window.addEventListener('mouseup', this.handleWindowMouseup);
	  },
	  beforeDestroy: function beforeDestroy() {
	    window.removeEventListener('mousedown', this.handleWindowMousedown);
	    window.removeEventListener('mouseup', this.handleWindowMouseup);
	  },
	  methods: {
	    handleWindowMousedown: function handleWindowMousedown() {
	      this.isMouseDown = true;
	    },
	    handleWindowMouseup: function handleWindowMouseup(event) {
	      this.isMouseDown = false;
	      if ((event.target === this.$refs.rootNode || !this.$refs.rootNode.contains(event.target)) && this.mergedState.isOpen) {
	        // TODO: handle on outer click here
	        if (!this.isMouseDown) {
	          this.reset();
	          if (this.$props.handleMouseup) {
	            this.$props.handleMouseup({
	              isOpen: false
	            });
	          }
	        }
	      }
	    },
	    keyDownArrowDown: function keyDownArrowDown(event) {
	      event.preventDefault();
	      var amount = event.shiftKey ? 5 : 1;
	      if (this.mergedState.isOpen) {
	        this.changeHighlightedIndex(amount);
	      } else {
	        this.setState({
	          isOpen: true
	        });
	        this.setHighlightedIndex();
	      }
	    },
	    keyDownArrowUp: function keyDownArrowUp(event) {
	      event.preventDefault();
	      var amount = event.shiftKey ? -5 : -1;
	      if (this.mergedState.isOpen) {
	        this.changeHighlightedIndex(amount);
	      } else {
	        this.setState({
	          isOpen: true
	        });
	        this.setHighlightedIndex();
	      }
	    },
	    keyDownEnter: function keyDownEnter(event) {
	      if (this.mergedState.isOpen) {
	        event.preventDefault();
	        this.selectHighlightedItem();
	      }
	    },
	    keyDownEscape: function keyDownEscape(event) {
	      event.preventDefault();
	      this.reset();
	    },
	    selectHighlightedItem: function selectHighlightedItem() {
	      return this.selectItemAtIndex(this.mergedState.highlightedIndex);
	    },
	    selectItemAtIndex: function selectItemAtIndex(itemIndex) {
	      var item = this.items[itemIndex];
	      if (item == null) {
	        return;
	      }
	      this.selectItem(item);
	    },
	    selectItem: function selectItem(item) {
	      if (this.$props.handleChange) {
	        this.$props.handleChange(item);
	      }
	      function getInputValue() {
	        if (this.isControlledProp('selectedItem')) {
	          return '';
	        }
	        return typeof item === 'object' ? item.label || '' : item;
	      }
	      this.setState({
	        isOpen: false,
	        highlightedIndex: null,
	        selectedItem: item,
	        inputValue: getInputValue.call(this)
	      });
	    },
	    changeHighlightedIndex: function changeHighlightedIndex(moveAmount) {
	      if (this.internalItemCount < 0) {
	        return;
	      }
	      var highlightedIndex = this.mergedState.highlightedIndex;
	      var baseIndex = highlightedIndex;
	      if (baseIndex === null) {
	        baseIndex = moveAmount > 0 ? -1 : this.internalItemCount + 1;
	      }
	      var newIndex = baseIndex + moveAmount;
	      if (newIndex < 0) {
	        newIndex = this.internalItemCount;
	      } else if (newIndex > this.internalItemCount) {
	        newIndex = 0;
	      }
	      this.setHighlightedIndex(newIndex);
	    },
	    setHighlightedIndex: function setHighlightedIndex(highlightedIndex) {
	      if (highlightedIndex === void 0) {
	        highlightedIndex = null;
	      }
	      this.setState({
	        highlightedIndex: highlightedIndex
	      });
	      var element = document.getElementById("Downshift" + highlightedIndex);
	      scrollIntoView(element, this.rootNode);
	      // Implement scrollIntroView thingy
	    },
	    reset: function reset() {
	      var selectedItem = this.mergedState.selectedItem;
	      this.setState({
	        isOpen: false,
	        highlightedIndex: null,
	        inputValue: selectedItem
	      });
	    },
	    getItemProps: function getItemProps(_ref) {
	      var index = _ref.index,
	        item = _ref.item;
	      var newIndex = index;
	      if (index === undefined) {
	        if (this.$props.itemToString) {
	          this.items.push(this.$props.itemToString(item));
	        } else {
	          this.items.push(item);
	        }
	        newIndex = this.items.indexOf(item);
	      } else {
	        this.items[newIndex] = item;
	      }
	      return {
	        id: "Downshift" + newIndex
	      };
	    },
	    getItemEvents: function getItemEvents(_ref2) {
	      var index = _ref2.index,
	        item = _ref2.item;
	      var newIndex = index;
	      if (index === undefined) {
	        newIndex = this.items.indexOf(item);
	      }
	      var vm = this;
	      return {
	        mouseenter: function mouseenter() {
	          vm.setHighlightedIndex(newIndex);
	        },
	        click: function click(event) {
	          event.stopPropagation();
	          vm.selectItemAtIndex(newIndex);
	        }
	      };
	    },
	    getInputProps: function getInputProps(_ref3) {
	      var value = _ref3.value;
	      var inputValue = this.mergedState.inputValue;
	      if (value !== inputValue) {
	        this.setState({
	          inputValue: value
	        });
	      }
	      return {
	        value: inputValue
	      };
	    },
	    getButtonProps: function getButtonProps(_ref4) {
	      var _this2 = this;
	      var onClick = _ref4.onClick,
	        onKeyDown = _ref4.onKeyDown,
	        onKeyUp = _ref4.onKeyUp,
	        onBlur = _ref4.onBlur;
	      return {
	        click: function click(event) {
	          _this2.setState({
	            isOpen: true,
	            inputValue: event.target.value
	          });
	          if (onClick) {
	            onClick(event);
	          }
	        },
	        keydown: function keydown(event) {
	          if (event.key && _this2["keyDown" + event.key]) {
	            _this2["keyDown" + event.key].call(_this2, event);
	          }
	          if (onKeyDown) {
	            onKeyDown(event);
	          }
	        },
	        keyup: function keyup(event) {
	          if (onKeyUp) {
	            onKeyUp(event);
	          }
	        },
	        blur: function blur(event) {
	          if (onBlur) {
	            onBlur(event);
	          }
	        }
	      };
	    },
	    getInputEvents: function getInputEvents(_ref5) {
	      var _this3 = this;
	      var onInput = _ref5.onInput,
	        onBlur = _ref5.onBlur,
	        onFocus = _ref5.onFocus,
	        onKeyPress = _ref5.onKeyPress,
	        onKeyDown = _ref5.onKeyDown,
	        onKeyUp = _ref5.onKeyUp,
	        onClick = _ref5.onClick;
	      return {
	        input: function input(event) {
	          _this3.setState({
	            isOpen: true,
	            inputValue: event.target.value
	          });
	          if (onInput) {
	            onInput(event);
	          }
	        },
	        focus: function focus(event) {
	          if (onFocus) {
	            onFocus(event);
	          }
	        },
	        keydown: function keydown(event) {
	          if (event.key && _this3["keyDown" + event.key]) {
	            _this3["keyDown" + event.key].call(_this3, event);
	          }
	          if (onKeyDown) {
	            onKeyDown(event);
	          }
	        },
	        keypress: function keypress(event) {
	          if (onKeyPress) {
	            onKeyPress(event);
	          }
	        },
	        keyup: function keyup(event) {
	          if (onKeyUp) {
	            onKeyUp(event);
	          }
	        },
	        blur: function blur(event) {
	          if (onBlur) {
	            onBlur(event);
	          }
	          // TODO: implement isMouseDown
	          // this.reset()
	        },

	        click: onClick
	      };
	    },
	    getHelpersAndState: function getHelpersAndState() {
	      var getItemProps = this.getItemProps,
	        getItemEvents = this.getItemEvents,
	        getInputProps = this.getInputProps,
	        getInputEvents = this.getInputEvents,
	        getButtonProps = this.getButtonProps,
	        setHighlightedIndex = this.setHighlightedIndex;
	      return _extends({
	        getItemProps: getItemProps,
	        getItemEvents: getItemEvents,
	        getInputProps: getInputProps,
	        getInputEvents: getInputEvents,
	        getButtonProps: getButtonProps,
	        setHighlightedIndex: setHighlightedIndex
	      }, this.mergedState);
	    },
	    isControlledProp: function isControlledProp(prop) {
	      return this.$props[prop] !== undefined;
	    },
	    setState: function setState(stateToSet) {
	      var _this4 = this;
	      // eslint-disable-next-line
	      Object.keys(stateToSet).forEach(function (key) {
	        // eslint-disable-next-line
	        if (_this4.isControlledProp(key)) {
	          _this4.$emit(key + "Change", stateToSet[key]);
	          _this4.$emit(key + "-change", stateToSet[key]);
	        } else {
	          _this4["internal_" + key] = stateToSet[key];
	        }
	      });
	      this.$emit('stateChange', this.mergedState);
	      this.$emit('state-change', this.mergedState);
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    this.items = [];
	    return h("div", {
	      "ref": "rootNode"
	    }, [this.$scopedSlots["default"] && this.$scopedSlots["default"](_extends({}, this.getHelpersAndState()))]);
	  }
	};

	var _templateObject$e;
	var Container = index$1('div')(_templateObject$e || (_templateObject$e = _taggedTemplateLiteralLoose(["\n\t", ";\n"])), function (_ref) {
	  var theme = _ref.theme;
	  return theme.component;
	});

	var getClassName$2 = lib_8.getClassName;
	var SuggestionWrapper = {
	  name: 'SuggestionWrapper',
	  props: {
	    innerClassName: types.string,
	    themePreset: types.themePreset,
	    innerClass: types.style
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      themePreset = _this$$props.themePreset,
	      innerClass = _this$$props.innerClass,
	      innerClassName = _this$$props.innerClassName;
	    return h("div", {
	      "class": noSuggestions(themePreset) + " " + getClassName$2(innerClass, innerClassName || '')
	    }, [h("li", [this.$scopedSlots["default"]()])]);
	  }
	};

	var dist = createCommonjsModule(function (module) {
	  module.exports = /******/function (modules) {
	    // webpackBootstrap
	    /******/ // The module cache
	    /******/
	    var installedModules = {};
	    /******/
	    /******/ // The require function
	    /******/
	    function __webpack_require__(moduleId) {
	      /******/
	      /******/ // Check if module is in cache
	      /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;
	      /******/
	      /******/ // Create a new module (and put it into the cache)
	      /******/
	      var module = installedModules[moduleId] = {
	        /******/exports: {},
	        /******/id: moduleId,
	        /******/loaded: false
	        /******/
	      };
	      /******/
	      /******/ // Execute the module function
	      /******/
	      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	      /******/
	      /******/ // Flag the module as loaded
	      /******/
	      module.loaded = true;
	      /******/
	      /******/ // Return the exports of the module
	      /******/
	      return module.exports;
	      /******/
	    }
	    /******/
	    /******/
	    /******/ // expose the modules object (__webpack_modules__)
	    /******/
	    __webpack_require__.m = modules;
	    /******/
	    /******/ // expose the module cache
	    /******/
	    __webpack_require__.c = installedModules;
	    /******/
	    /******/ // __webpack_public_path__
	    /******/
	    __webpack_require__.p = "";
	    /******/
	    /******/ // Load entry module and return exports
	    /******/
	    return __webpack_require__(0);
	    /******/
	  }
	  /************************************************************************/
	  /******/([/* 0 */
	  /***/function (module, exports, __webpack_require__) {
	    module.exports = __webpack_require__(1);

	    /***/
	  }, /* 1 */
	  /***/function (module, exports, __webpack_require__) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    var _utils = __webpack_require__(2);
	    Object.defineProperty(exports, 'combineChunks', {
	      enumerable: true,
	      get: function get() {
	        return _utils.combineChunks;
	      }
	    });
	    Object.defineProperty(exports, 'fillInChunks', {
	      enumerable: true,
	      get: function get() {
	        return _utils.fillInChunks;
	      }
	    });
	    Object.defineProperty(exports, 'findAll', {
	      enumerable: true,
	      get: function get() {
	        return _utils.findAll;
	      }
	    });
	    Object.defineProperty(exports, 'findChunks', {
	      enumerable: true,
	      get: function get() {
	        return _utils.findChunks;
	      }
	    });

	    /***/
	  }, /* 2 */
	  /***/function (module, exports) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });

	    /**
	     * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.
	     * @return Array of "chunks" (where a Chunk is { start:number, end:number, highlight:boolean })
	     */
	    var findAll = exports.findAll = function findAll(_ref) {
	      var autoEscape = _ref.autoEscape,
	        _ref$caseSensitive = _ref.caseSensitive,
	        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,
	        _ref$findChunks = _ref.findChunks,
	        findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,
	        sanitize = _ref.sanitize,
	        searchWords = _ref.searchWords,
	        textToHighlight = _ref.textToHighlight;
	      return fillInChunks({
	        chunksToHighlight: combineChunks({
	          chunks: findChunks({
	            autoEscape: autoEscape,
	            caseSensitive: caseSensitive,
	            sanitize: sanitize,
	            searchWords: searchWords,
	            textToHighlight: textToHighlight
	          })
	        }),
	        totalLength: textToHighlight ? textToHighlight.length : 0
	      });
	    };

	    /**
	     * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.
	     * @return {start:number, end:number}[]
	     */

	    var combineChunks = exports.combineChunks = function combineChunks(_ref2) {
	      var chunks = _ref2.chunks;
	      chunks = chunks.sort(function (first, second) {
	        return first.start - second.start;
	      }).reduce(function (processedChunks, nextChunk) {
	        // First chunk just goes straight in the array...
	        if (processedChunks.length === 0) {
	          return [nextChunk];
	        } else {
	          // ... subsequent chunks get checked to see if they overlap...
	          var prevChunk = processedChunks.pop();
	          if (nextChunk.start <= prevChunk.end) {
	            // It may be the case that prevChunk completely surrounds nextChunk, so take the
	            // largest of the end indeces.
	            var endIndex = Math.max(prevChunk.end, nextChunk.end);
	            processedChunks.push({
	              highlight: false,
	              start: prevChunk.start,
	              end: endIndex
	            });
	          } else {
	            processedChunks.push(prevChunk, nextChunk);
	          }
	          return processedChunks;
	        }
	      }, []);
	      return chunks;
	    };

	    /**
	     * Examine text for any matches.
	     * If we find matches, add them to the returned array as a "chunk" object ({start:number, end:number}).
	     * @return {start:number, end:number}[]
	     */
	    var defaultFindChunks = function defaultFindChunks(_ref3) {
	      var autoEscape = _ref3.autoEscape,
	        caseSensitive = _ref3.caseSensitive,
	        _ref3$sanitize = _ref3.sanitize,
	        sanitize = _ref3$sanitize === undefined ? defaultSanitize : _ref3$sanitize,
	        searchWords = _ref3.searchWords,
	        textToHighlight = _ref3.textToHighlight;
	      textToHighlight = sanitize(textToHighlight);
	      return searchWords.filter(function (searchWord) {
	        return searchWord;
	      }) // Remove empty words
	      .reduce(function (chunks, searchWord) {
	        searchWord = sanitize(searchWord);
	        if (autoEscape) {
	          searchWord = escapeRegExpFn(searchWord);
	        }
	        var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');
	        var match = void 0;
	        while (match = regex.exec(textToHighlight)) {
	          var _start = match.index;
	          var _end = regex.lastIndex;
	          // We do not return zero-length matches
	          if (_end > _start) {
	            chunks.push({
	              highlight: false,
	              start: _start,
	              end: _end
	            });
	          }

	          // Prevent browsers like Firefox from getting stuck in an infinite loop
	          // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/
	          if (match.index === regex.lastIndex) {
	            regex.lastIndex++;
	          }
	        }
	        return chunks;
	      }, []);
	    };
	    // Allow the findChunks to be overridden in findAll,
	    // but for backwards compatibility we export as the old name
	    exports.findChunks = defaultFindChunks;

	    /**
	     * Given a set of chunks to highlight, create an additional set of chunks
	     * to represent the bits of text between the highlighted text.
	     * @param chunksToHighlight {start:number, end:number}[]
	     * @param totalLength number
	     * @return {start:number, end:number, highlight:boolean}[]
	     */

	    var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {
	      var chunksToHighlight = _ref4.chunksToHighlight,
	        totalLength = _ref4.totalLength;
	      var allChunks = [];
	      var append = function append(start, end, highlight) {
	        if (end - start > 0) {
	          allChunks.push({
	            start: start,
	            end: end,
	            highlight: highlight
	          });
	        }
	      };
	      if (chunksToHighlight.length === 0) {
	        append(0, totalLength, false);
	      } else {
	        var lastIndex = 0;
	        chunksToHighlight.forEach(function (chunk) {
	          append(lastIndex, chunk.start, false);
	          append(chunk.start, chunk.end, true);
	          lastIndex = chunk.end;
	        });
	        append(lastIndex, totalLength, false);
	      }
	      return allChunks;
	    };
	    function defaultSanitize(string) {
	      return string;
	    }
	    function escapeRegExpFn(string) {
	      return string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	    }

	    /***/
	  }
	  /******/]);
	});

	unwrapExports(dist);
	var dist_1 = dist.findAll;

	/*!
	 * vue-highlight-words © Yichang Liu, 2019
	 *
	 * Version: 1.2.0
	 *
	 * LICENCE: MIT
	 *
	 * https://github.com/Astray-git/vue-highlight-words
	 *
	*/
	function _defineProperty$1(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};
	    var ownKeys = Object.keys(source);
	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }
	    ownKeys.forEach(function (key) {
	      _defineProperty$1(target, key, source[key]);
	    });
	  }
	  return target;
	}
	var VueHighlightWords = {
	  functional: true,
	  props: {
	    activeClassName: String,
	    activeIndex: Number,
	    activeStyle: Object,
	    autoEscape: Boolean,
	    findChunks: Function,
	    highlightClassName: String,
	    highlightStyle: Object,
	    highlightTag: [Object, Function, String],
	    sanitize: Function,
	    searchWords: {
	      type: Array,
	      // Array<string>
	      validator: function validator(value) {
	        return value.every(function (word) {
	          return typeof word === 'string';
	        });
	      },
	      required: true
	    },
	    textToHighlight: {
	      type: String,
	      required: true
	    },
	    unhighlightClassName: String,
	    unhighlightStyle: Object
	  },
	  render: function render(h, context) {
	    var _context$props = context.props,
	      _context$props$active = _context$props.activeClassName,
	      activeClassName = _context$props$active === void 0 ? '' : _context$props$active,
	      _context$props$active2 = _context$props.activeIndex,
	      activeIndex = _context$props$active2 === void 0 ? -1 : _context$props$active2,
	      activeStyle = _context$props.activeStyle,
	      autoEscape = _context$props.autoEscape,
	      _context$props$caseSe = _context$props.caseSensitive,
	      caseSensitive = _context$props$caseSe === void 0 ? false : _context$props$caseSe,
	      findChunks = _context$props.findChunks,
	      _context$props$highli = _context$props.highlightClassName,
	      highlightClassName = _context$props$highli === void 0 ? '' : _context$props$highli,
	      _context$props$highli2 = _context$props.highlightStyle,
	      highlightStyle = _context$props$highli2 === void 0 ? {} : _context$props$highli2,
	      _context$props$highli3 = _context$props.highlightTag,
	      highlightTag = _context$props$highli3 === void 0 ? 'mark' : _context$props$highli3,
	      sanitize = _context$props.sanitize,
	      searchWords = _context$props.searchWords,
	      textToHighlight = _context$props.textToHighlight,
	      _context$props$unhigh = _context$props.unhighlightClassName,
	      unhighlightClassName = _context$props$unhigh === void 0 ? '' : _context$props$unhigh,
	      unhighlightStyle = _context$props.unhighlightStyle;
	    var contextData = context.data;
	    var chunks = dist_1({
	      autoEscape: autoEscape,
	      caseSensitive: caseSensitive,
	      findChunks: findChunks,
	      sanitize: sanitize,
	      searchWords: searchWords,
	      textToHighlight: textToHighlight
	    });
	    var HighlightTag = highlightTag;
	    var highlightCount = -1;
	    var highlightClassNames = '';
	    var highlightStyles;
	    return h('span', _objectSpread({}, contextData), chunks.map(function (chunk, index) {
	      var text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);
	      if (chunk.highlight) {
	        highlightCount++;
	        var isActive = highlightCount === +activeIndex;
	        highlightClassNames = "".concat(highlightClassName, " ").concat(isActive ? activeClassName : '');
	        highlightStyles = isActive === true && activeStyle != null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;
	        var data = {
	          "class": highlightClassNames,
	          key: index,
	          style: highlightStyles
	        };
	        if (typeof HighlightTag !== 'string') {
	          // not plain html tag, add props for compoent
	          data.props = {
	            highlightIndex: highlightCount
	          };
	        }
	        if (contextData.scopedSlots) {
	          return h(HighlightTag, data, [contextData.scopedSlots["default"]({
	            children: text,
	            highlightIndex: highlightCount
	          })]);
	        }
	        return h(HighlightTag, data, text);
	      } else {
	        return h('span', {
	          "class": unhighlightClassName,
	          key: index,
	          style: unhighlightStyle
	        }, text);
	      }
	    }));
	  }
	};

	var _templateObject$f;
	var highlightStyle = {
	  fontWeight: 600,
	  padding: 0,
	  backgroundColor: 'transparent',
	  color: 'inherit'
	};
	var PredictiveSuggestion = index$1('span')(_templateObject$f || (_templateObject$f = _taggedTemplateLiteralLoose(["\n\t.highlight {\n\t\tbackground: transparent;\n\t\tcolor: inherit;\n\t\tfont-weight: 600;\n\t\tpadding: 0;\n\t}\n"])));
	var SuggestionItem = {
	  name: 'SuggestionItem',
	  props: {
	    currentValue: types.string,
	    suggestion: types.any
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$suggestion = this.suggestion,
	      label = _this$suggestion.label,
	      value = _this$suggestion.value,
	      title = _this$suggestion.title,
	      description = _this$suggestion.description,
	      image = _this$suggestion.image,
	      isPredictiveSuggestion = _this$suggestion.isPredictiveSuggestion,
	      _suggestion_type = _this$suggestion._suggestion_type,
	      _category = _this$suggestion._category;
	    if (label) {
	      // label has highest precedence
	      return typeof label === 'string' ? h("div", {
	        "class": "trim"
	      }, [(_category ? false : isPredictiveSuggestion
	      // eslint-disable-next-line
	      || !!_suggestion_type) ? h(PredictiveSuggestion, {
	        "domProps": {
	          "innerHTML": label
	        }
	      }) : h(VueHighlightWords, {
	        "attrs": {
	          "searchWords": _category ? [_category] : this.currentValue.split(' '),
	          "textToHighlight": label,
	          "autoEscape": true,
	          "highlightStyle": highlightStyle
	        }
	      })]) : label;
	    }
	    if (title || image || description) {
	      return h(Flex, {
	        "attrs": {
	          "alignItems": "center",
	          "css": {
	            width: '100%'
	          }
	        }
	      }, [image && h("div", {
	        "attrs": {
	          "css": {
	            margin: 'auto',
	            marginRight: 10
	          }
	        }
	      }, [h("img", {
	        "attrs": {
	          "src": image,
	          "alt": " ",
	          "height": "50px",
	          "width": "50px",
	          "css": {
	            objectFit: 'contain'
	          }
	        }
	      })]), h(Flex, {
	        "attrs": {
	          "direction": "column",
	          "css": {
	            width: image ? 'calc(100% - 60px)' : '100%'
	          }
	        }
	      }, [title && h("div", {
	        "class": "trim"
	      }, [h(VueHighlightWords, {
	        "attrs": {
	          "searchWords": this.currentValue.split(' '),
	          "textToHighlight": title,
	          "highlightStyle": highlightStyle
	        },
	        "class": css({
	          fontSize: '1rem'
	        })
	      })]), description && h("div", {
	        "class": cx('trim', css({
	          marginTop: 3
	        }))
	      }, [h(VueHighlightWords, {
	        "attrs": {
	          "searchWords": this.currentValue.split(' '),
	          "textToHighlight": description,
	          "highlightStyle": highlightStyle
	        }
	      })])])]);
	    }
	    return value;
	  }
	};

	var SearchSvg = {
	  name: 'SearchSvg',
	  props: ['styles'],
	  render: function render() {
	    var h = arguments[0];
	    return h("svg", {
	      "attrs": {
	        "alt": "Search",
	        "height": "12",
	        "xmlns": "http://www.w3.org/2000/svg",
	        "viewBox": "0 0 15 15"
	      },
	      "class": "search-icon",
	      "style": _extends({
	        transform: 'scale(1.35)',
	        position: 'relative'
	      }, this.$props.styles ? this.$props.styles : {})
	    }, [h("title", ["Search"]), h("path", {
	      "attrs": {
	        "d": 'M6.02945,10.20327a4.17382,4.17382,0,1,1,4.17382-4.17382A4.15609,4.15609,0,0,1,6.02945,10.20327Zm9.69195,4.2199L10.8989,9.59979A5.88021,5.88021,0,0,0,12.058,6.02856,6.00467,6.00467,0,1,0,9.59979,10.8989l4.82338,4.82338a.89729.89729,0,0,0,1.29912,0,.89749.89749,0,0,0-.00087-1.29909Z'
	      }
	    })]);
	  }
	};

	var CancelSvg = {
	  functional: true,
	  render: function render(h) {
	    return h("svg", {
	      "attrs": {
	        "alt": "Clear",
	        "xmlns": "http://www.w3.org/2000/svg",
	        "height": "20px",
	        "viewBox": "0 0 24 24",
	        "width": "20px"
	      },
	      "class": "cancel-icon"
	    }, [h("title", ["Clear"]), h("path", {
	      "attrs": {
	        "d": "M0 0h24v24H0V0z",
	        "fill": "none"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"
	      }
	    })]);
	  }
	};

	var _templateObject$g;

	// eslint-disable-next-line
	injectGlobal(_templateObject$g || (_templateObject$g = _taggedTemplateLiteralLoose(["\n\t#el_TvxDfTAtKp {\n\t\tstroke: none;\n\t\tstroke-width: 1;\n\t\tfill: none;\n\t}\n\t#el_D93PK3GbmJ {\n\t\t-webkit-transform: translate(163px, 131px);\n\t\ttransform: translate(163px, 131px);\n\t\tfill: #d8d8d8;\n\t}\n"])));
	var MicSvg = {
	  name: 'MicSvg',
	  props: ['className'],
	  render: function render() {
	    var h = arguments[0];
	    return h("svg", {
	      "attrs": {
	        "viewBox": "0 0 480 480",
	        "xmlns": "http://www.w3.org/2000/svg",
	        "id": "el_xS0FRzQjJ",
	        "width": 28,
	        "height": 28,
	        "className": this.$props.className
	      },
	      "style": {
	        transform: 'scale(1.5)'
	      }
	    }, [h("g", {
	      "attrs": {
	        "id": "el_TvxDfTAtKp",
	        "fillRule": "evenodd"
	      }
	    }, [h("g", {
	      "attrs": {
	        "id": "el_D93PK3GbmJ",
	        "fillRule": "nonzero"
	      },
	      "style": {
	        fill: '#595959'
	      }
	    }, [h("path", {
	      "attrs": {
	        "d": "M142.731204,111 C137.280427,111 132.719573,114.852 131.82965,120.095 C127.268796,145.24 104.464526,164.5 76.9881611,164.5 C49.5117965,164.5 26.7075263,145.24 22.1466723,120.095 C21.2567496,114.852 16.6958955,111 11.2451187,111 C4.45945784,111 -0.880078594,116.778 0.121084488,123.198 C5.57186127,155.298 32.2695435,180.443 65.8641269,185.044 L65.8641269,207.3 C65.8641269,213.185 70.8699423,218 76.9881611,218 C83.10638,218 88.1121954,213.185 88.1121954,207.3 L88.1121954,185.044 C121.706779,180.443 148.404461,155.298 153.855238,123.198 C154.967641,116.778 149.516864,111 142.731204,111 Z",
	        "id": "el_uly3EwA2O3"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M76.9864699,147.789474 C98.090352,147.789474 115.126016,131.286316 115.126016,110.842105 L115.126016,36.9473684 C115.126016,16.5031579 98.090352,-2.84217094e-14 76.9864699,-2.84217094e-14 C55.8825877,-2.84217094e-14 38.8469239,16.5031579 38.8469239,36.9473684 L38.8469239,110.842105 C38.8469239,131.286316 55.8825877,147.789474 76.9864699,147.789474 Z",
	        "id": "el_tnDbR4ytu4"
	      }
	    })])])]);
	  }
	};

	var _templateObject$h;

	// eslint-disable-next-line
	injectGlobal(_templateObject$h || (_templateObject$h = _taggedTemplateLiteralLoose(["\n\t#el_X81iT9kZYo {\n\t\tstroke: none;\n\t\tstroke-width: 1;\n\t\tfill: none;\n\t}\n\t#el_gMpyalCphp {\n\t\t-webkit-transform: translate(163px, 131px);\n\t\ttransform: translate(163px, 131px);\n\t}\n\t#el_c7H-3u-D4l {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_qhFcdAAFwo {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_M8X8g37WOI {\n\t\tstroke: #e83137;\n\t\tstroke-width: 21;\n\t}\n"])));
	var MuteSvg = {
	  name: 'MuteSvg',
	  props: ['className'],
	  render: function render() {
	    var h = arguments[0];
	    return h("svg", {
	      "style": {
	        transform: 'scale(1.5)'
	      },
	      "attrs": {
	        "viewBox": "0 0 480 480",
	        "xmlns": "http://www.w3.org/2000/svg",
	        "id": "el_D1rEpH2zj",
	        "width": 28,
	        "height": 28,
	        "className": this.$props.className
	      }
	    }, [h("g", {
	      "attrs": {
	        "id": "el_X81iT9kZYo",
	        "fillRule": "evenodd"
	      }
	    }, [h("g", {
	      "attrs": {
	        "id": "el_gMpyalCphp"
	      }
	    }, [h("path", {
	      "attrs": {
	        "d": "M142.731204,111 C137.280427,111 132.719573,114.852 131.82965,120.095 C127.268796,145.24 104.464526,164.5 76.9881611,164.5 C49.5117965,164.5 26.7075263,145.24 22.1466723,120.095 C21.2567496,114.852 16.6958955,111 11.2451187,111 C4.45945784,111 -0.880078594,116.778 0.121084488,123.198 C5.57186127,155.298 32.2695435,180.443 65.8641269,185.044 L65.8641269,207.3 C65.8641269,213.185 70.8699423,218 76.9881611,218 C83.10638,218 88.1121954,213.185 88.1121954,207.3 L88.1121954,185.044 C121.706779,180.443 148.404461,155.298 153.855238,123.198 C154.967641,116.778 149.516864,111 142.731204,111 Z",
	        "id": "el_c7H-3u-D4l",
	        "fillRule": "nonzero"
	      },
	      "style": {
	        fill: '#595959'
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M76.9864699,147.789474 C98.090352,147.789474 115.126016,131.286316 115.126016,110.842105 L115.126016,36.9473684 C115.126016,16.5031579 98.090352,-2.84217094e-14 76.9864699,-2.84217094e-14 C55.8825877,-2.84217094e-14 38.8469239,16.5031579 38.8469239,36.9473684 L38.8469239,110.842105 C38.8469239,131.286316 55.8825877,147.789474 76.9864699,147.789474 Z",
	        "id": "el_qhFcdAAFwo",
	        "fillRule": "nonzero"
	      },
	      "style": {
	        fill: '#595959'
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M11.5,206.5 L142.5,12.5",
	        "id": "el_M8X8g37WOI",
	        "strokeLinecap": "round",
	        "strokeLinejoin": "round"
	      }
	    })])])]);
	  }
	};

	var _templateObject$i;

	// eslint-disable-next-line
	injectGlobal(_templateObject$i || (_templateObject$i = _taggedTemplateLiteralLoose(["\n\t@-webkit-keyframes kf_el_6WKby7wXqV_an_qqO-rxbNc {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t13.89% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_6WKby7wXqV_an_qqO-rxbNc {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t13.89% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@-webkit-keyframes kf_el_Wi-my975tM_an_XhXP1epXB {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t27.78% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_Wi-my975tM_an_XhXP1epXB {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t27.78% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@-webkit-keyframes kf_el_DkfFFTaFxy8_an_T2XxzvIaA {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t41.67% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_DkfFFTaFxy8_an_T2XxzvIaA {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t41.67% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@-webkit-keyframes kf_el_34IgwiMB5rf_an_TPom3H2LI {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t55.56% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_34IgwiMB5rf_an_TPom3H2LI {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t55.56% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@-webkit-keyframes kf_el_DeebuCsPTGA_an_aYTRBE7Na {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t69.44% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_DeebuCsPTGA_an_aYTRBE7Na {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t69.44% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@-webkit-keyframes kf_el_ZOjjrPTvyrv_an_l_BjBNzXw {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t83.33% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_ZOjjrPTvyrv_an_l_BjBNzXw {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t83.33% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@-webkit-keyframes kf_el_2FATegVmf0K_an_wLg4ofuFx {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t97.22% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t@keyframes kf_el_2FATegVmf0K_an_wLg4ofuFx {\n\t\t0% {\n\t\t\topacity: 0;\n\t\t}\n\t\t97.22% {\n\t\t\topacity: 1;\n\t\t}\n\t\t100% {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t#el_hiibMG0x- * {\n\t\t-webkit-animation-duration: 1.2s;\n\t\tanimation-duration: 1.2s;\n\t\t-webkit-animation-iteration-count: infinite;\n\t\tanimation-iteration-count: infinite;\n\t\t-webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0, 0, 1, 1);\n\t}\n\t#el_QJeJ_2CDw5 {\n\t\tstroke: none;\n\t\tstroke-width: 1;\n\t\tfill: none;\n\t}\n\t#el_UYYCfubTRf {\n\t\t-webkit-transform: translate(163px, 123px);\n\t\ttransform: translate(163px, 123px);\n\t}\n\t#el_uzZNtK32Zi {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_EYKQ2N9Kgy {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_6SDP2LAgKC {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t}\n\t#el_-Vm65Ltfy7 {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_q04iZcSim4 {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_6WKby7wXqV {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_6WKby7wXqV_an_qqO-rxbNc;\n\t\tanimation-name: kf_el_6WKby7wXqV_an_qqO-rxbNc;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el_9bggsfQOtU {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_NKxqi9eIym {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_Wi-my975tM {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_Wi-my975tM_an_XhXP1epXB;\n\t\tanimation-name: kf_el_Wi-my975tM_an_XhXP1epXB;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el_zclQ34fvf7 {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_1OsvRT8HkeZ {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_DkfFFTaFxy8 {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_DkfFFTaFxy8_an_T2XxzvIaA;\n\t\tanimation-name: kf_el_DkfFFTaFxy8_an_T2XxzvIaA;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el_aa9sjx4H0vA {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_tea114vWg0J {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_34IgwiMB5rf {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_34IgwiMB5rf_an_TPom3H2LI;\n\t\tanimation-name: kf_el_34IgwiMB5rf_an_TPom3H2LI;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el_z5u6RAFhx7d {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_7nfuWmA5Uhy {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_DeebuCsPTGA {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_DeebuCsPTGA_an_aYTRBE7Na;\n\t\tanimation-name: kf_el_DeebuCsPTGA_an_aYTRBE7Na;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el__ZcqlS20zcw {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_8DnEQnD7VWV {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_ZOjjrPTvyrv {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_ZOjjrPTvyrv_an_l_BjBNzXw;\n\t\tanimation-name: kf_el_ZOjjrPTvyrv_an_l_BjBNzXw;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el_FYYKCI_u24e {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_XZty4MnTp5Y {\n\t\tfill: #d8d8d8;\n\t}\n\t#el_2FATegVmf0K {\n\t\t-webkit-transform: translate(37.846924px, 0px);\n\t\ttransform: translate(37.846924px, 0px);\n\t\t-webkit-animation-fill-mode: backwards;\n\t\tanimation-fill-mode: backwards;\n\t\topacity: 0;\n\t\t-webkit-animation-name: kf_el_2FATegVmf0K_an_wLg4ofuFx;\n\t\tanimation-name: kf_el_2FATegVmf0K_an_wLg4ofuFx;\n\t\t-webkit-animation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t\tanimation-timing-function: cubic-bezier(0.42, 0, 1, 1);\n\t}\n\t#el_RMT1KUfbdF8 {\n\t\tfill: #0B6AFF;\n\t}\n\t#el_RgLcovvFiO1 {\n\t\tfill: #d8d8d8;\n\t}\n"])));
	var ListenSvg = {
	  name: 'ListenSvg',
	  props: ['className'],
	  render: function render() {
	    var h = arguments[0];
	    return h("svg", {
	      "attrs": {
	        "viewBox": "0 0 480 480",
	        "xmlns": "http://www.w3.org/2000/svg",
	        "xmlnsXlink": "http://www.w3.org/1999/xlink",
	        "id": "el_hiibMG0x-",
	        "width": 28,
	        "height": 29,
	        "className": this.$props.className
	      },
	      "style": {
	        transform: 'scale(1.5)'
	      }
	    }, [h("defs", [h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-1"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-3"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-5"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-7"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-9"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-11"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-13"
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "path-15"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_QJeJ_2CDw5",
	        "fillRule": "evenodd"
	      }
	    }, [h("g", {
	      "attrs": {
	        "id": "el_UYYCfubTRf"
	      }
	    }, [h("path", {
	      "attrs": {
	        "d": "M142.731204,111 C137.280427,111 132.719573,114.852 131.82965,120.095 C127.268796,145.24 104.464526,164.5 76.9881611,164.5 C49.5117965,164.5 26.7075263,145.24 22.1466723,120.095 C21.2567496,114.852 16.6958955,111 11.2451187,111 C4.45945784,111 -0.880078594,116.778 0.121084488,123.198 C5.57186127,155.298 32.2695435,180.443 65.8641269,185.044 L65.8641269,207.3 C65.8641269,213.185 70.8699423,218 76.9881611,218 C83.10638,218 88.1121954,213.185 88.1121954,207.3 L88.1121954,185.044 C121.706779,180.443 148.404461,155.298 153.855238,123.198 C154.967641,116.778 149.516864,111 142.731204,111 Z",
	        "id": "el_uzZNtK32Zi",
	        "fillRule": "nonzero"
	      },
	      "style": {
	        fill: '#0B6AFF'
	      }
	    }), h("path", {
	      "attrs": {
	        "d": "M76.9864699,147.789474 C98.090352,147.789474 115.126016,131.286316 115.126016,110.842105 L115.126016,36.9473684 C115.126016,16.5031579 98.090352,0 76.9864699,0 C55.8825877,0 38.8469239,16.5031579 38.8469239,36.9473684 L38.8469239,110.842105 C38.8469239,131.286316 55.8825877,147.789474 76.9864699,147.789474 Z",
	        "id": "el_EYKQ2N9Kgy",
	        "fillRule": "nonzero"
	      }
	    }), h("g", {
	      "attrs": {
	        "id": "el_6SDP2LAgKC"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-2",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-1"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_-Vm65Ltfy7",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-2)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_q04iZcSim4",
	        "mask": "url(#mask-2)",
	        "x": "0.279",
	        "width": "77",
	        "height": "130"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_6WKby7wXqV"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-4",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-3"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_9bggsfQOtU",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-4)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_NKxqi9eIym",
	        "mask": "url(#mask-4)",
	        "x": "0.279",
	        "width": "77",
	        "height": "115"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_Wi-my975tM"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-6",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-5"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_zclQ34fvf7",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-6)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_1OsvRT8HkeZ",
	        "mask": "url(#mask-6)",
	        "x": "0.279",
	        "width": "77",
	        "height": "100"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_DkfFFTaFxy8"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-8",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-7"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_aa9sjx4H0vA",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-8)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_tea114vWg0J",
	        "mask": "url(#mask-8)",
	        "x": "0.279",
	        "width": "77",
	        "height": "85"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_34IgwiMB5rf"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-10",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-9"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_z5u6RAFhx7d",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-10)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_7nfuWmA5Uhy",
	        "mask": "url(#mask-10)",
	        "x": "0.279",
	        "width": "77",
	        "height": "70"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_DeebuCsPTGA"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-12",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-11"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el__ZcqlS20zcw",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-12)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_8DnEQnD7VWV",
	        "mask": "url(#mask-12)",
	        "x": "0.279",
	        "width": "77",
	        "height": "55"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_ZOjjrPTvyrv"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-14",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-13"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_FYYKCI_u24e",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-14)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_XZty4MnTp5Y",
	        "mask": "url(#mask-14)",
	        "x": "0.279",
	        "width": "77",
	        "height": "40"
	      }
	    })]), h("g", {
	      "attrs": {
	        "id": "el_2FATegVmf0K"
	      }
	    }, [h("mask", {
	      "attrs": {
	        "id": "mask-16",
	        "fill": "#fff"
	      }
	    }, [h("use", {
	      "attrs": {
	        "xlink:href": "#path-15"
	      }
	    })]), h("path", {
	      "attrs": {
	        "d": "M38.779092,147.789474 C60.0824253,147.789474 77.279092,131.286316 77.279092,110.842105 L77.279092,36.9473684 C77.279092,16.5031579 60.0824253,0 38.779092,0 C17.4757586,0 0.279091964,16.5031579 0.279091964,36.9473684 L0.279091964,110.842105 C0.279091964,131.286316 17.4757586,147.789474 38.779092,147.789474 Z",
	        "id": "el_RMT1KUfbdF8",
	        "fillRule": "nonzero",
	        "mask": "url(#mask-16)"
	      }
	    }), h("rect", {
	      "attrs": {
	        "id": "el_RgLcovvFiO1",
	        "mask": "url(#mask-16)",
	        "x": "0.279",
	        "width": "77",
	        "height": "25"
	      }
	    })])])])]);
	  }
	};

	var STATUS = {
	  inactive: 'INACTIVE',
	  stopped: 'STOPPED',
	  active: 'ACTIVE',
	  denied: 'DENIED'
	};
	var Mic = {
	  name: 'Mic',
	  props: {
	    children: types.title,
	    lang: VueTypes.string.def('en-US'),
	    iconPosition: VueTypes.string.def('left'),
	    handleResult: types.func,
	    onNoMatch: types.func,
	    onError: types.func,
	    getInstance: types.func,
	    render: types.func,
	    className: types.string,
	    applyClearStyle: VueTypes.bool,
	    showIcon: VueTypes.bool
	  },
	  methods: {
	    getComponent: function getComponent$1() {
	      var status = this.$data.status;
	      var data = {
	        handleClick: this.handleClick,
	        status: status
	      };
	      return getComponent(data, this);
	    },
	    stopMic: function stopMic() {
	      if (this.instance) {
	        this.status = STATUS.inactive;
	        this.instance.stop();
	        this.instance = null;
	      }
	    },
	    handleClick: function handleClick() {
	      var _this = this;
	      this.results = [];
	      if (window && window.SpeechRecognition) {
	        var status = this.$data.status;
	        if (status === STATUS.active) {
	          this.status = STATUS.inactive;
	        }
	        var _this$$props = this.$props,
	          handleResult = _this$$props.handleResult,
	          onNoMatch = _this$$props.onNoMatch,
	          onError = _this$$props.onError,
	          lang = _this$$props.lang,
	          getInstance = _this$$props.getInstance;
	        var _window = window,
	          SpeechRecognition = _window.SpeechRecognition;
	        if (this.instance && this.status !== STATUS.denied) {
	          this.status = STATUS.inactive;
	          this.instance.stop();
	          this.instance = null;
	          return;
	        }
	        this.instance = new SpeechRecognition();
	        this.instance.continuous = true;
	        this.instance.interimResults = true;
	        this.instance.lang = lang;
	        if (getInstance) {
	          getInstance(this.instance);
	        }
	        this.instance.start();
	        this.instance.onstart = function () {
	          _this.status = STATUS.active;
	        };
	        this.instance.onresult = function (_ref) {
	          var results = _ref.results,
	            timeStamp = _ref.timeStamp;
	          _this.stopMic();
	          if (handleResult) {
	            handleResult({
	              results: results,
	              timeStamp: timeStamp
	            });
	          }
	          _this.results.push({
	            results: results,
	            timeStamp: timeStamp
	          });
	        };
	        this.instance.onnomatch = function (e) {
	          return onNoMatch ? onNoMatch(e) : console.warn(e);
	        };
	        this.instance.onerror = function (e) {
	          if (e.error === 'no-speech' || e.error === 'audio-capture') {
	            _this.status = STATUS.inactive;
	          } else if (e.error === 'not-allowed') {
	            _this.status = STATUS.denied;
	          }
	          console.error(e);
	          if (onError) {
	            onError(e);
	          }
	        };

	        /* Below Two methods run when Continuous is False */
	        this.instance.onspeechend = function () {
	          _this.status = STATUS.inactive;
	        };
	        this.instance.onaudioend = function () {
	          _this.status = STATUS.inactive;
	        };
	      }
	    }
	  },
	  computed: {
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    },
	    Icon: function Icon() {
	      var h = this.$createElement;
	      var status = this.$data.status;
	      var className = this.$props.className;
	      switch (status) {
	        case STATUS.active:
	          return h(ListenSvg, {
	            "attrs": {
	              "className": className
	            },
	            "nativeOn": {
	              "click": this.handleClick
	            }
	          });
	        case STATUS.stopped:
	        case STATUS.denied:
	          return h(MuteSvg, {
	            "attrs": {
	              "className": className
	            },
	            "nativeOn": {
	              "click": this.handleClick
	            }
	          });
	        default:
	          return h(MicSvg, {
	            "attrs": {
	              "className": className
	            },
	            "nativeOn": {
	              "click": this.handleClick
	            }
	          });
	      }
	    }
	  },
	  data: function data() {
	    return {
	      status: STATUS.inactive
	    };
	  },
	  created: function created() {
	    this.results = [];
	    if (typeof window !== 'undefined') {
	      window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition || null;
	      if (!window.SpeechRecognition) {
	        console.error('SpeechRecognition is not supported in this browser. Please check the browser compatibility at https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition#Browser_compatibility.');
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    if (this.hasCustomRenderer) {
	      return this.getComponent();
	    }
	    return h(IconWrapper, [this.Icon]);
	  }
	};

	var CustomSvg = {
	  name: 'CustomSvg',
	  props: {
	    className: String,
	    icon: Function,
	    type: String
	  },
	  data: function data() {
	    return {
	      customIcon: this.$props.icon && typeof this.$props.icon === 'function' ? this.$props.icon() : null
	    };
	  },
	  render: function render() {
	    var h = arguments[0];
	    if (this.customIcon) {
	      return h("div", {
	        "class": this.$props.className
	      }, [this.customIcon]);
	    }
	    if (this.$props.type === 'recent-search-icon') {
	      return h("svg", {
	        "attrs": {
	          "xmlns": "http://www.w3.org/2000/svg",
	          "alt": "Recent Search",
	          "height": "20",
	          "width": "20",
	          "viewBox": "0 0 24 24"
	        },
	        "style": {
	          fill: '#707070'
	        },
	        "class": this.$props.className
	      }, [h("path", {
	        "attrs": {
	          "d": "M0 0h24v24H0z",
	          "fill": "none"
	        }
	      }), h("path", {
	        "attrs": {
	          "d": "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"
	        }
	      })]);
	    }
	    if (this.$props.type === 'promoted-search-icon') {
	      return h("svg", {
	        "attrs": {
	          "xmlns": "http://www.w3.org/2000/svg",
	          "width": "20",
	          "alt": "promoted search",
	          "height": "20",
	          "viewBox": "0 0 24 24"
	        },
	        "class": this.$props.className,
	        "style": {
	          fill: '#707070'
	        }
	      }, [h("path", {
	        "attrs": {
	          "d": "M12 .587l3.668 7.568 8.332 1.151-6.064 5.828 1.48 8.279-7.416-3.967-7.417 3.967 1.481-8.279-6.064-5.828 8.332-1.151z"
	        }
	      })]);
	    }
	    if (this.$props.type === 'popular-search-icon') {
	      return h("svg", {
	        "attrs": {
	          "xmlns": "http://www.w3.org/2000/svg",
	          "alt": "Popular Search",
	          "height": "20",
	          "width": "20",
	          "viewBox": "0 0 24 24"
	        },
	        "style": {
	          fill: '#707070'
	        },
	        "class": this.$props.className
	      }, [h("path", {
	        "attrs": {
	          "d": "M0 0h24v24H0z",
	          "fill": "none"
	        }
	      }), h("path", {
	        "attrs": {
	          "d": "M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"
	        }
	      })]);
	    }
	    return h(SearchSvg, {
	      "attrs": {
	        "styles": {
	          position: 'relative',
	          fill: '#707070',
	          left: '3px',
	          marginRight: '8px'
	        }
	      }
	    });
	  }
	};

	var _templateObject$j, _templateObject2$7;
	var TagsContainer = index$1('div')(_templateObject$j || (_templateObject$j = _taggedTemplateLiteralLoose(["\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tmargin-top: 10px;\n\twidth: 100%;\n"])));
	var TagItem = index$1('span')(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteralLoose(["\n\tcursor: default;\n\tbox-sizing: border-box;\n\tmargin: 0 4px 4px 0;\n\tcolor: #000000d9;\n\tfont-size: 14px;\n\tfont-variant: tabular-nums;\n\tline-height: 1.5715;\n\tlist-style: none;\n\tfont-feature-settings: 'tnum';\n\tdisplay: inline-block;\n\theight: auto;\n\tpadding: 0 2px 0 7px;\n\tfont-size: 12px;\n\tline-height: 22px;\n\twhite-space: nowrap;\n\tbackground: #fafafa;\n\tborder: 1px solid #d9d9d9;\n\tborder-radius: 2px;\n\topacity: 1;\n\ttransition: all 0.3s;\n\n\tspan.close-icon {\n\t\tsvg {\n\t\t\tcursor: pointer;\n\t\t\theight: 15px;\n\t\t\tposition: relative;\n\t\t\ttop: 4px;\n\t\t\tfill: #262626;\n\t\t}\n\t}\n"])));

	var updateQuery$1 = lib_5.updateQuery,
	  setQueryOptions$1 = lib_5.setQueryOptions,
	  setCustomQuery = lib_5.setCustomQuery,
	  setDefaultQuery$1 = lib_5.setDefaultQuery,
	  setCustomHighlightOptions = lib_5.setCustomHighlightOptions,
	  recordSuggestionClick = lib_5.recordSuggestionClick,
	  loadPopularSuggestions = lib_5.loadPopularSuggestions,
	  getRecentSearches = lib_5.getRecentSearches,
	  resetStoreForComponent = lib_5.resetStoreForComponent;
	var debounce$1 = lib_8.debounce,
	  checkValueChange = lib_8.checkValueChange,
	  getClassName$3 = lib_8.getClassName,
	  extractQueryFromCustomQuery$1 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$1 = lib_8.getOptionsForCustomQuery,
	  isEqual$4 = lib_8.isEqual,
	  getCompositeAggsQuery$1 = lib_8.getCompositeAggsQuery,
	  withClickIds = lib_8.withClickIds,
	  getResultStats$1 = lib_8.getResultStats,
	  handleOnSuggestions = lib_8.handleOnSuggestions,
	  getTopSuggestions = lib_8.getTopSuggestions,
	  normalizeDataField = lib_8.normalizeDataField;
	var DataSearch = {
	  name: 'DataSearch',
	  isTagsMode: false,
	  data: function data() {
	    var props = this.$props;
	    this.__state = {
	      currentValue: '',
	      selectedTags: [],
	      isOpen: false,
	      normalizedSuggestions: [],
	      isPending: false
	    };
	    this.internalComponent = props.componentId + "__internal";
	    return this.__state;
	  },
	  inject: {
	    theme: {
	      from: 'theme_reactivesearch'
	    }
	  },
	  created: function created() {
	    var _this$$props = this.$props,
	      enableRecentSearches = _this$$props.enableRecentSearches,
	      distinctField = _this$$props.distinctField,
	      distinctFieldConfig = _this$$props.distinctFieldConfig,
	      index = _this$$props.index,
	      mode = _this$$props.mode;
	    if (mode === constants_5$1.TAG) {
	      this.$options.isTagsMode = true;
	    }
	    if (this.enableAppbase && this.aggregationField && this.aggregationField !== '') {
	      console.warn('Warning(ReactiveSearch): The `aggregationField` prop has been marked as deprecated, please use the `distinctField` prop instead.');
	    }
	    if (!this.enableAppbase && (distinctField || distinctFieldConfig)) {
	      console.warn('Warning(ReactiveSearch): In order to use the `distinctField` and `distinctFieldConfig` props, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    if (!this.enableAppbase && index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    this.currentValue = '';
	    if (this.$options.isTagsMode) {
	      this.currentValue = '';
	    }
	    var shouldFetchInitialSuggestions = this.$props.enableDefaultSuggestions || this.currentValue;
	    if (shouldFetchInitialSuggestions) {
	      this.loadPopularSuggestions(this.$props.componentId);
	      if (enableRecentSearches) {
	        this.getRecentSearches();
	      }
	    }
	    this.handleTextChange = debounce$1(this.handleText, this.$props.debounce);
	    this.updateDefaultQueryHandlerDebounced = debounce$1(this.updateDefaultQueryHandler, this.$props.debounce);
	    this.updateQueryHandlerDebounced = debounce$1(this.updateQueryHandler, this.$props.debounce);
	    // Set custom and default queries in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	    updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
	    this.updateDefaultQueryHandlerDebounced(this.currentValue, this.$props, false);
	  },
	  computed: {
	    suggestionsList: function suggestionsList() {
	      var suggestionsList = [];
	      if (!this.$data.currentValue && this.$props.defaultSuggestions && this.$props.defaultSuggestions.length) {
	        suggestionsList = this.$props.defaultSuggestions;
	      } else if (this.$data.currentValue) {
	        suggestionsList = this.normalizedSuggestions;
	      }
	      return withClickIds(suggestionsList);
	    },
	    topSuggestions: function topSuggestions() {
	      if (!this.currentValue) {
	        return [];
	      }
	      return this.enablePopularSuggestions ? this.normalizedPopularSuggestions : [];
	    },
	    normalizedRecentSearches: function normalizedRecentSearches() {
	      return this.recentSearches || [];
	    },
	    normalizedPopularSuggestions: function normalizedPopularSuggestions() {
	      return getTopSuggestions(
	      // use default popular suggestions if value is empty
	      this.currentValue ? this.popularSuggestions : this.defaultPopularSuggestions || [], this.currentValue, this.showDistinctSuggestions);
	    },
	    defaultSearchSuggestions: function defaultSearchSuggestions() {
	      var isPopularSuggestionsEnabled = this.enablePopularSuggestions;
	      if (this.currentValue || !this.enableDefaultSuggestions) {
	        return [];
	      }
	      var customDefaultPopularSuggestions = (this.defaultPopularSuggestions || []).map(function (suggestion) {
	        return _extends({}, suggestion, {
	          _popular_suggestion: true
	        });
	      });
	      var customNormalizedRecentSearches = (this.normalizedRecentSearches || []).map(function (search) {
	        return _extends({}, search, {
	          _recent_search: true
	        });
	      });
	      var defaultSuggestions = isPopularSuggestionsEnabled ? [].concat(customNormalizedRecentSearches, customDefaultPopularSuggestions || []) : customNormalizedRecentSearches;
	      return getTopSuggestions(
	      // use default popular suggestions if value is empty
	      defaultSuggestions, this.currentValue, this.showDistinctSuggestions);
	    },
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    },
	    stats: function stats() {
	      return getResultStats$1(this);
	    }
	  },
	  props: {
	    options: types.options,
	    autoFocus: VueTypes.bool,
	    autosuggest: VueTypes.bool.def(true),
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    clearIcon: types.children,
	    componentId: types.stringRequired,
	    customHighlight: types.func,
	    customQuery: types.func,
	    defaultQuery: types.func,
	    dataField: VueTypes.oneOfType([VueTypes.string, VueTypes.shape({
	      field: VueTypes.string,
	      weight: VueTypes.number
	    }), VueTypes.arrayOf(VueTypes.string), VueTypes.arrayOf({
	      field: VueTypes.string,
	      weight: VueTypes.number
	    })]),
	    aggregationField: types.string,
	    aggregationSize: VueTypes.number,
	    size: VueTypes.number,
	    debounce: VueTypes.number.def(0),
	    defaultValue: types.string,
	    excludeFields: types.excludeFields,
	    value: VueTypes.oneOfType([VueTypes.arrayOf(VueTypes.string), types.value]),
	    defaultSuggestions: types.suggestions,
	    enableSynonyms: VueTypes.bool.def(true),
	    enablePopularSuggestions: VueTypes.bool.def(false),
	    enableRecentSearches: VueTypes.bool.def(false),
	    fieldWeights: types.fieldWeights,
	    filterLabel: types.string,
	    fuzziness: types.fuzziness,
	    highlight: VueTypes.bool,
	    highlightField: types.stringOrArray,
	    icon: types.children,
	    iconPosition: VueTypes.oneOf(['left', 'right']).def('left'),
	    includeFields: types.includeFields,
	    innerClass: types.style,
	    innerRef: VueTypes.string.def('searchInputField'),
	    render: types.func,
	    renderPopularSuggestions: types.func,
	    parseSuggestion: types.func,
	    renderNoSuggestion: types.title,
	    renderError: types.title,
	    placeholder: VueTypes.string.def('Search'),
	    queryFormat: VueTypes.oneOf(['and', 'or']).def('or'),
	    react: types.react,
	    showClear: VueTypes.bool.def(true),
	    showDistinctSuggestions: VueTypes.bool.def(true),
	    showFilter: VueTypes.bool.def(true),
	    showIcon: VueTypes.bool.def(true),
	    title: types.title,
	    theme: types.style,
	    URLParams: VueTypes.bool.def(false),
	    strictSelection: VueTypes.bool.def(false),
	    nestedField: types.string,
	    enablePredictiveSuggestions: VueTypes.bool.def(false),
	    recentSearchesIcon: VueTypes.any,
	    popularSearchesIcon: VueTypes.any,
	    //	mic props
	    showVoiceSearch: VueTypes.bool.def(false),
	    getMicInstance: types.func,
	    renderMic: types.func,
	    distinctField: types.string,
	    distinctFieldConfig: types.props,
	    //
	    focusShortcuts: VueTypes.arrayOf(VueTypes.oneOfType([VueTypes.string, VueTypes.number])).def(['/']),
	    addonBefore: VueTypes.any,
	    addonAfter: VueTypes.any,
	    expandSuggestionsContainer: VueTypes.bool.def(true),
	    index: VueTypes.string,
	    enableDefaultSuggestions: VueTypes.bool.def(true),
	    mode: VueTypes.oneOf(['select', 'tag']).def('select'),
	    renderSelectedTags: VueTypes.any,
	    endpoint: types.endpointConfig
	  },
	  beforeMount: function beforeMount() {
	    if (this.$props.highlight) {
	      if (this.customHighlight && typeof this.customHighlight === 'function') {
	        this.setCustomHighlightOptions(this.componentId, this.customHighlight(this.$props));
	      }
	      var queryOptions = DataSearch.highlightQuery(this.$props) || {};
	      this.queryOptions = _extends({}, queryOptions, this.getBasicQueryOptions());
	      this.setQueryOptions(this.$props.componentId, this.queryOptions);
	    } else {
	      this.queryOptions = this.getBasicQueryOptions();
	      this.setQueryOptions(this.$props.componentId, this.queryOptions);
	    }
	    if (this.selectedValue) {
	      this.setValue(this.selectedValue, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	    } else if (this.$props.value) {
	      this.setValue(this.$props.value, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	    } else if (this.$props.defaultValue) {
	      this.setValue(this.$props.defaultValue, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	    }
	  },
	  mounted: function mounted() {
	    this.listenForFocusShortcuts();
	  },
	  watch: {
	    highlight: function highlight() {
	      this.updateQueryOptions();
	    },
	    dataField: function dataField() {
	      this.updateQueryOptions();
	      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
	    },
	    highlightField: function highlightField() {
	      this.updateQueryOptions();
	    },
	    fieldWeights: function fieldWeights() {
	      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
	    },
	    fuzziness: function fuzziness() {
	      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
	    },
	    queryFormat: function queryFormat() {
	      this.updateQueryHandler(this.$props.componentId, this.$options.isTagsMode ? this.$data.selectedTags : this.$data.currentValue, this.$props);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(newVal, true, this.$props);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$4(newVal, oldVal) || this.$options.isTagsMode && !isEqual$4(newVal, this.selectedTags)) {
	        if (this.isPending && this.$options.isTagsMode && Array.isArray(newVal)) {
	          this.isPending = false;
	        }
	        this.setValue(newVal, true, this.$props, newVal === '' ? lib_7.CLEAR_VALUE : undefined, false, typeof newVal !== 'string' && this.$options.isTagsMode);
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateDefaultQueryHandlerDebounced(this.$data.currentValue, this.$props);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
	      }
	    },
	    suggestions: function suggestions(newVal) {
	      if (Array.isArray(newVal) && this.$data.currentValue.trim().length) {
	        // shallow check allows us to set suggestions even if the next set
	        // of suggestions are same as the current one
	        this.$emit('suggestions', newVal);
	        this.normalizedSuggestions = this.onSuggestions(newVal);
	      }
	    },
	    selectedValue: function selectedValue(newVal, oldVal) {
	      if (!isEqual$4(newVal, oldVal) && (this.$options.isTagsMode ? !isEqual$4(this.$data.selectedTags, newVal) : this.$data.currentValue !== newVal)) {
	        if (!newVal && this.$data.currentValue) {
	          // selected value is cleared, call onValueSelected
	          this.onValueSelectedHandler('', lib_7.CLEAR_VALUE);
	        }
	        if (this.$options.isTagsMode) {
	          // handling reset of tags through SelectedFilters or URL
	          this.selectedTags = [];
	        }
	        this.setValue(newVal || '', true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	      }
	    },
	    focusShortcuts: function focusShortcuts() {
	      this.listenForFocusShortcuts();
	    }
	  },
	  methods: {
	    handleText: function handleText(value) {
	      if (this.$props.autosuggest) {
	        this.updateDefaultQueryHandlerDebounced(value, this.$props);
	      } else if (!this.$options.isTagsMode) {
	        this.updateQueryHandlerDebounced(this.$props.componentId, value, this.$props);
	      } else if (this.$options.isTagsMode) {
	        this.$data.currentValue = value;
	      }
	    },
	    validateDataField: function validateDataField() {
	      var propName = 'dataField';
	      var componentName = DataSearch.name;
	      var props = this.$props;
	      var requiredError = propName + " supplied to " + componentName + " is required. Validation failed.";
	      var propValue = props[propName];
	      if (!this.enableAppbase) {
	        if (!propValue) {
	          console.error(requiredError);
	          return;
	        }
	        if (typeof propValue !== 'string' && typeof propValue !== 'object' && !Array.isArray(propValue)) {
	          console.error("Invalid " + propName + " supplied to " + componentName + ". Validation failed.");
	          return;
	        }
	        if (Array.isArray(propValue) && propValue.length === 0) {
	          console.error(requiredError);
	        }
	      }
	    },
	    updateQueryOptions: function updateQueryOptions() {
	      if (this.customHighlight && typeof this.customHighlight === 'function') {
	        this.setCustomHighlightOptions(this.componentId, this.customHighlight(this.$props));
	      }
	      var queryOptions = DataSearch.highlightQuery(this.$props) || {};
	      this.queryOptions = _extends({}, queryOptions, this.getBasicQueryOptions());
	      this.setQueryOptions(this.$props.componentId, this.queryOptions);
	    },
	    getComponent: function getComponent$1(downshiftProps, isQuerySuggestionsRender) {
	      if (downshiftProps === void 0) {
	        downshiftProps = {};
	      }
	      if (isQuerySuggestionsRender === void 0) {
	        isQuerySuggestionsRender = false;
	      }
	      var currentValue = this.$data.currentValue;
	      var data = {
	        error: this.error,
	        loading: this.isLoading,
	        downshiftProps: downshiftProps,
	        data: this.suggestionsList,
	        promotedData: this.promotedResults,
	        aggregationData: this.aggregationData,
	        rawData: this.rawData,
	        customData: this.customData,
	        value: currentValue,
	        triggerClickAnalytics: this.triggerClickAnalytics,
	        resultStats: this.stats,
	        querySuggestions: this.normalizedPopularSuggestions,
	        popularSuggestions: this.normalizedPopularSuggestions
	      };
	      if (isQuerySuggestionsRender) {
	        return getQuerySuggestionsComponent({
	          downshiftProps: downshiftProps,
	          data: this.normalizedPopularSuggestions,
	          value: currentValue,
	          loading: this.isLoading,
	          error: this.error
	        }, this);
	      }
	      return getComponent(data, this);
	    },
	    // returns size and aggs property
	    getBasicQueryOptions: function getBasicQueryOptions() {
	      var aggregationField = this.$props.aggregationField;
	      var queryOptions = helper_36(this.$props);
	      if (aggregationField) {
	        queryOptions.aggs = getCompositeAggsQuery$1({
	          props: this.$props,
	          showTopHits: true
	        }).aggs;
	      }
	      return queryOptions;
	    },
	    onSuggestions: function onSuggestions(results) {
	      return handleOnSuggestions(results, this.$data.currentValue, this);
	    },
	    handleSearchIconClick: function handleSearchIconClick() {
	      var currentValue = this.currentValue;
	      if (currentValue.trim()) {
	        this.isPending = false;
	        this.setValue(currentValue, true);
	        this.onValueSelectedHandler(currentValue, lib_7.SEARCH_ICON_CLICK);
	      }
	    },
	    setValue: function setValue(value, isDefaultValue, props, cause, toggleIsOpen, isTagsMode) {
	      var _this = this;
	      if (isDefaultValue === void 0) {
	        isDefaultValue = false;
	      }
	      if (props === void 0) {
	        props = this.$props;
	      }
	      if (toggleIsOpen === void 0) {
	        toggleIsOpen = true;
	      }
	      if (isTagsMode === void 0) {
	        isTagsMode = this.$options.isTagsMode;
	      }
	      var performUpdate = function performUpdate() {
	        if (isTagsMode && isEqual$4(value, _this.selectedTags)) {
	          return;
	        }
	        // Refresh recent searches when value becomes empty
	        if (!value && props.enableDefaultSuggestions === false) {
	          _this.resetStoreForComponent(props.componentId);
	        } else if (!value && _this.currentValue && _this.enableRecentSearches) {
	          _this.getRecentSearches();
	        }
	        if (isTagsMode) {
	          if (Array.isArray(_this.selectedTags) && _this.selectedTags.length) {
	            // check if value already present in selectedTags
	            if (typeof value === 'string' && _this.selectedTags.includes(value)) {
	              _this.isOpen = false;
	              return;
	            }
	            _this.selectedTags = [].concat(_this.selectedTags);
	            if (typeof value === 'string' && !!value) {
	              _this.selectedTags.push(value);
	            } else if (Array.isArray(value) && !isEqual$4(_this.selectedTags, value)) {
	              _this.selectedTags = value;
	            }
	          } else if (value) {
	            _this.selectedTags = typeof value !== 'string' ? value : [].concat(value);
	          }
	          _this.currentValue = '';
	        } else {
	          _this.currentValue = value;
	        }
	        var queryHandlerValue = value;
	        if (isTagsMode) {
	          queryHandlerValue = Array.isArray(_this.selectedTags) && _this.selectedTags.length ? _this.selectedTags : undefined;
	        }
	        if (isDefaultValue) {
	          if (_this.$props.autosuggest) {
	            if (toggleIsOpen) {
	              _this.isOpen = false;
	            }
	            if (typeof value === 'string') _this.updateDefaultQueryHandlerDebounced(value, _this.$props);
	          } // in case of strict selection only SUGGESTION_SELECT should be able
	          // to set the query otherwise the value should reset

	          if (props.strictSelection && props.autosuggest) {
	            if (cause === lib_7.SUGGESTION_SELECT || props.value !== undefined) {
	              _this.updateQueryHandler(props.componentId, queryHandlerValue, props);
	            } else if (_this.currentValue !== '') {
	              _this.setValue('', true);
	            }
	          } else {
	            _this.updateQueryHandler(props.componentId, queryHandlerValue, props);
	          }
	        } else {
	          // debounce for handling text while typing
	          _this.handleTextChange(value);
	        }
	        _this.$emit('valueChange', value);
	        _this.$emit('value-change', value);
	        // Set the already fetched suggestions if query is same as used last to fetch the hits
	        if (value === _this.lastUsedQuery) {
	          _this.suggestions = _this.onSuggestions(_this.suggestions);
	          // invoke on suggestions
	          _this.$emit('suggestions', _this.suggestions);
	        } else if (!value) {
	          // reset suggestions
	          _this.suggestions = [];
	          // invoke on suggestions
	          _this.$emit('suggestions', _this.suggestions);
	        }
	      };
	      checkValueChange(props.componentId, value, props.beforeValueChange, performUpdate);
	    },
	    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props, execute) {
	      if (props === void 0) {
	        props = this.$props;
	      }
	      if (!value && props.enableDefaultSuggestions === false) {
	        // clear Component data from store
	        this.resetStoreForComponent(props.componentId);
	        return;
	      }
	      var defaultQueryOptions;
	      var query = DataSearch.defaultQuery(value, props);
	      if (this.defaultQuery) {
	        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
	        var defaultQueryObj = extractQueryFromCustomQuery$1(defaultQueryToBeSet);
	        if (defaultQueryObj) {
	          query = defaultQueryObj;
	        }
	        defaultQueryOptions = getOptionsForCustomQuery$1(defaultQueryToBeSet);
	        // Update calculated default query in store
	        updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
	      }
	      this.setQueryOptions(this.internalComponent, _extends({}, this.queryOptions, defaultQueryOptions), execute);
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query,
	        value: value,
	        componentType: constants_1$1.dataSearch
	      }, execute);
	    },
	    updateQueryHandler: function updateQueryHandler(componentId, value, props) {
	      var customQuery = props.customQuery,
	        filterLabel = props.filterLabel,
	        showFilter = props.showFilter,
	        URLParams = props.URLParams;
	      var customQueryOptions;
	      var defaultQueryTobeSet = DataSearch.defaultQuery(value, props);
	      var query = defaultQueryTobeSet;
	      if (customQuery) {
	        var customQueryTobeSet = customQuery(value, props);
	        var queryTobeSet = extractQueryFromCustomQuery$1(customQueryTobeSet);
	        if (queryTobeSet) {
	          query = queryTobeSet;
	        }
	        customQueryOptions = getOptionsForCustomQuery$1(customQueryTobeSet);
	        updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
	        this.setQueryOptions(componentId, _extends({}, this.queryOptions, customQueryOptions), false);
	      }
	      if (!this.isPending) {
	        this.updateQuery({
	          componentId: componentId,
	          query: query,
	          value: value,
	          label: filterLabel,
	          showFilter: showFilter,
	          URLParams: URLParams,
	          componentType: 'DATASEARCH'
	        });
	      }
	    },
	    // need to review
	    handleFocus: function handleFocus(event) {
	      this.isOpen = true;
	      this.$emit('focus', event);
	    },
	    handleVoiceResults: function handleVoiceResults(_ref) {
	      var results = _ref.results;
	      if (results && results[0] && results[0].isFinal && results[0][0] && results[0][0].transcript && results[0][0].transcript.trim()) {
	        this.isPending = false;
	        this.setValue(results[0][0].transcript.trim(), true);
	      }
	    },
	    triggerQuery: function triggerQuery(_temp) {
	      var _ref2 = _temp === void 0 ? false : _temp,
	        _ref2$isOpen = _ref2.isOpen,
	        isOpen = _ref2$isOpen === void 0 ? false : _ref2$isOpen;
	      var value = this.$props.value;
	      if (value !== undefined) {
	        this.isPending = false;
	        this.setValue(this.$props.value, !isOpen);
	      }
	    },
	    triggerClickAnalytics: function triggerClickAnalytics(searchPosition, documentId) {
	      // click analytics would only work client side and after javascript loads
	      var docId = documentId;
	      if (!docId) {
	        var hitData = this.suggestionsList.find(function (hit) {
	          return hit._click_id === searchPosition;
	        });
	        if (hitData && hitData.source && hitData.source._id) {
	          docId = hitData.source._id;
	        }
	      }
	      this.recordSuggestionClick(searchPosition, docId);
	    },
	    clearValue: function clearValue() {
	      this.isPending = false;
	      this.setValue('', true);
	      this.onValueSelectedHandler('', lib_7.CLEAR_VALUE);
	    },
	    handleKeyDown: function handleKeyDown(event, highlightedIndex) {
	      var targetValue = event.target.value;
	      var _this$$props2 = this.$props,
	        value = _this$$props2.value,
	        strictSelection = _this$$props2.strictSelection,
	        size = _this$$props2.size,
	        autosuggest = _this$$props2.autosuggest;
	      if (value !== undefined) {
	        this.isPending = true;
	      }
	      // if a suggestion was selected, delegate the handling to suggestion handler
	      if (event.key === 'Enter' && (highlightedIndex === null || highlightedIndex < 0 || highlightedIndex === [].concat([].concat(this.suggestionsList).slice(0, size || 10), this.defaultSearchSuggestions, this.topSuggestions).length)) {
	        this.isPending = false;
	        this.setValue(this.$options.isTagsMode && autosuggest && strictSelection ? '' : targetValue, true, this.$props, undefined, false);
	        this.onValueSelectedHandler(targetValue, lib_7.ENTER_PRESS);
	      }
	      // Need to review
	      this.$emit('keyDown', event, this.triggerQuery);
	      this.$emit('key-down', event, this.triggerQuery);
	    },
	    onInputChange: function onInputChange(e) {
	      var _this2 = this;
	      var inputValue = e.target.value;
	      if (!this.$data.isOpen) {
	        this.isOpen = true;
	      }
	      var _this$$props3 = this.$props,
	        value = _this$$props3.value,
	        autosuggest = _this$$props3.autosuggest;
	      if (value === undefined) {
	        this.setValue(inputValue, false, this.$props, undefined, true, false);
	      } else {
	        this.isPending = true;
	        this.currentValue = inputValue;
	        this.$emit('change', inputValue, function (_temp2) {
	          var _ref3 = _temp2 === void 0 ? {} : _temp2,
	            _ref3$isOpen = _ref3.isOpen,
	            isOpen = _ref3$isOpen === void 0 ? false : _ref3$isOpen;
	          if (_this2.$options.isTagsMode && autosuggest) {
	            _this2.isOpen = isOpen;
	            _this2.updateDefaultQueryHandlerDebounced(_this2.currentValue, _this2.$props);
	            return;
	          }
	          _this2.triggerQuery({
	            isOpen: isOpen
	          });
	        }, e);
	      }
	    },
	    onSuggestionSelected: function onSuggestionSelected(suggestion) {
	      var value = this.$props.value;
	      // Record analytics for selected suggestions
	      this.triggerClickAnalytics(suggestion._click_id);
	      if (value === undefined) {
	        this.setValue(suggestion.value, true, this.$props, lib_7.SUGGESTION_SELECT);
	      } else if (this.$options.isTagsMode) {
	        var emitValue = Array.isArray(this.selectedTags) ? [].concat(this.selectedTags) : [];
	        if (this.selectedTags.includes(suggestion.value)) {
	          // avoid duplicates in tags array
	          this.isOpen = false;
	          return;
	        }
	        emitValue.push(suggestion.value);
	        this.setValue(emitValue, true, this.$props, lib_7.SUGGESTION_SELECT, true);
	        this.$emit('change', emitValue, this.triggerQuery);
	      } else {
	        this.$emit('change', suggestion.value, this.triggerQuery);
	      }
	      this.isPending = false;
	      this.onValueSelectedHandler(suggestion.value, lib_7.SUGGESTION_SELECT, suggestion.source);
	    },
	    onValueSelectedHandler: function onValueSelectedHandler(currentValue) {
	      if (currentValue === void 0) {
	        currentValue = this.$data.currentValue;
	      }
	      for (var _len = arguments.length, cause = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        cause[_key - 1] = arguments[_key];
	      }
	      this.$emit.apply(this, ['valueSelected', currentValue].concat(cause));
	      this.$emit.apply(this, ['value-selected', currentValue].concat(cause));
	    },
	    handleStateChange: function handleStateChange(changes) {
	      var isOpen = changes.isOpen;
	      this.isOpen = isOpen;
	    },
	    getBackgroundColor: function getBackgroundColor(highlightedIndex, index) {
	      var isDark = this.themePreset === 'dark';
	      if (isDark) {
	        return highlightedIndex === index ? '#555' : '#424242';
	      }
	      return highlightedIndex === index ? '#eee' : '#fff';
	    },
	    renderIcon: function renderIcon() {
	      var h = this.$createElement;
	      if (this.$props.showIcon) {
	        return this.$props.icon || h(SearchSvg);
	      }
	      return null;
	    },
	    renderErrorComponent: function renderErrorComponent() {
	      var h = this.$createElement;
	      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
	      if (this.error && renderError && this.$data.currentValue && !this.isLoading) {
	        return h(SuggestionWrapper, {
	          "attrs": {
	            "innerClass": this.$props.innerClass,
	            "innerClassName": "error",
	            "theme": this.theme,
	            "themePreset": this.themePreset
	          }
	        }, [isFunction$1(renderError) ? renderError(this.error) : renderError]);
	      }
	      return null;
	    },
	    renderCancelIcon: function renderCancelIcon() {
	      var h = this.$createElement;
	      if (this.$props.showClear) {
	        return this.$props.clearIcon || h(CancelSvg);
	      }
	      return null;
	    },
	    renderNoSuggestions: function renderNoSuggestions(finalSuggestionsList) {
	      if (finalSuggestionsList === void 0) {
	        finalSuggestionsList = [];
	      }
	      var h = this.$createElement;
	      var _this$$props4 = this.$props,
	        theme = _this$$props4.theme,
	        innerClass = _this$$props4.innerClass;
	      var renderNoSuggestion = this.$scopedSlots.renderNoSuggestion || this.$props.renderNoSuggestion;
	      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
	      var _this$$data = this.$data,
	        isOpen = _this$$data.isOpen,
	        currentValue = _this$$data.currentValue;
	      if (renderNoSuggestion && isOpen && !finalSuggestionsList.length && !this.isLoading && currentValue && !(renderError && this.error)) {
	        return h(SuggestionWrapper, {
	          "attrs": {
	            "innerClass": innerClass,
	            "themePreset": this.themePreset,
	            "theme": theme,
	            "innerClassName": "noSuggestion"
	          },
	          "scopedSlots": {
	            "default": function _default() {
	              return typeof renderNoSuggestion === 'function' ? renderNoSuggestion(currentValue) : renderNoSuggestion;
	            }
	          }
	        });
	      }
	      return null;
	    },
	    renderInputAddonBefore: function renderInputAddonBefore() {
	      var h = this.$createElement;
	      var addonBefore = this.$scopedSlots.addonBefore;
	      if (addonBefore) {
	        return h(InputAddon, [addonBefore()]);
	      }
	      return null;
	    },
	    renderTag: function renderTag(item) {
	      var _this3 = this;
	      var h = this.$createElement;
	      var innerClass = this.$props.innerClass;
	      return h(TagItem, {
	        "class": getClassName$3(innerClass, 'selected-tag') || ''
	      }, [h("span", [item]), h("span", {
	        "attrs": {
	          "role": "img",
	          "aria-label": "delete-tag"
	        },
	        "class": "close-icon",
	        "on": {
	          "click": function click() {
	            return _this3.clearTag(item);
	          }
	        }
	      }, [h(CancelSvg)])]);
	    },
	    clearAllTags: function clearAllTags() {
	      this.selectedTags = [];
	      this.setValue('', true, this.$props, lib_7.SUGGESTION_SELECT);
	      if (this.$props.value !== undefined) {
	        this.$emit('change', this.selectedTags, this.triggerQuery);
	      }
	    },
	    clearTag: function clearTag(tagValue) {
	      this.selectedTags = [].concat(this.selectedTags.filter(function (tag) {
	        return tag !== tagValue;
	      }));
	      this.setValue('', true, this.$props, lib_7.SUGGESTION_SELECT);
	      if (this.$props.value !== undefined) {
	        this.$emit('change', this.selectedTags, this.triggerQuery);
	      }
	    },
	    renderTags: function renderTags() {
	      var _this4 = this;
	      var h = this.$createElement;
	      if (!Array.isArray(this.selectedTags)) {
	        return null;
	      }
	      var tagsList = [].concat(this.selectedTags);
	      var shouldRenderClearAllTag = tagsList.length > 1;
	      var renderSelectedTags = this.$scopedSlots.renderSelectedTags || this.$props.renderSelectedTags;
	      return renderSelectedTags ? renderSelectedTags({
	        values: this.selectedTags,
	        handleClear: this.clearTag,
	        handleClearAll: this.clearAllTags
	      }) : h(TagsContainer, [tagsList.map(function (item) {
	        return _this4.renderTag(item);
	      }), shouldRenderClearAllTag && h(TagItem, {
	        "class": getClassName$3(this.$props.innerClass, 'selected-tag') || ''
	      }, [h("span", ["Clear All"]), h("span", {
	        "attrs": {
	          "role": "img",
	          "aria-label": "delete-tag"
	        },
	        "class": "close-icon",
	        "on": {
	          "click": this.clearAllTags
	        }
	      }, [h(CancelSvg)])])]);
	    },
	    renderInputAddonAfter: function renderInputAddonAfter() {
	      var h = this.$createElement;
	      var addonAfter = this.$scopedSlots.addonAfter;
	      if (addonAfter) {
	        return h(InputAddon, [addonAfter()]);
	      }
	      return null;
	    },
	    renderIcons: function renderIcons() {
	      var h = this.$createElement;
	      var _this$$props5 = this.$props,
	        iconPosition = _this$$props5.iconPosition,
	        showClear = _this$$props5.showClear,
	        innerClass = _this$$props5.innerClass,
	        getMicInstance = _this$$props5.getMicInstance,
	        showVoiceSearch = _this$$props5.showVoiceSearch,
	        showIcon = _this$$props5.showIcon;
	      var renderMic = this.$scopedSlots.renderMic || this.$props.renderMic;
	      var currentValue = this.$data.currentValue;
	      return h("div", [h(IconGroup, {
	        "attrs": {
	          "groupPosition": "right",
	          "positionType": "absolute"
	        }
	      }, [currentValue && showClear && h(IconWrapper, {
	        "on": {
	          "click": this.clearValue
	        },
	        "attrs": {
	          "showIcon": showIcon,
	          "isClearIcon": true
	        }
	      }, [this.renderCancelIcon()]), showVoiceSearch && h(Mic, {
	        "attrs": {
	          "getInstance": getMicInstance,
	          "render": renderMic,
	          "handleResult": this.handleVoiceResults,
	          "className": getClassName$3(innerClass, 'mic') || null
	        }
	      }), iconPosition === 'right' && showIcon && h(IconWrapper, {
	        "on": {
	          "click": this.handleSearchIconClick
	        }
	      }, [this.renderIcon()])]), h(IconGroup, {
	        "attrs": {
	          "groupPosition": "left",
	          "positionType": "absolute"
	        }
	      }, [iconPosition === 'left' && showIcon && h(IconWrapper, {
	        "on": {
	          "click": this.handleSearchIconClick
	        }
	      }, [this.renderIcon()])])]);
	    },
	    focusSearchBox: function focusSearchBox(event) {
	      var _this$$refs, _this$$refs$this$$pro;
	      var elt = event.target || event.srcElement;
	      var tagName = elt.tagName;
	      if (elt.isContentEditable || tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA') {
	        // already in an input
	        return;
	      }
	      (_this$$refs = this.$refs) == null ? void 0 : (_this$$refs$this$$pro = _this$$refs[this.$props.innerRef]) == null ? void 0 : _this$$refs$this$$pro.focus(); // eslint-disable-line
	    },
	    listenForFocusShortcuts: function listenForFocusShortcuts() {
	      var _this5 = this;
	      var _this$$props$focusSho = this.$props.focusShortcuts,
	        focusShortcuts = _this$$props$focusSho === void 0 ? ['/'] : _this$$props$focusSho;
	      if (isEmpty(focusShortcuts)) {
	        return;
	      }
	      var shortcutsString = parseFocusShortcuts(focusShortcuts).join(',');

	      // handler for alphabets and other key combinations
	      hotkeys(shortcutsString,
	      // eslint-disable-next-line no-unused-vars
	      /* eslint-disable no-shadow */
	      function (event, handler) {
	        // Prevent the default refresh event under WINDOWS system
	        event.preventDefault();
	        _this5.focusSearchBox(event);
	      });

	      // if one of modifier keys are used, they are handled below
	      hotkeys('*', function (event) {
	        var modifierKeys = extractModifierKeysFromFocusShortcuts(focusShortcuts);
	        if (modifierKeys.length === 0) return;
	        for (var index = 0; index < modifierKeys.length; index += 1) {
	          var element = modifierKeys[index];
	          if (hotkeys[element]) {
	            _this5.focusSearchBox(event);
	            break;
	          }
	        }
	      });
	    }
	  },
	  render: function render() {
	    var _this6 = this;
	    var h = arguments[0];
	    var _this$$props6 = this.$props,
	      theme = _this$$props6.theme,
	      size = _this$$props6.size,
	      expandSuggestionsContainer = _this$$props6.expandSuggestionsContainer,
	      enableDefaultSuggestions = _this$$props6.enableDefaultSuggestions;
	    var _this$$scopedSlots = this.$scopedSlots,
	      recentSearchesIcon = _this$$scopedSlots.recentSearchesIcon,
	      popularSearchesIcon = _this$$scopedSlots.popularSearchesIcon;
	    var hasSuggestions = this.currentValue ? this.suggestionsList.length || this.topSuggestions.length : this.defaultSearchSuggestions.length;
	    if (enableDefaultSuggestions === false && !this.currentValue) {
	      hasSuggestions = false;
	    }
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$3(this.$props.innerClass, 'title') || ''
	    }, [this.$props.title]), this.$props.defaultSuggestions || this.$props.autosuggest ? h(Downshift, {
	      "attrs": {
	        "id": this.$props.componentId + "-downshift",
	        "handleChange": this.onSuggestionSelected,
	        "handleMouseup": this.handleStateChange,
	        "isOpen": this.$data.isOpen
	      },
	      "scopedSlots": {
	        "default": function _default(_ref4) {
	          var getInputEvents = _ref4.getInputEvents,
	            getInputProps = _ref4.getInputProps,
	            getItemProps = _ref4.getItemProps,
	            getItemEvents = _ref4.getItemEvents,
	            isOpen = _ref4.isOpen,
	            highlightedIndex = _ref4.highlightedIndex,
	            setHighlightedIndex = _ref4.setHighlightedIndex;
	          var renderSuggestionsContainer = function renderSuggestionsContainer() {
	            return h("div", [_this6.hasCustomRenderer && _this6.getComponent({
	              isOpen: isOpen,
	              getItemProps: getItemProps,
	              getItemEvents: getItemEvents,
	              highlightedIndex: highlightedIndex
	            }), _this6.renderErrorComponent(), !_this6.hasCustomRenderer && isOpen && hasSuggestions ? h("ul", {
	              "class": suggestions$1(_this6.themePreset, theme) + " " + getClassName$3(_this6.$props.innerClass, 'list')
	            }, [_this6.suggestionsList.slice(0, size || 10).map(function (item, index) {
	              return h("li", {
	                "domProps": _extends({}, getItemProps({
	                  item: item
	                })),
	                "on": _extends({}, getItemEvents({
	                  item: item
	                })),
	                "key": index + 1 + "-" + item.value,
	                "style": {
	                  backgroundColor: _this6.getBackgroundColor(highlightedIndex, index)
	                }
	              }, [h(SuggestionItem, {
	                "attrs": {
	                  "currentValue": _this6.currentValue,
	                  "suggestion": item
	                }
	              })]);
	            }), _this6.defaultSearchSuggestions.map(function (sugg, index) {
	              return h("li", {
	                "domProps": _extends({}, getItemProps({
	                  item: sugg
	                })),
	                "on": _extends({}, getItemEvents({
	                  item: sugg
	                })),
	                "key": _this6.suggestionsList.length + index + 1 + "-" + sugg.value,
	                "style": {
	                  backgroundColor: _this6.getBackgroundColor(highlightedIndex, _this6.suggestionsList.length + index),
	                  justifyContent: 'flex-start'
	                }
	              }, [h("div", {
	                "style": {
	                  padding: '0 10px 0 0'
	                }
	              }, [sugg.source && sugg.source._recent_search && h(CustomSvg, {
	                "attrs": {
	                  "className": getClassName$3(_this6.$props.innerClass, 'recent-search-icon') || null,
	                  "icon": recentSearchesIcon,
	                  "type": "recent-search-icon"
	                }
	              }), sugg.source && sugg.source._popular_suggestion && h(CustomSvg, {
	                "attrs": {
	                  "className": getClassName$3(_this6.$props.innerClass, 'popular-search-icon') || null,
	                  "icon": popularSearchesIcon,
	                  "type": "popular-search-icon"
	                }
	              })]), h(SuggestionItem, {
	                "attrs": {
	                  "currentValue": _this6.currentValue,
	                  "suggestion": sugg
	                }
	              })]);
	            }), hasQuerySuggestionsRenderer(_this6) ? _this6.getComponent({
	              isOpen: isOpen,
	              getItemProps: getItemProps,
	              getItemEvents: getItemEvents,
	              highlightedIndex: highlightedIndex
	            }, true) : _this6.topSuggestions.map(function (sugg, index) {
	              return h("li", {
	                "domProps": _extends({}, getItemProps({
	                  item: sugg
	                })),
	                "on": _extends({}, getItemEvents({
	                  item: sugg
	                })),
	                "key": _this6.suggestionsList.length + index + 1 + "-" + sugg.value,
	                "style": {
	                  backgroundColor: _this6.getBackgroundColor(highlightedIndex, _this6.suggestionsList.length + index),
	                  justifyContent: 'flex-start'
	                }
	              }, [h("div", {
	                "style": {
	                  padding: '0 10px 0 0'
	                }
	              }, [h(CustomSvg, {
	                "attrs": {
	                  "className": getClassName$3(_this6.$props.innerClass, 'popular-search-icon') || null,
	                  "icon": popularSearchesIcon,
	                  "type": "popular-search-icon"
	                }
	              })]), h(SuggestionItem, {
	                "attrs": {
	                  "currentValue": _this6.currentValue,
	                  "suggestion": sugg
	                }
	              })]);
	            })]) : _this6.renderNoSuggestions(_this6.suggestionsList)]);
	          };
	          return h("div", {
	            "class": suggestionsContainer
	          }, [h(InputGroup, [_this6.renderInputAddonBefore(), h(InputWrapper, [h(Input, {
	            "attrs": {
	              "id": _this6.$props.componentId + "-input",
	              "showIcon": _this6.$props.showIcon,
	              "showClear": _this6.$props.showClear,
	              "iconPosition": _this6.$props.iconPosition,
	              "placeholder": _this6.$props.placeholder,
	              "autoFocus": _this6.$props.autoFocus,
	              "themePreset": _this6.themePreset,
	              "autocomplete": "off"
	            },
	            "ref": _this6.$props.innerRef,
	            "class": getClassName$3(_this6.$props.innerClass, 'input'),
	            "on": _extends({}, getInputEvents({
	              onInput: _this6.onInputChange,
	              onBlur: function onBlur(e) {
	                _this6.$emit('blur', e, _this6.triggerQuery);
	              },
	              onFocus: _this6.handleFocus,
	              onKeyPress: function onKeyPress(e) {
	                _this6.$emit('keyPress', e, _this6.triggerQuery);
	                _this6.$emit('key-press', e, _this6.triggerQuery);
	              },
	              onKeyDown: function onKeyDown(e) {
	                return _this6.handleKeyDown(e, highlightedIndex);
	              },
	              onKeyUp: function onKeyUp(e) {
	                _this6.$emit('keyUp', e, _this6.triggerQuery);
	                _this6.$emit('key-up', e, _this6.triggerQuery);
	              },
	              onClick: function onClick() {
	                setHighlightedIndex(null);
	              }
	            })),
	            "domProps": _extends({}, getInputProps({
	              value: _this6.$data.currentValue === null || typeof _this6.$data.currentValue !== 'string' ? '' : _this6.$data.currentValue
	            }))
	          }), _this6.renderIcons(), !expandSuggestionsContainer && renderSuggestionsContainer()]), ' ', _this6.renderInputAddonAfter()]), expandSuggestionsContainer && renderSuggestionsContainer(), _this6.renderTags()]);
	        }
	      }
	    }) : h("div", {
	      "class": suggestionsContainer
	    }, [h(InputGroup, [this.renderInputAddonBefore(), h(InputWrapper, [h(Input, {
	      "class": getClassName$3(this.$props.innerClass, 'input') || '',
	      "attrs": {
	        "placeholder": this.$props.placeholder,
	        "iconPosition": this.$props.iconPosition,
	        "showIcon": this.$props.showIcon,
	        "showClear": this.$props.showClear,
	        "themePreset": this.themePreset
	      },
	      "on": _extends({}, {
	        blur: function blur(e) {
	          _this6.$emit('blur', e, _this6.triggerQuery);
	        },
	        keypress: function keypress(e) {
	          _this6.$emit('keyPress', e, _this6.triggerQuery);
	          _this6.$emit('key-press', e, _this6.triggerQuery);
	        },
	        input: this.onInputChange,
	        focus: function focus(e) {
	          _this6.$emit('focus', e, _this6.triggerQuery);
	        },
	        keydown: function keydown(e) {
	          _this6.handleKeyDown(e, null);
	        },
	        keyup: function keyup(e) {
	          _this6.$emit('keyUp', e, _this6.triggerQuery);
	          _this6.$emit('key-up', e, _this6.triggerQuery);
	        }
	      }),
	      "domProps": _extends({}, {
	        autofocus: this.$props.autoFocus,
	        value: this.$data.currentValue ? this.$data.currentValue : ''
	      }),
	      "ref": this.$props.innerRef
	    }), this.renderIcons()]), this.renderInputAddonAfter()]), this.renderTags()])]);
	  },
	  destroyed: function destroyed() {
	    document.removeEventListener('keydown', this.onKeyDown);
	  }
	};
	DataSearch.defaultQuery = function (value, props) {
	  var finalQuery = null;
	  if (value) {
	    var fields = normalizeDataField(props.dataField, props.fieldWeights);
	    finalQuery = {
	      bool: {
	        should: DataSearch.shouldQuery(value, fields, props),
	        minimum_should_match: '1'
	      }
	    };
	  }
	  if (value === '') {
	    finalQuery = null;
	  }
	  if (finalQuery && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: finalQuery
	        }
	      }
	    };
	  }
	  return finalQuery;
	};
	DataSearch.shouldQuery = function (value, dataFields, props) {
	  var finalQuery = [];
	  var phrasePrefixFields = [];
	  var fields = dataFields.map(function (dataField) {
	    var queryField = "" + dataField.field + (dataField.weight ? "^" + dataField.weight : '');
	    if (!(dataField.field.endsWith('.keyword') || dataField.field.endsWith('.autosuggest') || dataField.field.endsWith('.search'))) {
	      phrasePrefixFields.push(queryField);
	    }
	    return queryField;
	  });
	  if (props.searchOperators || props.queryString) {
	    return {
	      query: value,
	      fields: fields,
	      default_operator: props.queryFormat
	    };
	  }
	  if (props.queryFormat === 'and') {
	    finalQuery.push({
	      multi_match: {
	        query: value,
	        fields: fields,
	        type: 'cross_fields',
	        operator: 'and'
	      }
	    });
	    finalQuery.push({
	      multi_match: {
	        query: value,
	        fields: fields,
	        type: 'phrase',
	        operator: 'and'
	      }
	    });
	    if (phrasePrefixFields.length > 0) {
	      finalQuery.push({
	        multi_match: {
	          query: value,
	          fields: phrasePrefixFields,
	          type: 'phrase_prefix',
	          operator: 'and'
	        }
	      });
	    }
	    return finalQuery;
	  }
	  finalQuery.push({
	    multi_match: {
	      query: value,
	      fields: fields,
	      type: 'best_fields',
	      operator: 'or',
	      fuzziness: props.fuzziness ? props.fuzziness : 0
	    }
	  });
	  finalQuery.push({
	    multi_match: {
	      query: value,
	      fields: fields,
	      type: 'phrase',
	      operator: 'or'
	    }
	  });
	  if (phrasePrefixFields.length > 0) {
	    finalQuery.push({
	      multi_match: {
	        query: value,
	        fields: phrasePrefixFields,
	        type: 'phrase_prefix',
	        operator: 'or'
	      }
	    });
	  }
	  return finalQuery;
	};
	DataSearch.highlightQuery = function (props) {
	  if (props.customHighlight) {
	    return props.customHighlight(props);
	  }
	  if (!props.highlight) {
	    return null;
	  }
	  var fields = {};
	  var highlightField = props.highlightField ? props.highlightField : props.dataField;
	  if (typeof highlightField === 'string') {
	    fields[highlightField] = {};
	  } else if (Array.isArray(highlightField)) {
	    highlightField.forEach(function (item) {
	      fields[item] = {};
	    });
	  }
	  return {
	    highlight: _extends({
	      pre_tags: ['<mark>'],
	      post_tags: ['</mark>'],
	      fields: fields
	    }, props.highlightField && {
	      require_field_match: false
	    })
	  };
	};
	DataSearch.hasInternalComponent = function () {
	  return true;
	};
	var mapStateToProps$3 = function mapStateToProps(state, props) {
	  return {
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    suggestions: state.hits[props.componentId] && state.hits[props.componentId].hits,
	    rawData: state.rawData[props.componentId],
	    aggregationData: state.compositeAggregations[props.componentId] || [],
	    isLoading: !!state.isLoading[props.componentId + "_active"],
	    themePreset: state.config.themePreset,
	    error: state.error[props.componentId],
	    analytics: state.analytics,
	    enableAppbase: state.config.enableAppbase,
	    headers: state.appbaseRef.headers,
	    promotedResults: state.promotedResults[props.componentId] || [],
	    customData: state.customData[props.componentId],
	    time: state.hits[props.componentId] && state.hits[props.componentId].time || 0,
	    total: state.hits[props.componentId] && state.hits[props.componentId].total,
	    hidden: state.hits[props.componentId] && state.hits[props.componentId].hidden,
	    popularSuggestions: state.querySuggestions[props.componentId],
	    defaultPopularSuggestions: state.defaultPopularSuggestions[props.componentId],
	    componentProps: state.props[props.componentId],
	    lastUsedQuery: state.queryToHits[props.componentId],
	    recentSearches: state.recentSearches.data
	  };
	};
	var mapDispatchToProps$2 = {
	  setQueryOptions: setQueryOptions$1,
	  updateQuery: updateQuery$1,
	  setCustomQuery: setCustomQuery,
	  setDefaultQuery: setDefaultQuery$1,
	  setCustomHighlightOptions: setCustomHighlightOptions,
	  recordSuggestionClick: recordSuggestionClick,
	  loadPopularSuggestions: loadPopularSuggestions,
	  getRecentSearches: getRecentSearches,
	  resetStoreForComponent: resetStoreForComponent
	};
	var DSConnected = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$3, mapDispatchToProps$2)(DataSearch), {
	  componentType: constants_1$1.dataSearch,
	  internalComponent: DataSearch.hasInternalComponent()
	}));
	DSConnected.defaultQuery = DataSearch.defaultQuery;
	DSConnected.shouldQuery = DataSearch.shouldQuery;
	DSConnected.highlightQuery = DataSearch.highlightQuery;
	DSConnected.hasInternalComponent = DataSearch.hasInternalComponent;
	DSConnected.name = DataSearch.name;

	// plugins usage
	DSConnected.install = function (Vue) {
	  Vue.component(DSConnected.name, DSConnected);
	};
	// Add componentType for SSR
	DSConnected.componentType = constants_1$1.dataSearch;

	var _templateObject$k;
	var AutofillSvgIcon = index$1('button')(_templateObject$k || (_templateObject$k = _taggedTemplateLiteralLoose(["\n\tdisplay: flex;\n\tmargin-left: auto;\n\tposition: relative;\n\tright: -3px;\n\tborder: none;\n\toutline: none;\n\tbackground: transparent;\n\tpadding: 0;\n\tz-index: 111000;\n\n\tsvg {\n\t\tcursor: pointer;\n\t\tfill: #707070;\n\t\theight: 20px;\n\t}\n\n\t&:hover {\n\t\tsvg {\n\t\t\tfill: #1c1a1a;\n\t\t}\n\t}\n"])));
	var AutoFillSvg = {
	  name: 'AutoFillSvg',
	  render: function render() {
	    var h = arguments[0];
	    return h(AutofillSvgIcon, {
	      "on": {
	        "click": this.$listeners.click
	      }
	    }, [h("svg", {
	      "attrs": {
	        "viewBox": "0 0 24 24"
	      }
	    }, [h("path", {
	      "attrs": {
	        "d": "M8 17v-7.586l8.293 8.293c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414l-8.293-8.293h7.586c0.552 0 1-0.448 1-1s-0.448-1-1-1h-10c-0.552 0-1 0.448-1 1v10c0 0.552 0.448 1 1 1s1-0.448 1-1z"
	      }
	    })])]);
	  },
	  methods: {
	    clicked: function clicked(e) {
	      e.stopPropagation();
	      window.console.log('hey', e);
	    }
	  }
	};

	var updateQuery$2 = lib_5.updateQuery,
	  setCustomQuery$1 = lib_5.setCustomQuery,
	  setDefaultQuery$2 = lib_5.setDefaultQuery,
	  recordSuggestionClick$1 = lib_5.recordSuggestionClick;
	var _debounce = lib_8.debounce,
	  checkValueChange$1 = lib_8.checkValueChange,
	  getClassName$4 = lib_8.getClassName,
	  isEqual$5 = lib_8.isEqual,
	  getCompositeAggsQuery$2 = lib_8.getCompositeAggsQuery,
	  withClickIds$1 = lib_8.withClickIds,
	  getResultStats$2 = lib_8.getResultStats,
	  normalizeDataField$1 = lib_8.normalizeDataField;
	var SearchBox = {
	  name: 'SearchBox',
	  isTagsMode: false,
	  data: function data() {
	    var props = this.$props;
	    this.__state = {
	      currentValue: '',
	      selectedTags: [],
	      isOpen: false,
	      normalizedSuggestions: []
	    };
	    this.internalComponent = props.componentId + "__internal";
	    return this.__state;
	  },
	  inject: {
	    theme: {
	      from: 'theme_reactivesearch'
	    }
	  },
	  created: function created() {
	    var _this$$props = this.$props,
	      distinctField = _this$$props.distinctField,
	      distinctFieldConfig = _this$$props.distinctFieldConfig,
	      index = _this$$props.index,
	      mode = _this$$props.mode;
	    if (mode === constants_5$1.TAG) {
	      this.$options.isTagsMode = true;
	    }
	    if (this.$options.isTagsMode) {
	      console.warn('Warning(ReactiveSearch): The `categoryField` prop is not supported when `mode` prop is set to `tag`');
	    }
	    if (this.enableAppbase && this.aggregationField && this.aggregationField !== '') {
	      console.warn('Warning(ReactiveSearch): The `aggregationField` prop has been marked as deprecated, please use the `distinctField` prop instead.');
	    }
	    if (!this.enableAppbase && (distinctField || distinctFieldConfig)) {
	      console.warn('Warning(ReactiveSearch): In order to use the `distinctField` and `distinctFieldConfig` props, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    if (!this.enableAppbase && index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    this.currentValue = decodeHtml(this.selectedValue || this.value || this.defaultValue || '');
	    if (this.$options.isTagsMode) {
	      this.currentValue = '';
	    }
	    this.handleTextChange = _debounce(this.handleText, this.$props.debounce);

	    // Set custom and default queries in store
	    this.triggerCustomQuery(this.currentValue, this.selectedCategory);
	    this.triggerDefaultQuery(this.currentValue);
	  },
	  computed: {
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    },
	    stats: function stats() {
	      return getResultStats$2(this);
	    }
	  },
	  props: {
	    autoFocus: VueTypes.bool,
	    autosuggest: VueTypes.bool.def(true),
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    clearIcon: types.children,
	    componentId: types.stringRequired,
	    customHighlight: types.func,
	    customQuery: types.func,
	    defaultQuery: types.func,
	    dataField: VueTypes.oneOfType([VueTypes.string, VueTypes.shape({
	      field: VueTypes.string,
	      weight: VueTypes.number
	    }), VueTypes.arrayOf(VueTypes.string), VueTypes.arrayOf({
	      field: VueTypes.string,
	      weight: VueTypes.number
	    })]),
	    aggregationField: types.string,
	    aggregationSize: VueTypes.number,
	    size: VueTypes.number,
	    debounce: VueTypes.number.def(0),
	    defaultValue: types.string,
	    excludeFields: types.excludeFields,
	    value: VueTypes.oneOfType([VueTypes.arrayOf(VueTypes.string), types.value]),
	    defaultSuggestions: types.suggestions,
	    enableSynonyms: VueTypes.bool.def(true),
	    enableQuerySuggestions: VueTypes.bool.def(false),
	    enablePopularSuggestions: VueTypes.bool.def(false),
	    enableRecentSuggestions: VueTypes.bool.def(false),
	    fieldWeights: types.fieldWeights,
	    filterLabel: types.string,
	    fuzziness: types.fuzziness,
	    highlight: VueTypes.bool,
	    highlightField: types.stringOrArray,
	    icon: types.children,
	    iconPosition: VueTypes.oneOf(['left', 'right']).def('left'),
	    includeFields: types.includeFields,
	    innerClass: types.style,
	    innerRef: VueTypes.string.def('searchInputField'),
	    render: types.func,
	    renderNoSuggestion: types.title,
	    renderError: types.title,
	    placeholder: VueTypes.string.def('Search'),
	    queryFormat: VueTypes.oneOf(['and', 'or']).def('or'),
	    react: types.react,
	    showClear: VueTypes.bool.def(true),
	    showDistinctSuggestions: VueTypes.bool.def(true),
	    showFilter: VueTypes.bool.def(true),
	    showIcon: VueTypes.bool.def(true),
	    title: types.title,
	    theme: types.style,
	    URLParams: VueTypes.bool.def(false),
	    strictSelection: VueTypes.bool.def(false),
	    nestedField: types.string,
	    enablePredictiveSuggestions: VueTypes.bool.def(false),
	    recentSearchesIcon: VueTypes.any,
	    popularSearchesIcon: VueTypes.any,
	    //	mic props
	    showVoiceSearch: VueTypes.bool.def(false),
	    getMicInstance: types.func,
	    renderMic: types.func,
	    distinctField: types.string,
	    distinctFieldConfig: types.props,
	    //
	    focusShortcuts: VueTypes.arrayOf(VueTypes.oneOfType([VueTypes.string, VueTypes.number])).def(['/']),
	    addonBefore: VueTypes.any,
	    addonAfter: VueTypes.any,
	    expandSuggestionsContainer: VueTypes.bool.def(true),
	    index: VueTypes.string,
	    popularSuggestionsConfig: VueTypes.object,
	    recentSuggestionsConfig: VueTypes.object,
	    applyStopwords: VueTypes.bool,
	    customStopwords: types.stringArray,
	    onData: types.func,
	    renderItem: types.func,
	    enterButton: VueTypes.bool.def(false),
	    renderEnterButton: VueTypes.any,
	    mode: VueTypes.oneOf(['select', 'tag']).def('select'),
	    renderSelectedTags: VueTypes.any,
	    searchboxId: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  beforeMount: function beforeMount() {
	    if (this.selectedValue) {
	      this.setValue(this.selectedValue, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	    } else if (this.$props.value) {
	      this.setValue(this.$props.value, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	    } else if (this.$props.defaultValue) {
	      this.setValue(this.$props.defaultValue, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined);
	    }
	  },
	  mounted: function mounted() {
	    this.listenForFocusShortcuts();
	  },
	  watch: {
	    dataField: function dataField(newVal, oldVal) {
	      if (!isEqual$5(newVal, oldVal)) {
	        this.triggerCustomQuery(this.$data.currentValue);
	      }
	    },
	    fieldWeights: function fieldWeights() {
	      this.triggerCustomQuery(this.$data.currentValue);
	    },
	    fuzziness: function fuzziness() {
	      this.triggerCustomQuery(this.$data.currentValue);
	    },
	    queryFormat: function queryFormat() {
	      this.triggerCustomQuery(this.$data.currentValue);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(newVal, true, this.$props);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$5(newVal, oldVal)) {
	        this.setValue(newVal, true, this.$props, newVal === '' ? lib_7.CLEAR_VALUE : undefined, false);
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.triggerDefaultQuery(this.$data.currentValue);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.triggerCustomQuery(this.$data.currentValue);
	      }
	    },
	    suggestions: function suggestions(newVal) {
	      var suggestionsList = [];
	      if (Array.isArray(newVal) && newVal.length) {
	        suggestionsList = [].concat(withClickIds$1(newVal));
	      } else if (Array.isArray(this.$props.defaultSuggestions) && this.$props.defaultSuggestions.length) {
	        suggestionsList = [].concat(withClickIds$1(this.$props.defaultSuggestions));
	      }
	      this.normalizedSuggestions = suggestionsList;
	    },
	    selectedValue: function selectedValue(newVal, oldVal) {
	      if (!isEqual$5(newVal, oldVal) && (this.$options.isTagsMode ? !isEqual$5(this.$data.selectedTags, newVal) : this.$data.currentValue !== newVal)) {
	        if (!newVal && this.$data.currentValue) {
	          // selected value is cleared, call onValueSelected
	          this.onValueSelectedHandler('', lib_7.CLEAR_VALUE);
	        }
	        if (this.$options.isTagsMode) {
	          // handling reset of tags through SelectedFilters or URL
	          this.selectedTags = [];
	        }
	        var cause = !newVal ? lib_7.CLEAR_VALUE : undefined;
	        if (this.$options.isTagsMode) {
	          cause = lib_7.SUGGESTION_SELECT;
	        }
	        this.setValue(newVal || '', true, this.$props, cause);
	      }
	    },
	    focusShortcuts: function focusShortcuts() {
	      this.listenForFocusShortcuts();
	    },
	    rawData: function rawData(newVal) {
	      this.$emit('on-data', {
	        data: this.normalizedSuggestions,
	        rawData: newVal,
	        aggregationData: this.aggregationData,
	        loading: this.isLoading,
	        error: this.isError
	      });
	    },
	    aggregationData: function aggregationData(newVal) {
	      this.$emit('on-data', {
	        data: this.normalizedSuggestions,
	        rawData: this.rawData,
	        aggregationData: newVal,
	        loading: this.isLoading,
	        error: this.isError
	      });
	    },
	    loading: function loading(newVal) {
	      this.$emit('on-data', {
	        data: this.normalizedSuggestions,
	        rawData: this.rawData,
	        aggregationData: this.aggregationData,
	        loading: newVal,
	        error: this.isError
	      });
	    },
	    error: function error(newVal) {
	      this.$emit('on-data', {
	        data: this.normalizedSuggestions,
	        rawData: this.rawData,
	        aggregationData: this.aggregationData,
	        loading: this.isLoading,
	        error: newVal
	      });
	    },
	    debounce: function debounce(newVal, oldVal) {
	      if (!isEqual$5(newVal, oldVal)) {
	        this.handleTextChange = _debounce(this.handleText, newVal);
	      }
	    }
	  },
	  methods: {
	    handleText: function handleText(value, cause) {
	      if (cause === lib_7.CLEAR_VALUE) {
	        this.triggerCustomQuery(value);
	        this.triggerDefaultQuery(value);
	      } else if (this.$props.autosuggest) {
	        this.triggerDefaultQuery(value);
	      } else if (!this.$props.enterButton) {
	        this.triggerCustomQuery(value);
	      }
	    },
	    validateDataField: function validateDataField() {
	      var propName = 'dataField';
	      var componentName = SearchBox.name;
	      var props = this.$props;
	      var requiredError = propName + " supplied to " + componentName + " is required. Validation failed.";
	      var propValue = props[propName];
	      if (!this.enableAppbase) {
	        if (!propValue) {
	          console.error(requiredError);
	          return;
	        }
	        if (typeof propValue !== 'string' && typeof propValue !== 'object' && !Array.isArray(propValue)) {
	          console.error("Invalid " + propName + " supplied to " + componentName + ". Validation failed.");
	          return;
	        }
	        if (Array.isArray(propValue) && propValue.length === 0) {
	          console.error(requiredError);
	        }
	      }
	    },
	    getComponent: function getComponent$1(downshiftProps) {
	      if (downshiftProps === void 0) {
	        downshiftProps = {};
	      }
	      var currentValue = this.$data.currentValue;
	      var data = {
	        error: this.error,
	        loading: this.isLoading,
	        downshiftProps: downshiftProps,
	        data: this.normalizedSuggestions,
	        rawData: this.rawData,
	        value: currentValue,
	        resultStats: this.stats
	      };
	      return getComponent(data, this);
	    },
	    // returns size and aggs property
	    getBasicQueryOptions: function getBasicQueryOptions() {
	      var aggregationField = this.$props.aggregationField;
	      var queryOptions = helper_36(this.$props);
	      if (aggregationField) {
	        queryOptions.aggs = getCompositeAggsQuery$2({
	          props: this.$props,
	          showTopHits: true
	        }).aggs;
	      }
	      return queryOptions;
	    },
	    handleSearchIconClick: function handleSearchIconClick() {
	      var currentValue = this.currentValue;
	      if (currentValue.trim()) {
	        this.setValue(currentValue, true);
	        this.onValueSelectedHandler(currentValue, lib_7.SEARCH_ICON_CLICK);
	      }
	    },
	    setValue: function setValue(value, isDefaultValue, props, cause, toggleIsOpen, categoryValue) {
	      var _this = this;
	      if (isDefaultValue === void 0) {
	        isDefaultValue = false;
	      }
	      if (props === void 0) {
	        props = this.$props;
	      }
	      if (toggleIsOpen === void 0) {
	        toggleIsOpen = true;
	      }
	      if (categoryValue === void 0) {
	        categoryValue = undefined;
	      }
	      var performUpdate = function performUpdate() {
	        if (_this.$options.isTagsMode && isEqual$5(value, _this.selectedTags)) {
	          return;
	        }
	        if (_this.$options.isTagsMode && cause === lib_7.SUGGESTION_SELECT) {
	          if (Array.isArray(_this.selectedTags) && _this.selectedTags.length) {
	            // check if value already present in selectedTags
	            if (typeof value === 'string' && _this.selectedTags.includes(value)) {
	              _this.isOpen = false;
	              return;
	            }
	            _this.selectedTags = [].concat(_this.selectedTags);
	            if (typeof value === 'string' && !!value) {
	              _this.selectedTags.push(value);
	            } else if (Array.isArray(value) && !isEqual$5(_this.selectedTags, value)) {
	              _this.selectedTags = value;
	            }
	          } else if (value) {
	            _this.selectedTags = typeof value !== 'string' ? value : [].concat(value);
	          }
	          _this.currentValue = '';
	        } else {
	          _this.currentValue = decodeHtml(value);
	        }
	        var queryHandlerValue = value;
	        if (_this.$options.isTagsMode && cause === lib_7.SUGGESTION_SELECT) {
	          queryHandlerValue = Array.isArray(_this.selectedTags) && _this.selectedTags.length ? _this.selectedTags : undefined;
	        }
	        if (isDefaultValue) {
	          if (_this.$props.autosuggest) {
	            if (toggleIsOpen) {
	              _this.isOpen = false;
	            }
	            if (typeof _this.currentValue === 'string') _this.triggerDefaultQuery(_this.currentValue);
	          } // in case of strict selection only SUGGESTION_SELECT should be able
	          // to set the query otherwise the value should reset
	          if (props.strictSelection) {
	            if (cause === lib_7.SUGGESTION_SELECT || (_this.$options.isTagsMode ? _this.selectedTags.length === 0 : value === '')) {
	              _this.triggerCustomQuery(queryHandlerValue, _this.$options.isTagsMode ? undefined : categoryValue);
	            } else {
	              _this.setValue('', true);
	            }
	          } else if (props.value === undefined || cause === lib_7.SUGGESTION_SELECT || cause === lib_7.CLEAR_VALUE) {
	            _this.triggerCustomQuery(queryHandlerValue, _this.$options.isTagsMode ? undefined : categoryValue);
	          }
	        } else {
	          // debounce for handling text while typing
	          _this.handleTextChange(value, cause);
	        }
	        _this.$emit('valueChange', value);
	        _this.$emit('value-change', value);
	      };
	      checkValueChange$1(props.componentId, value, props.beforeValueChange, performUpdate);
	    },
	    triggerDefaultQuery: function triggerDefaultQuery(paramValue) {
	      if (!this.$props.autosuggest) {
	        return;
	      }
	      var value = typeof paramValue !== 'string' ? this.currentValue : paramValue;
	      var query = SearchBox.defaultQuery(value, this.$props);
	      if (this.defaultQuery) {
	        var defaultQueryToBeSet = this.defaultQuery(value, this.$props) || {};
	        if (defaultQueryToBeSet.query) {
	          query = defaultQueryToBeSet.query;
	        }

	        // Update calculated default query in store
	        updateDefaultQuery(this.$props.componentId, this.setDefaultQuery, this.$props, value);
	      }
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query,
	        value: value,
	        componentType: constants_1$1.searchBox
	      });
	    },
	    triggerCustomQuery: function triggerCustomQuery(paramValue, categoryValue) {
	      if (categoryValue === void 0) {
	        categoryValue = undefined;
	      }
	      var _this$$props2 = this.$props,
	        customQuery = _this$$props2.customQuery,
	        filterLabel = _this$$props2.filterLabel,
	        showFilter = _this$$props2.showFilter,
	        URLParams = _this$$props2.URLParams;
	      var value = typeof paramValue !== 'string' ? this.$data.currentValue : paramValue;
	      if (this.$options.isTagsMode) {
	        value = paramValue;
	      }
	      var defaultQueryTobeSet = SearchBox.defaultQuery("" + value + (categoryValue ? " in " + categoryValue : ''), this.$props);
	      var query = defaultQueryTobeSet;
	      if (customQuery) {
	        var customQueryTobeSet = customQuery(value, this.$props);
	        var queryTobeSet = customQueryTobeSet.query;
	        if (queryTobeSet) {
	          query = queryTobeSet;
	        }
	        updateCustomQuery(this.$props.componentId, this.setCustomQuery, this.$props, value);
	      }
	      this.updateQuery({
	        componentId: this.$props.componentId,
	        query: query,
	        value: value,
	        label: filterLabel,
	        showFilter: showFilter,
	        URLParams: URLParams,
	        componentType: constants_1$1.searchBox,
	        category: categoryValue
	      });
	    },
	    handleFocus: function handleFocus(event) {
	      if (this.$props.autosuggest) {
	        this.isOpen = true;
	      }
	      this.$emit('focus', event);
	    },
	    handleVoiceResults: function handleVoiceResults(_ref) {
	      var results = _ref.results;
	      if (results && results[0] && results[0].isFinal && results[0][0] && results[0][0].transcript && results[0][0].transcript.trim()) {
	        this.setValue(results[0][0].transcript.trim(), true);
	      }
	    },
	    triggerQuery: function triggerQuery(_ref2) {
	      var _ref2$isOpen = _ref2.isOpen,
	        isOpen = _ref2$isOpen === void 0 ? undefined : _ref2$isOpen,
	        _ref2$customQuery = _ref2.customQuery,
	        customQuery = _ref2$customQuery === void 0 ? true : _ref2$customQuery,
	        _ref2$defaultQuery = _ref2.defaultQuery,
	        defaultQuery = _ref2$defaultQuery === void 0 ? true : _ref2$defaultQuery,
	        _ref2$value = _ref2.value,
	        value = _ref2$value === void 0 ? undefined : _ref2$value,
	        _ref2$categoryValue = _ref2.categoryValue,
	        categoryValue = _ref2$categoryValue === void 0 ? undefined : _ref2$categoryValue;
	      if (typeof isOpen === 'boolean') {
	        this.isOpen = isOpen;
	      }
	      if (customQuery) {
	        this.triggerCustomQuery(value, categoryValue);
	      }
	      if (defaultQuery) {
	        this.triggerDefaultQuery(value);
	      }
	    },
	    triggerClickAnalytics: function triggerClickAnalytics(searchPosition, documentId) {
	      // click analytics would only work client side and after javascript loads
	      var docId = documentId;
	      if (!docId) {
	        var hitData = this.normalizedSuggestions.find(function (hit) {
	          return hit._click_id === searchPosition;
	        });
	        if (hitData && hitData.source && hitData.source._id) {
	          docId = hitData.source._id;
	        }
	      }
	      this.recordSuggestionClick(searchPosition, docId);
	    },
	    clearValue: function clearValue() {
	      this.setValue('', false, this.$props, lib_7.CLEAR_VALUE, false);
	      this.onValueSelectedHandler('', lib_7.CLEAR_VALUE);
	    },
	    handleKeyDown: function handleKeyDown(event, highlightedIndex) {
	      if (highlightedIndex === void 0) {
	        highlightedIndex = null;
	      }
	      // if a suggestion was selected, delegate the handling to suggestion handler
	      if (event.key === 'Enter') {
	        if (this.$props.autosuggest === false) {
	          this.enterButtonOnClick();
	        } else if (highlightedIndex === null) {
	          this.setValue(event.target.value, true, this.$props, this.$options.isTagsMode ? lib_7.SUGGESTION_SELECT : undefined // to handle tags
	          );

	          this.onValueSelectedHandler(event.target.value, lib_7.ENTER_PRESS);
	        }
	      }

	      // Need to review
	      this.$emit('keyDown', event, this.triggerQuery);
	      this.$emit('key-down', event, this.triggerQuery);
	    },
	    onInputChange: function onInputChange(e) {
	      var _this2 = this;
	      var inputValue = e.target.value;
	      if (!this.$data.isOpen && this.$props.autosuggest) {
	        this.isOpen = true;
	      }
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.setValue(inputValue, false, this.$props, inputValue === '' ? lib_7.CLEAR_VALUE : undefined);
	      } else {
	        this.$emit('change', inputValue, function (_ref3) {
	          var isOpen = _ref3.isOpen;
	          return _this2.triggerQuery({
	            defaultQuery: true,
	            customQuery: true,
	            value: inputValue,
	            isOpen: isOpen
	          });
	        }, e);
	      }
	    },
	    onSuggestionSelected: function onSuggestionSelected(suggestion) {
	      var _this3 = this;
	      this.isOpen = false;
	      var value = this.$props.value;
	      // Record analytics for selected suggestions
	      this.triggerClickAnalytics(suggestion._click_id);
	      if (value === undefined) {
	        this.setValue(suggestion.value, true, this.$props, lib_7.SUGGESTION_SELECT, false, suggestion._category);
	      } else {
	        var emitValue = suggestion.value;
	        if (this.$options.isTagsMode) {
	          emitValue = Array.isArray(this.selectedTags) ? [].concat(this.selectedTags) : [];
	          if (this.selectedTags.includes(suggestion.value)) {
	            // avoid duplicates in tags array
	            this.isOpen = false;
	            return;
	          }
	          emitValue.push(suggestion.value);
	        }
	        this.setValue(emitValue, true, this.$props, lib_7.SUGGESTION_SELECT, false, suggestion._category);
	        this.$emit('change', emitValue, function (_ref4) {
	          var isOpen = _ref4.isOpen;
	          return _this3.triggerQuery(_extends({
	            isOpen: isOpen,
	            value: emitValue
	          }, !_this3.$options.isTagsMode && {
	            categoryValue: suggestion._category
	          }));
	        });
	      }
	      this.onValueSelectedHandler(suggestion.value, lib_7.SUGGESTION_SELECT, suggestion.source);
	    },
	    onValueSelectedHandler: function onValueSelectedHandler(currentValue) {
	      if (currentValue === void 0) {
	        currentValue = this.$data.currentValue;
	      }
	      for (var _len = arguments.length, cause = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        cause[_key - 1] = arguments[_key];
	      }
	      this.$emit.apply(this, ['valueSelected', currentValue].concat(cause));
	      this.$emit.apply(this, ['value-selected', currentValue].concat(cause));
	    },
	    handleStateChange: function handleStateChange(changes) {
	      var isOpen = changes.isOpen;
	      this.isOpen = isOpen;
	    },
	    getBackgroundColor: function getBackgroundColor(highlightedIndex, index) {
	      var isDark = this.themePreset === 'dark';
	      if (isDark) {
	        return highlightedIndex === index ? '#555' : '#424242';
	      }
	      return highlightedIndex === index ? '#eee' : '#fff';
	    },
	    renderIcon: function renderIcon() {
	      var h = this.$createElement;
	      if (this.$props.showIcon) {
	        return this.$props.icon || h(SearchSvg);
	      }
	      return null;
	    },
	    renderErrorComponent: function renderErrorComponent() {
	      var h = this.$createElement;
	      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
	      if (this.error && renderError && this.$data.currentValue && !this.isLoading) {
	        return h(SuggestionWrapper, {
	          "attrs": {
	            "innerClass": this.$props.innerClass,
	            "innerClassName": "error",
	            "theme": this.theme,
	            "themePreset": this.themePreset
	          }
	        }, [isFunction$1(renderError) ? renderError(this.error) : renderError]);
	      }
	      return null;
	    },
	    renderCancelIcon: function renderCancelIcon() {
	      var h = this.$createElement;
	      if (this.$props.showClear) {
	        return this.$props.clearIcon || h(CancelSvg);
	      }
	      return null;
	    },
	    renderNoSuggestions: function renderNoSuggestions(finalSuggestionsList) {
	      if (finalSuggestionsList === void 0) {
	        finalSuggestionsList = [];
	      }
	      var h = this.$createElement;
	      var _this$$props3 = this.$props,
	        theme = _this$$props3.theme,
	        innerClass = _this$$props3.innerClass;
	      var renderNoSuggestion = this.$scopedSlots.renderNoSuggestion || this.$props.renderNoSuggestion;
	      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
	      var _this$$data = this.$data,
	        isOpen = _this$$data.isOpen,
	        currentValue = _this$$data.currentValue;
	      if (renderNoSuggestion && isOpen && !finalSuggestionsList.length && !this.isLoading && currentValue && !(renderError && this.error)) {
	        return h(SuggestionWrapper, {
	          "attrs": {
	            "innerClass": innerClass,
	            "themePreset": this.themePreset,
	            "theme": theme,
	            "innerClassName": "noSuggestion"
	          },
	          "scopedSlots": {
	            "default": function _default() {
	              return typeof renderNoSuggestion === 'function' ? renderNoSuggestion(currentValue) : renderNoSuggestion;
	            }
	          }
	        });
	      }
	      return null;
	    },
	    renderInputAddonBefore: function renderInputAddonBefore() {
	      var h = this.$createElement;
	      var addonBefore = this.$scopedSlots.addonBefore;
	      if (addonBefore) {
	        return h(InputAddon, {
	          "class": "addon-before"
	        }, [addonBefore()]);
	      }
	      return null;
	    },
	    renderInputAddonAfter: function renderInputAddonAfter() {
	      var h = this.$createElement;
	      var addonAfter = this.$scopedSlots.addonAfter;
	      if (addonAfter) {
	        return h(InputAddon, {
	          "class": "addon-after"
	        }, [addonAfter()]);
	      }
	      return null;
	    },
	    enterButtonOnClick: function enterButtonOnClick() {
	      this.triggerQuery({
	        isOpen: false,
	        value: this.currentValue,
	        customQuery: true
	      });
	    },
	    renderEnterButtonElement: function renderEnterButtonElement() {
	      var _this4 = this;
	      var h = this.$createElement;
	      var _this$$props4 = this.$props,
	        enterButton = _this$$props4.enterButton,
	        innerClass = _this$$props4.innerClass;
	      var renderEnterButton = this.$scopedSlots.renderEnterButton;
	      if (enterButton) {
	        var getEnterButtonMarkup = function getEnterButtonMarkup() {
	          if (renderEnterButton) {
	            return renderEnterButton(_this4.enterButtonOnClick);
	          }
	          return h(Button, {
	            "class": "enter-btn " + getClassName$4(innerClass, 'enter-button'),
	            "attrs": {
	              "primary": true
	            },
	            "on": {
	              "click": _this4.enterButtonOnClick
	            }
	          }, ["Search"]);
	        };
	        return h("div", {
	          "class": "enter-button-wrapper"
	        }, [getEnterButtonMarkup()]);
	      }
	      return null;
	    },
	    renderIcons: function renderIcons() {
	      var h = this.$createElement;
	      var _this$$props5 = this.$props,
	        iconPosition = _this$$props5.iconPosition,
	        showClear = _this$$props5.showClear,
	        innerClass = _this$$props5.innerClass,
	        getMicInstance = _this$$props5.getMicInstance,
	        showVoiceSearch = _this$$props5.showVoiceSearch,
	        showIcon = _this$$props5.showIcon;
	      var renderMic = this.$scopedSlots.renderMic || this.$props.renderMic;
	      var currentValue = this.$data.currentValue;
	      return h("div", [h(IconGroup, {
	        "attrs": {
	          "groupPosition": "right",
	          "positionType": "absolute"
	        }
	      }, [currentValue && showClear && h(IconWrapper, {
	        "on": {
	          "click": this.clearValue
	        },
	        "attrs": {
	          "showIcon": showIcon,
	          "isClearIcon": true
	        }
	      }, [this.renderCancelIcon()]), showVoiceSearch && h(Mic, {
	        "attrs": {
	          "getInstance": getMicInstance,
	          "render": renderMic,
	          "handleResult": this.handleVoiceResults,
	          "className": getClassName$4(innerClass, 'mic') || null
	        }
	      }), iconPosition === 'right' && showIcon && h(IconWrapper, {
	        "on": {
	          "click": this.handleSearchIconClick
	        }
	      }, [this.renderIcon()])]), h(IconGroup, {
	        "attrs": {
	          "groupPosition": "left",
	          "positionType": "absolute"
	        }
	      }, [iconPosition === 'left' && showIcon && h(IconWrapper, {
	        "on": {
	          "click": this.handleSearchIconClick
	        }
	      }, [this.renderIcon()])])]);
	    },
	    focusSearchBox: function focusSearchBox(event) {
	      var _this$$refs, _this$$refs$this$$pro;
	      var elt = event.target || event.srcElement;
	      var tagName = elt.tagName;
	      if (elt.isContentEditable || tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA') {
	        // already in an input
	        return;
	      }
	      (_this$$refs = this.$refs) == null ? void 0 : (_this$$refs$this$$pro = _this$$refs[this.$props.innerRef]) == null ? void 0 : _this$$refs$this$$pro.focus(); // eslint-disable-line
	    },
	    listenForFocusShortcuts: function listenForFocusShortcuts() {
	      var _this5 = this;
	      var _this$$props$focusSho = this.$props.focusShortcuts,
	        focusShortcuts = _this$$props$focusSho === void 0 ? ['/'] : _this$$props$focusSho;
	      if (isEmpty(focusShortcuts)) {
	        return;
	      }
	      var shortcutsString = parseFocusShortcuts(focusShortcuts).join(',');

	      // handler for alphabets and other key combinations
	      hotkeys(shortcutsString,
	      // eslint-disable-next-line no-unused-vars
	      /* eslint-disable no-shadow */
	      function (event, handler) {
	        // Prevent the default refresh event under WINDOWS system
	        event.preventDefault();
	        _this5.focusSearchBox(event);
	      });

	      // if one of modifier keys are used, they are handled below
	      hotkeys('*', function (event) {
	        var modifierKeys = extractModifierKeysFromFocusShortcuts(focusShortcuts);
	        if (modifierKeys.length === 0) return;
	        for (var index = 0; index < modifierKeys.length; index += 1) {
	          var element = modifierKeys[index];
	          if (hotkeys[element]) {
	            _this5.focusSearchBox(event);
	            break;
	          }
	        }
	      });
	    },
	    onAutofillClick: function onAutofillClick(suggestion) {
	      var value = suggestion.value;
	      this.isOpen = true;
	      this.currentValue = decodeHtml(value);
	      this.triggerDefaultQuery(value);
	    },
	    renderAutoFill: function renderAutoFill(suggestion) {
	      var _this6 = this;
	      var h = this.$createElement;
	      var handleAutoFillClick = function handleAutoFillClick(e) {
	        e.stopPropagation();
	        _this6.onAutofillClick(suggestion);
	      };
	      /* 👇 avoid showing autofill for category suggestions👇 */
	      return suggestion._category ? null : h(AutoFillSvg, {
	        "on": {
	          "click": handleAutoFillClick
	        }
	      });
	    },
	    renderTag: function renderTag(item) {
	      var _this7 = this;
	      var h = this.$createElement;
	      var innerClass = this.$props.innerClass;
	      return h(TagItem, {
	        "class": getClassName$4(innerClass, 'selected-tag') || ''
	      }, [h("span", [item]), h("span", {
	        "attrs": {
	          "role": "img",
	          "aria-label": "delete-tag"
	        },
	        "class": "close-icon",
	        "on": {
	          "click": function click() {
	            return _this7.clearTag(item);
	          }
	        }
	      }, [h(CancelSvg)])]);
	    },
	    clearAllTags: function clearAllTags() {
	      this.selectedTags = [];
	      this.setValue('', true, this.$props, lib_7.SUGGESTION_SELECT);
	      if (this.$props.value !== undefined) {
	        this.$emit('change', this.selectedTags, this.triggerQuery);
	      }
	    },
	    clearTag: function clearTag(tagValue) {
	      this.selectedTags = [].concat(this.selectedTags.filter(function (tag) {
	        return tag !== tagValue;
	      }));
	      this.setValue('', true, this.$props, lib_7.SUGGESTION_SELECT);
	      if (this.$props.value !== undefined) {
	        this.$emit('change', this.selectedTags, this.triggerQuery);
	      }
	    },
	    renderTags: function renderTags() {
	      var _this8 = this;
	      var h = this.$createElement;
	      if (!Array.isArray(this.selectedTags)) {
	        return null;
	      }
	      var tagsList = [].concat(this.selectedTags);
	      var shouldRenderClearAllTag = tagsList.length > 1;
	      var renderSelectedTags = this.$scopedSlots.renderSelectedTags || this.$props.renderSelectedTags;
	      return renderSelectedTags ? renderSelectedTags({
	        values: this.selectedTags,
	        handleClear: this.clearTag,
	        handleClearAll: this.clearAllTags
	      }) : h(TagsContainer, [tagsList.map(function (item) {
	        return _this8.renderTag(item);
	      }), shouldRenderClearAllTag && h(TagItem, {
	        "class": getClassName$4(this.$props.innerClass, 'selected-tag') || ''
	      }, [h("span", ["Clear All"]), h("span", {
	        "attrs": {
	          "role": "img",
	          "aria-label": "delete-tag"
	        },
	        "class": "close-icon",
	        "on": {
	          "click": this.clearAllTags
	        }
	      }, [h(CancelSvg)])])]);
	    }
	  },
	  render: function render() {
	    var _this9 = this;
	    var h = arguments[0];
	    var _this$$props6 = this.$props,
	      theme = _this$$props6.theme,
	      expandSuggestionsContainer = _this$$props6.expandSuggestionsContainer;
	    var _this$$scopedSlots = this.$scopedSlots,
	      recentSearchesIcon = _this$$scopedSlots.recentSearchesIcon,
	      popularSearchesIcon = _this$$scopedSlots.popularSearchesIcon;
	    var hasSuggestions = Array.isArray(this.normalizedSuggestions) && this.normalizedSuggestions.length;
	    var renderItem = this.$scopedSlots.renderItem || this.$props.renderItem;
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$4(this.$props.innerClass, 'title') || ''
	    }, [this.$props.title]), this.$props.autosuggest ? h(Downshift, {
	      "attrs": {
	        "id": this.$props.componentId + "-downshift",
	        "handleChange": this.onSuggestionSelected,
	        "handleMouseup": this.handleStateChange,
	        "isOpen": this.$data.isOpen
	      },
	      "scopedSlots": {
	        "default": function _default(_ref5) {
	          var getInputEvents = _ref5.getInputEvents,
	            getInputProps = _ref5.getInputProps,
	            getItemProps = _ref5.getItemProps,
	            getItemEvents = _ref5.getItemEvents,
	            isOpen = _ref5.isOpen,
	            highlightedIndex = _ref5.highlightedIndex,
	            setHighlightedIndex = _ref5.setHighlightedIndex;
	          var renderSuggestionsDropdown = function renderSuggestionsDropdown() {
	            var getIcon = function getIcon(iconType) {
	              switch (iconType) {
	                case helper_13.Recent:
	                  return recentSearchesIcon;
	                case helper_13.Popular:
	                  return popularSearchesIcon;
	                default:
	                  return null;
	              }
	            };
	            return h("div", [_this9.hasCustomRenderer && _this9.getComponent({
	              isOpen: isOpen,
	              getItemProps: getItemProps,
	              getItemEvents: getItemEvents,
	              highlightedIndex: highlightedIndex
	            }), _this9.renderErrorComponent(), !_this9.hasCustomRenderer && isOpen && hasSuggestions ? h("ul", {
	              "class": suggestions$1(_this9.themePreset, theme) + " " + getClassName$4(_this9.$props.innerClass, 'list')
	            }, [_this9.normalizedSuggestions.map(function (item, index) {
	              return renderItem ? h("li", {
	                "domProps": _extends({}, getItemProps({
	                  item: item
	                })),
	                "on": _extends({}, getItemEvents({
	                  item: item
	                })),
	                "key": index + 1 + "-" + item.value,
	                "style": {
	                  backgroundColor: _this9.getBackgroundColor(highlightedIndex, index),
	                  justifyContent: 'flex-start',
	                  alignItems: 'center'
	                }
	              }, [renderItem(item)]) : h("li", {
	                "domProps": _extends({}, getItemProps({
	                  item: item
	                })),
	                "on": _extends({}, getItemEvents({
	                  item: item
	                })),
	                "key": index + 1 + "-" + item.value,
	                "style": {
	                  backgroundColor: _this9.getBackgroundColor(highlightedIndex, index),
	                  justifyContent: 'flex-start',
	                  alignItems: 'center'
	                }
	              }, [h("div", {
	                "style": {
	                  padding: '0 10px 0 0',
	                  display: 'flex'
	                }
	              }, [h(CustomSvg, {
	                "attrs": {
	                  "className": getClassName$4(_this9.$props.innerClass, item._suggestion_type + "-search-icon") || null,
	                  "icon": getIcon(item._suggestion_type),
	                  "type": item._suggestion_type + "-search-icon"
	                }
	              })]), h(SuggestionItem, {
	                "attrs": {
	                  "currentValue": _this9.currentValue,
	                  "suggestion": item
	                }
	              }), _this9.renderAutoFill(item)]);
	            })]) : _this9.renderNoSuggestions(_this9.normalizedSuggestions)]);
	          };
	          return h("div", {
	            "class": suggestionsContainer
	          }, [h(InputGroup, [_this9.renderInputAddonBefore(), h(InputWrapper, [h(Input, {
	            "attrs": {
	              "id": _this9.$props.componentId + "-input",
	              "showIcon": _this9.$props.showIcon,
	              "showClear": _this9.$props.showClear,
	              "iconPosition": _this9.$props.iconPosition,
	              "placeholder": _this9.$props.placeholder,
	              "autoFocus": _this9.$props.autoFocus,
	              "themePreset": _this9.themePreset,
	              "autocomplete": "off"
	            },
	            "ref": _this9.$props.innerRef,
	            "class": getClassName$4(_this9.$props.innerClass, 'input'),
	            "on": _extends({}, getInputEvents({
	              onInput: _this9.onInputChange,
	              onBlur: function onBlur(e) {
	                _this9.$emit('blur', e, _this9.triggerQuery);
	              },
	              onFocus: _this9.handleFocus,
	              onKeyPress: function onKeyPress(e) {
	                _this9.$emit('keyPress', e, _this9.triggerQuery);
	                _this9.$emit('key-press', e, _this9.triggerQuery);
	              },
	              onKeyDown: function onKeyDown(e) {
	                return _this9.handleKeyDown(e, highlightedIndex);
	              },
	              onKeyUp: function onKeyUp(e) {
	                _this9.$emit('keyUp', e, _this9.triggerQuery);
	                _this9.$emit('key-up', e, _this9.triggerQuery);
	              },
	              onClick: function onClick() {
	                setHighlightedIndex(null);
	              }
	            })),
	            "domProps": _extends({}, getInputProps({
	              value: _this9.$data.currentValue === null ? '' : _this9.$data.currentValue
	            }))
	          }), _this9.renderIcons(), !expandSuggestionsContainer && renderSuggestionsDropdown()]), _this9.renderInputAddonAfter(), _this9.renderEnterButtonElement()]), expandSuggestionsContainer && renderSuggestionsDropdown(), _this9.renderTags()]);
	        }
	      }
	    }) : h("div", {
	      "class": suggestionsContainer
	    }, [h(InputGroup, [this.renderInputAddonBefore(), h(InputWrapper, [h(Input, {
	      "class": getClassName$4(this.$props.innerClass, 'input') || '',
	      "attrs": {
	        "placeholder": this.$props.placeholder,
	        "iconPosition": this.$props.iconPosition,
	        "showIcon": this.$props.showIcon,
	        "showClear": this.$props.showClear,
	        "themePreset": this.themePreset
	      },
	      "on": _extends({}, {
	        blur: function blur(e) {
	          _this9.$emit('blur', e, _this9.triggerQuery);
	        },
	        keypress: function keypress(e) {
	          _this9.$emit('keyPress', e, _this9.triggerQuery);
	          _this9.$emit('key-press', e, _this9.triggerQuery);
	        },
	        input: this.onInputChange,
	        focus: function focus(e) {
	          _this9.$emit('focus', e, _this9.triggerQuery);
	        },
	        keydown: this.handleKeyDown,
	        keyup: function keyup(e) {
	          _this9.$emit('keyUp', e, _this9.triggerQuery);
	          _this9.$emit('key-up', e, _this9.triggerQuery);
	        }
	      }),
	      "domProps": _extends({}, {
	        autofocus: this.$props.autoFocus,
	        value: this.$data.currentValue ? this.$data.currentValue : ''
	      }),
	      "ref": this.$props.innerRef
	    }), this.renderIcons()]), this.renderInputAddonAfter(), this.renderEnterButtonElement()])])]);
	  },
	  destroyed: function destroyed() {
	    document.removeEventListener('keydown', this.onKeyDown);
	  }
	};
	SearchBox.hasInternalComponent = function () {
	  return true;
	};
	SearchBox.defaultQuery = function (value, props) {
	  var finalQuery = null;
	  var fields = normalizeDataField$1(props.dataField, props.fieldWeights);
	  finalQuery = {
	    bool: {
	      should: SearchBox.shouldQuery(value, fields, props),
	      minimum_should_match: '1'
	    }
	  };
	  if (finalQuery && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: finalQuery
	        }
	      }
	    };
	  }
	  return finalQuery;
	};
	SearchBox.shouldQuery = function (value, dataFields, props) {
	  var finalQuery = [];
	  var phrasePrefixFields = [];
	  var fields = dataFields.map(function (dataField) {
	    var queryField = "" + dataField.field + (dataField.weight ? "^" + dataField.weight : '');
	    if (!(dataField.field.endsWith('.keyword') || dataField.field.endsWith('.autosuggest') || dataField.field.endsWith('.search'))) {
	      phrasePrefixFields.push(queryField);
	    }
	    return queryField;
	  });
	  if (props.searchOperators || props.queryString) {
	    return {
	      query: value,
	      fields: fields,
	      default_operator: props.queryFormat
	    };
	  }
	  if (props.queryFormat === 'and') {
	    finalQuery.push({
	      multi_match: {
	        query: value,
	        fields: fields,
	        type: 'cross_fields',
	        operator: 'and'
	      }
	    });
	    finalQuery.push({
	      multi_match: {
	        query: value,
	        fields: fields,
	        type: 'phrase',
	        operator: 'and'
	      }
	    });
	    if (phrasePrefixFields.length > 0) {
	      finalQuery.push({
	        multi_match: {
	          query: value,
	          fields: phrasePrefixFields,
	          type: 'phrase_prefix',
	          operator: 'and'
	        }
	      });
	    }
	    return finalQuery;
	  }
	  finalQuery.push({
	    multi_match: {
	      query: value,
	      fields: fields,
	      type: 'best_fields',
	      operator: 'or',
	      fuzziness: props.fuzziness ? props.fuzziness : 0
	    }
	  });
	  finalQuery.push({
	    multi_match: {
	      query: value,
	      fields: fields,
	      type: 'phrase',
	      operator: 'or'
	    }
	  });
	  if (phrasePrefixFields.length > 0) {
	    finalQuery.push({
	      multi_match: {
	        query: value,
	        fields: phrasePrefixFields,
	        type: 'phrase_prefix',
	        operator: 'or'
	      }
	    });
	  }
	  return finalQuery;
	};
	var mapStateToProps$4 = function mapStateToProps(state, props) {
	  return {
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    selectedCategory: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].category || null,
	    suggestions: state.hits[props.componentId] && state.hits[props.componentId].hits,
	    rawData: state.rawData[props.componentId],
	    aggregationData: state.compositeAggregations[props.componentId] || [],
	    themePreset: state.config.themePreset,
	    isLoading: !!state.isLoading[props.componentId + "_active"],
	    error: state.error[props.componentId],
	    enableAppbase: state.config.enableAppbase,
	    time: state.hits[props.componentId] && state.hits[props.componentId].time || 0,
	    total: state.hits[props.componentId] && state.hits[props.componentId].total,
	    hidden: state.hits[props.componentId] && state.hits[props.componentId].hidden
	  };
	};
	var mapDispatchToProps$3 = {
	  updateQuery: updateQuery$2,
	  setCustomQuery: setCustomQuery$1,
	  setDefaultQuery: setDefaultQuery$2,
	  recordSuggestionClick: recordSuggestionClick$1
	};
	var SBConnected = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$4, mapDispatchToProps$3)(SearchBox), {
	  componentType: constants_1$1.searchBox,
	  internalComponent: true
	}));
	SBConnected.name = SearchBox.name;
	SBConnected.defaultQuery = SearchBox.defaultQuery;
	SBConnected.shouldQuery = SearchBox.shouldQuery;
	SBConnected.hasInternalComponent = SearchBox.hasInternalComponent;
	SBConnected.install = function (Vue) {
	  Vue.component(SBConnected.name, SBConnected);
	};
	// Add componentType for SSR
	SBConnected.componentType = constants_1$1.searchBox;

	var _templateObject$l, _templateObject2$8, _templateObject3$6, _templateObject4$5, _templateObject5$3, _templateObject6$3;
	var item = {
	  width: '15px',
	  height: '15px',
	  scale: '4px'
	};
	var vh = css(_templateObject$l || (_templateObject$l = _taggedTemplateLiteralLoose(["\n\tborder: 0;\n\tclip: rect(1px, 1px, 1px, 1px);\n\tclip-path: inset(50%);\n\theight: 1px;\n\toverflow: hidden;\n\tpadding: 0;\n\tposition: absolute;\n\twidth: 1px;\n\twhite-space: nowrap;\n"])));
	var hideInputControl = css(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteralLoose(["\n\t+ label {\n\t\tpadding-left: 0;\n\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder: 0;\n\t\t\tmargin: 0;\n\t\t\tvisibility: hidden;\n\t\t}\n\t}\n\n\t&:checked {\n\t\t+ label {\n\t\t\tfont-weight: bold;\n\t\t}\n\t}\n"])));
	var formItem = function formItem(_ref) {
	  var theme = _ref.theme;
	  return css(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteralLoose(["\n\t", ";\n\n\t&:focus {\n\t\t+ label {\n\t\t\t&::before {\n\t\t\t\tbox-shadow: 0 0 0 2px ", ";\n\t\t\t}\n\t\t}\n\t}\n\n\t&:hover {\n\t\t+ label {\n\t\t\t&::before {\n\t\t\t\tborder-color: ", ";\n\t\t\t}\n\t\t}\n\t}\n\n\t&:active {\n\t\t+ label {\n\t\t\t&::before {\n\t\t\t\ttransition-duration: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t+ label {\n\t\tposition: relative;\n\t\tuser-select: none;\n\t\tdisplay: flex;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\talign-items: center;\n\t\tcursor: pointer;\n\n\t\t&::before {\n\t\t\tbackground-color: #fff;\n\t\t\tborder: 1px solid ", ";\n\t\t\tbox-sizing: content-box;\n\t\t\tcontent: '';\n\t\t\tcolor: ", ";\n\t\t\tmargin-right: calc(", " * 0.5);\n\t\t\ttop: 50%;\n\t\t\tleft: 0;\n\t\t\twidth: ", ";\n\t\t\theight: ", ";\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: middle;\n\t\t}\n\n\t\t&::after {\n\t\t\tbox-sizing: content-box;\n\t\t\tcontent: '';\n\t\t\tbackground-color: ", ";\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: calc(1px + ", " / 2);\n\t\t\twidth: calc(", " - ", ");\n\t\t\theight: calc(", " - ", ");\n\t\t\tmargin-top: calc(", " / -2 - ", " / -2);\n\t\t\ttransform: scale(0);\n\t\t\ttransform-origin: 50%;\n\t\t\ttransition: transform 200ms ease-out;\n\t\t}\n\t}\n"])), vh, curriedLighten(0.4, theme.colors.primaryColor), theme.colors.primaryColor, theme.colors.borderColor || curriedLighten(0.1, theme.colors.textColor), theme.colors.primaryColor, item.width, item.width, item.height, theme.colors.primaryColor, item.scale, item.width, item.scale, item.height, item.scale, item.height, item.scale);
	};
	var Radio = index$1('input')(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteralLoose(["\n\t", ";\n\t", ";\n\n\t+ label {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-radius: 50%;\n\t\t}\n\t}\n\n\t&:checked {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t+ label {\n\t\t\t\tcolor: ", ";\n\n\t\t\t\t&::before {\n\t\t\t\t\tanimation: none;\n\t\t\t\t\tfilter: none;\n\t\t\t\t\ttransition: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t+ label {\n\t\t\t&::before {\n\t\t\t\tanimation: none;\n\t\t\t\tbackground-color: #fff;\n\t\t\t\tborder-color: ", ";\n\t\t}\n\n\t\t&::after {\n\t\t\ttransform: scale(1);\n\t\t}\n\t}\n"])), formItem, function (props) {
	  return props.show ? null : hideInputControl;
	}, function (_ref2) {
	  var theme = _ref2.theme;
	  return theme.colors.primaryColor;
	}, function (_ref3) {
	  var theme = _ref3.theme;
	  return theme.colors.primaryColor;
	});
	var Checkbox = index$1('input')(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteralLoose(["\n\t", ";\n\t", ";\n\n\t+ label {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-radius: 0;\n\t\t}\n\n\t\t&::after {\n\t\t\tbackground-color: transparent;\n\t\t\ttop: 50%;\n\t\t\tleft: calc(1px + ", " / 5);\n\t\t\twidth: calc(", " / 2);\n\t\t\theight: calc(", " / 5);\n\t\t\tmargin-top: calc(", " / -2 / 2 * 0.8);\n\t\t\tborder-style: solid;\n\t\t\tborder-color: ", ";\n\t\t\tborder-width: 0 0 2px 2px;\n\t\t\tborder-radius: 0;\n\t\t\tborder-image: none;\n\t\t\ttransform: rotate(-45deg) scale(0);\n\t\t\ttransition: none;\n\t\t}\n\t}\n\n\t&:checked {\n\t\t+ label {\n\t\t\t&::before {\n\t\t\t\tborder-color: ", ";\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: '';\n\t\t\t\ttransform: rotate(-45deg) scale(1);\n\t\t\t\ttransition: transform 200ms ease-out;\n\t\t\t}\n\t\t}\n\t}\n"])), formItem, function (props) {
	  return props.show ? null : hideInputControl;
	}, item.width, item.width, item.width, item.height, function (_ref4) {
	  var theme = _ref4.theme;
	  return theme.colors.primaryColor;
	}, function (_ref5) {
	  var theme = _ref5.theme;
	  return theme.colors.primaryColor;
	});
	var UL = index$1('ul')(_templateObject6$3 || (_templateObject6$3 = _taggedTemplateLiteralLoose(["\n\tlist-style: none;\n\tpadding: 0;\n\tmargin: 0;\n\tmax-height: 240px;\n\tposition: relative;\n\toverflow-y: auto;\n\tpadding-bottom: 12px;\n\n\tli {\n\t\theight 30px;\n\t\tdisplay: flex;\n\t\tflex-direction: row;\n\t\talign-items: center;\n\t\tpadding-left: 2px;\n\t}\n"])));

	var getAggsOrder = lib_8.getAggsOrder;
	var extractQuery = function extractQuery(props) {
	  var queryToBeReturned = {};
	  if (props.defaultQuery) {
	    var evaluateQuery = props.defaultQuery([], props);
	    if (evaluateQuery) {
	      if (evaluateQuery.query) {
	        queryToBeReturned.query = evaluateQuery.query;
	      }
	      if (evaluateQuery.aggs) {
	        queryToBeReturned.aggs = evaluateQuery.aggs;
	      }
	    }
	  }
	  return queryToBeReturned;
	};
	// eslint-disable-next-line import/prefer-default-export
	var getAggsQuery = function getAggsQuery(query, props) {
	  var _clonedQuery$aggs;
	  var clonedQuery = query;
	  var dataField = props.dataField,
	    size = props.size,
	    sortBy = props.sortBy,
	    showMissing = props.showMissing,
	    missingLabel = props.missingLabel;
	  clonedQuery.size = 0;
	  clonedQuery.aggs = (_clonedQuery$aggs = {}, _clonedQuery$aggs[dataField] = {
	    terms: _extends({
	      field: dataField,
	      size: size,
	      order: getAggsOrder(sortBy || 'count')
	    }, showMissing ? {
	      missing: missingLabel
	    } : {})
	  }, _clonedQuery$aggs);
	  if (props.nestedField) {
	    clonedQuery.aggs = {
	      reactivesearch_nested: {
	        nested: {
	          path: props.nestedField
	        },
	        aggs: clonedQuery.aggs
	      }
	    };
	  }
	  return _extends({}, clonedQuery, extractQuery(props));
	};

	var updateQuery$3 = lib_5.updateQuery,
	  setQueryOptions$2 = lib_5.setQueryOptions,
	  setCustomQuery$2 = lib_5.setCustomQuery,
	  setDefaultQuery$3 = lib_5.setDefaultQuery;
	var getQueryOptions$1 = lib_8.getQueryOptions,
	  checkValueChange$2 = lib_8.checkValueChange,
	  getClassName$5 = lib_8.getClassName,
	  isEqual$6 = lib_8.isEqual,
	  extractQueryFromCustomQuery$2 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$2 = lib_8.getOptionsForCustomQuery;
	var SingleList = {
	  name: 'SingleList',
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    dataField: types.stringRequired,
	    defaultValue: types.string,
	    value: types.value,
	    defaultQuery: types.func,
	    filterLabel: types.string,
	    innerClass: types.style,
	    placeholder: VueTypes.string.def('Search'),
	    react: types.react,
	    render: types.func,
	    renderItem: types.func,
	    renderNoResults: VueTypes.any,
	    transformData: types.func,
	    selectAllLabel: types.string,
	    showCount: VueTypes.bool.def(true),
	    showFilter: VueTypes.bool.def(true),
	    showRadio: VueTypes.bool.def(true),
	    showSearch: VueTypes.bool.def(true),
	    size: VueTypes.number,
	    sortBy: VueTypes.oneOf(['asc', 'desc', 'count']).def('count'),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    showMissing: VueTypes.bool.def(false),
	    missingLabel: VueTypes.string.def('N/A'),
	    nestedField: types.string,
	    index: VueTypes.string,
	    enableStrictSelection: VueTypes.bool.def(false),
	    endpoint: types.endpointConfig
	  },
	  data: function data() {
	    var props = this.$props;
	    this.__state = {
	      currentValue: '',
	      modifiedOptions: [],
	      searchTerm: ''
	    };
	    this.internalComponent = props.componentId + "__internal";
	    return this.__state;
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    var props = this.$props;
	    this.modifiedOptions = this.options && this.options[props.dataField] ? this.options[props.dataField].buckets : [];
	    // Set custom and default queries in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	    updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    this.updateQueryHandlerOptions(this.$props);
	    if (this.selectedValue) {
	      this.setValue(this.selectedValue);
	    } else if (this.$props.value) {
	      this.setValue(this.$props.value);
	    } else if (this.$props.defaultValue) {
	      this.setValue(this.$props.defaultValue);
	    }
	  },
	  watch: {
	    options: function options(newVal) {
	      if (newVal) {
	        this.modifiedOptions = newVal[this.$props.dataField] ? newVal[this.$props.dataField].buckets : [];
	      }
	    },
	    size: function size() {
	      this.updateQueryHandlerOptions(this.$props);
	    },
	    sortBy: function sortBy() {
	      this.updateQueryHandlerOptions(this.$props);
	    },
	    dataField: function dataField() {
	      this.updateQueryHandlerOptions(this.$props);
	      this.updateQueryHandler(this.$data.currentValue, this.$props);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(newVal);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$6(newVal, oldVal)) {
	        this.setValue(newVal);
	      }
	    },
	    selectedValue: function selectedValue(newVal) {
	      if (this.$data.currentValue !== newVal) {
	        this.setValue(newVal || '');
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateDefaultQueryHandler(this.$data.currentValue, this.$props);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  render: function render() {
	    var _this = this;
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      selectAllLabel = _this$$props.selectAllLabel,
	      renderItem = _this$$props.renderItem,
	      renderError = _this$$props.renderError;
	    var renderItemCalc = this.$scopedSlots.renderItem || renderItem;
	    var renderErrorCalc = this.$scopedSlots.renderError || renderError;
	    if (renderErrorCalc && this.error) {
	      return isFunction$1(renderErrorCalc) ? renderErrorCalc(this.error) : renderErrorCalc;
	    }
	    if (!this.hasCustomRenderer && this.modifiedOptions.length === 0 && !this.isLoading) {
	      if (this.renderNoResults) {
	        this.renderNoResult();
	      } else {
	        return null;
	      }
	    }
	    var itemsToRender = this.$data.modifiedOptions;
	    if (this.$props.transformData) {
	      itemsToRender = this.$props.transformData(itemsToRender);
	    }
	    var filteredItemsToRender = itemsToRender.filter(function (item) {
	      if (String(item.key).length) {
	        if (_this.$props.showSearch && _this.$data.searchTerm) {
	          return suggestions_1(String(item.key)).toLowerCase().includes(suggestions_1(_this.$data.searchTerm.toLowerCase()));
	        }
	        return true;
	      }
	      return false;
	    });
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$5(this.$props.innerClass, 'title') || ''
	    }, [this.$props.title]), this.renderSearch(), this.hasCustomRenderer ? this.getComponent() : h(UL, {
	      "class": getClassName$5(this.$props.innerClass, 'list') || ''
	    }, [selectAllLabel ? h("li", {
	      "key": selectAllLabel,
	      "class": "" + (this.$data.currentValue === selectAllLabel ? 'active' : '')
	    }, [h(Radio, {
	      "class": getClassName$5(this.$props.innerClass, 'radio'),
	      "attrs": {
	        "id": this.$props.componentId + "-" + selectAllLabel,
	        "name": this.$props.componentId,
	        "value": selectAllLabel,
	        "readOnly": true,
	        "type": "radio",
	        "show": this.$props.showRadio
	      },
	      "on": {
	        "click": this.handleClick
	      },
	      "domProps": _extends({}, {
	        checked: this.$data.currentValue === selectAllLabel
	      })
	    }), h("label", {
	      "class": getClassName$5(this.$props.innerClass, 'label') || null,
	      "attrs": {
	        "for": this.$props.componentId + "-" + selectAllLabel
	      }
	    }, [h("span", [selectAllLabel, this.$props.showCount && h("span", {
	      "class": getClassName$5(this.$props.innerClass, 'count') || null
	    }, ["\xA0(", this.totalDocumentCount, ")"])])])]) : null, !this.hasCustomRenderer && filteredItemsToRender.length === 0 && !this.isLoading ? this.renderNoResult() : filteredItemsToRender.map(function (item) {
	      return h("li", {
	        "key": item.key,
	        "class": "" + (_this.currentValue === String(item.key) ? 'active' : '')
	      }, [h(Radio, {
	        "class": getClassName$5(_this.$props.innerClass, 'radio'),
	        "attrs": {
	          "id": _this.$props.componentId + "-" + item.key,
	          "name": _this.$props.componentId,
	          "value": item.key,
	          "readOnly": true,
	          "type": "radio",
	          "show": _this.$props.showRadio
	        },
	        "on": {
	          "click": _this.handleClick
	        },
	        "domProps": _extends({}, {
	          checked: _this.currentValue === String(item.key)
	        })
	      }), h("label", {
	        "class": getClassName$5(_this.$props.innerClass, 'label') || null,
	        "attrs": {
	          "for": _this.$props.componentId + "-" + item.key
	        }
	      }, [renderItemCalc ? renderItemCalc({
	        label: item.key,
	        count: item.doc_count,
	        isChecked: _this.currentValue === String(item.key)
	      }) : h("span", [item.key, _this.$props.showCount && h("span", {
	        "class": getClassName$5(_this.$props.innerClass, 'count') || null
	      }, ["\xA0(", item.doc_count, ")"])])])]);
	    })])]);
	  },
	  methods: {
	    setValue: function setValue(nextValue, props) {
	      var _this2 = this;
	      if (props === void 0) {
	        props = this.$props;
	      }
	      var value = nextValue;
	      if (nextValue === this.$data.currentValue) {
	        value = '';
	      }
	      var performUpdate = function performUpdate() {
	        _this2.currentValue = value;
	        _this2.updateQueryHandler(value, props);
	        _this2.$emit('valueChange', value);
	        _this2.$emit('value-change', value);
	      };
	      checkValueChange$2(props.componentId, value, props.beforeValueChange, performUpdate);
	    },
	    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props) {
	      var query = SingleList.defaultQuery(value, props);
	      if (this.defaultQuery) {
	        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
	        var defaultQueryObj = extractQueryFromCustomQuery$2(defaultQueryToBeSet);
	        if (defaultQueryObj) {
	          query = defaultQueryObj;
	        }

	        // Update calculated default query in store
	        updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
	        var defaultQueryOptions = getOptionsForCustomQuery$2(defaultQueryToBeSet);
	        this.setQueryOptions(this.internalComponent, defaultQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query,
	        value: value,
	        componentType: constants_1$1.singleList
	      });
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = SingleList.defaultQuery(value, props);
	      if (customQuery) {
	        var customQueryCalc = customQuery(value, props);
	        query = extractQueryFromCustomQuery$2(customQueryCalc);
	        var customQueryOptions = getOptionsForCustomQuery$2(customQueryCalc);
	        updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.singleList
	      });
	    },
	    generateQueryOptions: function generateQueryOptions(props) {
	      var queryOptions = getQueryOptions$1(props);
	      return getAggsQuery(queryOptions, props);
	    },
	    updateQueryHandlerOptions: function updateQueryHandlerOptions(props) {
	      var queryOptions = SingleList.generateQueryOptions(props);
	      if (props.defaultQuery) {
	        var value = this.$data.currentValue;
	        var defaultQueryOptions = getOptionsForCustomQuery$2(props.defaultQuery(value, props));
	        this.setQueryOptions(this.internalComponent, _extends({}, queryOptions, defaultQueryOptions));
	      } else {
	        this.setQueryOptions(this.internalComponent, queryOptions);
	      }
	    },
	    handleInputChange: function handleInputChange(e) {
	      var value = e.target.value;
	      this.searchTerm = value;
	    },
	    renderSearch: function renderSearch() {
	      var h = this.$createElement;
	      if (this.$props.showSearch) {
	        return h(Input, {
	          "class": getClassName$5(this.$props.innerClass, 'input') || '',
	          "on": {
	            "input": this.handleInputChange
	          },
	          "attrs": {
	            "value": this.$data.searchTerm,
	            "placeholder": this.$props.placeholder,
	            "themePreset": this.$props.themePreset
	          },
	          "style": {
	            margin: '0 0 8px'
	          }
	        });
	      }
	      return null;
	    },
	    getComponent: function getComponent$1() {
	      var _this$$data = this.$data,
	        currentValue = _this$$data.currentValue,
	        modifiedOptions = _this$$data.modifiedOptions;
	      var transformData = this.$props.transformData;
	      var itemsToRender = modifiedOptions;
	      if (transformData) {
	        itemsToRender = transformData(itemsToRender);
	      }
	      var data = {
	        error: this.error,
	        loading: this.isLoading,
	        value: currentValue,
	        data: itemsToRender,
	        rawData: this.rawData,
	        handleChange: this.handleClick
	      };
	      return getComponent(data, this);
	    },
	    handleClick: function handleClick(e) {
	      var currentValue = e;
	      if (isEvent(e)) {
	        currentValue = e.target.value;
	      }
	      if (this.enableStrictSelection && currentValue === this.currentValue) {
	        return false;
	      }
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.setValue(currentValue);
	      } else {
	        this.$emit('change', currentValue);
	      }
	      return true;
	    },
	    renderNoResult: function renderNoResult() {
	      var h = this.$createElement;
	      var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
	      return h("p", {
	        "class": getClassName$5(this.$props.innerClass, 'noResults') || null
	      }, [isFunction$1(renderNoResults) ? renderNoResults() : renderNoResults]);
	    }
	  },
	  computed: {
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    }
	  }
	};
	SingleList.generateQueryOptions = function (props) {
	  var queryOptions = getQueryOptions$1(props);
	  return getAggsQuery(queryOptions, props);
	};
	SingleList.defaultQuery = function (value, props) {
	  var query = null;
	  if (props.selectAllLabel && props.selectAllLabel === value) {
	    if (props.showMissing) {
	      query = {
	        match_all: {}
	      };
	    }
	    query = {
	      exists: {
	        field: props.dataField
	      }
	    };
	  }
	  if (value) {
	    var _term;
	    query = {
	      term: (_term = {}, _term[props.dataField] = value, _term)
	    };
	    if (props.showMissing && props.missingLabel === value) {
	      query = {
	        bool: {
	          must_not: {
	            exists: {
	              field: props.dataField
	            }
	          }
	        }
	      };
	    }
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	SingleList.hasInternalComponent = function () {
	  return true;
	};
	var mapStateToProps$5 = function mapStateToProps(state, props) {
	  return {
	    options: props.nestedField && state.aggregations[props.componentId] ? state.aggregations[props.componentId].reactivesearch_nested : state.aggregations[props.componentId],
	    rawData: state.rawData[props.componentId],
	    isLoading: state.isLoading[props.componentId],
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || '',
	    totalDocumentCount: state.hits[props.componentId] && state.hits[props.componentId].total,
	    themePreset: state.config.themePreset,
	    error: state.error[props.componentId],
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$2 = {
	  setQueryOptions: setQueryOptions$2,
	  updateQuery: updateQuery$3,
	  setCustomQuery: setCustomQuery$2,
	  setDefaultQuery: setDefaultQuery$3
	};
	var ListConnected = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$5, mapDispatchtoProps$2)(SingleList), {
	  componentType: constants_1$1.singleList,
	  internalComponent: SingleList.hasInternalComponent()
	}));
	ListConnected.name = SingleList.name;
	ListConnected.defaultQuery = SingleList.defaultQuery;
	ListConnected.generateQueryOptions = SingleList.generateQueryOptions;
	ListConnected.hasInternalComponent = SingleList.hasInternalComponent;
	// Add componentType for SSR
	ListConnected.componentType = constants_1$1.singleList;
	ListConnected.install = function (Vue) {
	  Vue.component(ListConnected.name, ListConnected);
	};

	var updateQuery$4 = lib_5.updateQuery,
	  setQueryOptions$3 = lib_5.setQueryOptions,
	  setCustomQuery$3 = lib_5.setCustomQuery,
	  setDefaultQuery$4 = lib_5.setDefaultQuery;
	var isEqual$7 = lib_8.isEqual,
	  getQueryOptions$2 = lib_8.getQueryOptions,
	  checkValueChange$3 = lib_8.checkValueChange,
	  getClassName$6 = lib_8.getClassName,
	  extractQueryFromCustomQuery$3 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$3 = lib_8.getOptionsForCustomQuery;
	var MultiList = {
	  name: 'MultiList',
	  props: {
	    defaultValue: types.stringArray,
	    value: types.stringArray,
	    queryFormat: VueTypes.oneOf(['and', 'or']).def('or'),
	    showCheckbox: VueTypes.bool.def(true),
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    dataField: types.stringRequired,
	    defaultQuery: types.func,
	    filterLabel: types.string,
	    innerClass: types.style,
	    placeholder: VueTypes.string.def('Search'),
	    react: types.react,
	    render: types.func,
	    renderItem: types.func,
	    renderError: types.title,
	    renderNoResults: VueTypes.any,
	    transformData: types.func,
	    selectAllLabel: types.string,
	    showCount: VueTypes.bool.def(true),
	    showFilter: VueTypes.bool.def(true),
	    showSearch: VueTypes.bool.def(true),
	    size: VueTypes.number,
	    sortBy: VueTypes.oneOf(['asc', 'desc', 'count']).def('count'),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    showMissing: VueTypes.bool.def(false),
	    missingLabel: VueTypes.string.def('N/A'),
	    nestedField: types.string,
	    index: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  data: function data() {
	    var props = this.$props;
	    this.__state = {
	      currentValue: {},
	      modifiedOptions: [],
	      searchTerm: ''
	    };
	    this.internalComponent = props.componentId + "__internal";
	    return this.__state;
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    var props = this.$props;
	    this.modifiedOptions = this.options && this.options[props.dataField] ? this.options[props.dataField].buckets : [];
	    // Set custom and default queries in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	    updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    this.updateQueryHandlerOptions(this.$props);
	    var value = this.selectedValue || this.$props.value || this.$props.defaultValue;
	    this.setValue(value, !this.selectedValue);
	  },
	  mounted: function mounted() {
	    var currentValue = Object.keys(this.$data.currentValue);
	    if (this.$props.value !== undefined && !isEqual$7(this.$props.value, currentValue)) {
	      this.$emit('change', currentValue);
	    }
	  },
	  watch: {
	    options: function options(newVal) {
	      if (newVal) {
	        this.modifiedOptions = newVal[this.$props.dataField] ? newVal[this.$props.dataField].buckets : [];
	      }
	    },
	    size: function size() {
	      this.updateQueryHandlerOptions(this.$props);
	    },
	    sortBy: function sortBy() {
	      this.updateQueryHandlerOptions(this.$props);
	    },
	    dataField: function dataField() {
	      this.updateQueryHandlerOptions(this.$props);
	      this.updateQueryHandler(this.$data.currentValue, this.$props);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$7(oldVal, newVal)) {
	        this.setValue(newVal, true);
	      }
	    },
	    defaultValue: function defaultValue(newVal, oldVal) {
	      if (!isEqual$7(oldVal, newVal)) {
	        this.setValue(newVal, true);
	      }
	    },
	    selectedValue: function selectedValue(newVal) {
	      var _this = this;
	      var selectedValue = Object.keys(this.$data.currentValue);
	      if (this.$props.selectAllLabel) {
	        selectedValue = selectedValue.filter(function (val) {
	          return val !== _this.$props.selectAllLabel;
	        });
	        if (this.$data.currentValue[this.$props.selectAllLabel]) {
	          selectedValue = [this.$props.selectAllLabel];
	        }
	      }
	      if (!isEqual$7(selectedValue, newVal)) {
	        if (this.value === undefined) {
	          this.setValue(newVal, true);
	        } else {
	          this.$emit('change', newVal);
	        }
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateDefaultQueryHandler(this.$data.currentValue, this.$props);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  render: function render() {
	    var _this2 = this;
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      selectAllLabel = _this$$props.selectAllLabel,
	      renderItem = _this$$props.renderItem,
	      renderError = _this$$props.renderError;
	    var renderItemCalc = this.$scopedSlots.renderItem || renderItem;
	    var renderErrorCalc = this.$scopedSlots.renderError || renderError;
	    if (renderErrorCalc && this.error) {
	      return isFunction$1(renderErrorCalc) ? renderErrorCalc(this.error) : renderErrorCalc;
	    }
	    if (!this.hasCustomRenderer && this.modifiedOptions.length === 0 && !this.isLoading) {
	      if (this.renderNoResults) {
	        this.renderNoResult();
	      } else {
	        return null;
	      }
	    }
	    var itemsToRender = this.$data.modifiedOptions;
	    if (this.$props.transformData) {
	      itemsToRender = this.$props.transformData(itemsToRender);
	    }
	    var filteredItemsToRender = itemsToRender.filter(function (item) {
	      if (String(item.key).length) {
	        if (_this2.$props.showSearch && _this2.$data.searchTerm) {
	          return suggestions_1(String(item.key)).toLowerCase().includes(suggestions_1(_this2.$data.searchTerm).toLowerCase());
	        }
	        return true;
	      }
	      return false;
	    });
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$6(this.$props.innerClass, 'title')
	    }, [this.$props.title]), this.renderSearch(), this.hasCustomRenderer ? this.getComponent() : h(UL, {
	      "class": getClassName$6(this.$props.innerClass, 'list')
	    }, [selectAllLabel ? h("li", {
	      "key": selectAllLabel,
	      "class": "" + (this.currentValue[selectAllLabel] ? 'active' : '')
	    }, [h(Checkbox, {
	      "attrs": {
	        "type": "checkbox",
	        "id": this.$props.componentId + "-" + selectAllLabel,
	        "name": selectAllLabel,
	        "value": selectAllLabel,
	        "show": this.$props.showCheckbox
	      },
	      "class": getClassName$6(this.$props.innerClass, 'checkbox'),
	      "on": {
	        "click": this.handleClick
	      },
	      "domProps": _extends({}, {
	        checked: !!this.currentValue[selectAllLabel]
	      })
	    }), h("label", {
	      "class": getClassName$6(this.$props.innerClass, 'label'),
	      "attrs": {
	        "for": this.$props.componentId + "-" + selectAllLabel
	      }
	    }, [h("span", [selectAllLabel, this.$props.showCount && h("span", {
	      "class": getClassName$6(this.$props.innerClass, 'count')
	    }, ["\xA0(", this.totalDocumentCount, ")"])])])]) : null, !this.hasCustomRenderer && filteredItemsToRender.length === 0 && !this.isLoading ? this.renderNoResult() : filteredItemsToRender.map(function (item) {
	      return h("li", {
	        "key": item.key,
	        "class": "" + (_this2.$data.currentValue[item.key] ? 'active' : '')
	      }, [h(Checkbox, {
	        "attrs": {
	          "type": "checkbox",
	          "id": _this2.$props.componentId + "-" + item.key,
	          "name": _this2.$props.componentId,
	          "value": item.key,
	          "show": _this2.$props.showCheckbox
	        },
	        "class": getClassName$6(_this2.$props.innerClass, 'checkbox'),
	        "on": {
	          "click": _this2.handleClick
	        },
	        "domProps": _extends({}, {
	          checked: !!_this2.$data.currentValue[item.key]
	        })
	      }), h("label", {
	        "class": getClassName$6(_this2.$props.innerClass, 'label'),
	        "attrs": {
	          "for": _this2.$props.componentId + "-" + item.key
	        }
	      }, [renderItemCalc ? renderItemCalc({
	        label: item.key,
	        count: item.doc_count,
	        isChecked: !!_this2.$data.currentValue[item.key]
	      }) : h("span", [item.key, _this2.$props.showCount && h("span", {
	        "class": getClassName$6(_this2.$props.innerClass, 'count')
	      }, ["\xA0(", item.doc_count, ")"])])])]);
	    })])]);
	  },
	  methods: {
	    setValue: function setValue(value, isDefaultValue, props) {
	      var _this3 = this;
	      if (isDefaultValue === void 0) {
	        isDefaultValue = false;
	      }
	      if (props === void 0) {
	        props = this.$props;
	      }
	      var selectAllLabel = this.$props.selectAllLabel;
	      var currentValue = this.$data.currentValue;
	      var finalValues = null;
	      if (selectAllLabel && (Array.isArray(value) && value.includes(selectAllLabel) || typeof value === 'string' && value === selectAllLabel)) {
	        if (currentValue[selectAllLabel]) {
	          currentValue = {};
	          finalValues = [];
	        } else {
	          this.$data.modifiedOptions.forEach(function (item) {
	            currentValue[item.key] = true;
	          });
	          currentValue[selectAllLabel] = true;
	          finalValues = [selectAllLabel];
	        }
	      } else if (isDefaultValue) {
	        finalValues = value;
	        currentValue = {};
	        if (value && value.length) {
	          value.forEach(function (item) {
	            currentValue[item] = true;
	          });
	        }
	        if (selectAllLabel && selectAllLabel in currentValue) {
	          var _currentValue = currentValue,
	            del = _currentValue[selectAllLabel],
	            obj = _objectWithoutPropertiesLoose(_currentValue, [selectAllLabel].map(_toPropertyKey));
	          currentValue = _extends({}, obj);
	        }
	      } else {
	        if (currentValue[value]) {
	          var _currentValue2 = currentValue,
	            _del = _currentValue2[value],
	            rest = _objectWithoutPropertiesLoose(_currentValue2, [value].map(_toPropertyKey));
	          currentValue = _extends({}, rest);
	        } else if (Array.isArray(value)) {
	          value.forEach(function (val) {
	            currentValue[val] = true;
	          });
	        } else {
	          currentValue[value] = true;
	        }
	        if (selectAllLabel && selectAllLabel in currentValue) {
	          var _currentValue3 = currentValue,
	            _del2 = _currentValue3[selectAllLabel],
	            _obj = _objectWithoutPropertiesLoose(_currentValue3, [selectAllLabel].map(_toPropertyKey));
	          currentValue = _extends({}, _obj);
	        }
	        finalValues = Object.keys(currentValue);
	      }
	      var performUpdate = function performUpdate() {
	        _this3.currentValue = Object.assign({}, currentValue);
	        _this3.updateQueryHandler(finalValues, props);
	        _this3.$emit('valueChange', finalValues);
	        _this3.$emit('value-change', finalValues);
	      };
	      checkValueChange$3(props.componentId, finalValues, props.beforeValueChange, performUpdate);
	    },
	    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props) {
	      var query = MultiList.defaultQuery(value, props);
	      if (this.defaultQuery) {
	        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
	        var defaultQueryObj = extractQueryFromCustomQuery$3(defaultQueryToBeSet);
	        if (defaultQueryObj) {
	          query = defaultQueryObj;
	        }

	        // Update calculated default query in store
	        updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
	        var defaultQueryOptions = getOptionsForCustomQuery$3(defaultQueryToBeSet);
	        this.setQueryOptions(this.internalComponent, defaultQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query,
	        value: value,
	        componentType: constants_1$1.multiList
	      });
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = MultiList.defaultQuery(value, props);
	      if (customQuery) {
	        var customQueryCalc = customQuery(value, props);
	        query = extractQueryFromCustomQuery$3(customQueryCalc);
	        updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
	        var customQueryOptions = getOptionsForCustomQuery$3(customQueryCalc);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.multiList
	      });
	    },
	    generateQueryOptions: function generateQueryOptions(props) {
	      var queryOptions = getQueryOptions$2(props);
	      return getAggsQuery(queryOptions, props);
	    },
	    updateQueryHandlerOptions: function updateQueryHandlerOptions(props) {
	      var queryOptions = MultiList.generateQueryOptions(props);
	      if (props.defaultQuery) {
	        var value = Object.keys(this.$data.currentValue);
	        var defaultQueryOptions = getOptionsForCustomQuery$3(props.defaultQuery(value, props));
	        this.setQueryOptions(this.internalComponent, _extends({}, queryOptions, defaultQueryOptions));
	      } else {
	        this.setQueryOptions(this.internalComponent, queryOptions);
	      }
	    },
	    handleInputChange: function handleInputChange(e) {
	      var value = e.target.value;
	      this.searchTerm = value;
	    },
	    renderSearch: function renderSearch() {
	      var h = this.$createElement;
	      if (this.$props.showSearch) {
	        return h(Input, {
	          "class": getClassName$6(this.$props.innerClass, 'input') || '',
	          "on": {
	            "input": this.handleInputChange
	          },
	          "attrs": {
	            "value": this.$data.searchTerm,
	            "placeholder": this.$props.placeholder,
	            "themePreset": this.$props.themePreset
	          },
	          "style": {
	            margin: '0 0 8px'
	          }
	        });
	      }
	      return null;
	    },
	    handleClick: function handleClick(e) {
	      var currentValue = e;
	      if (isEvent(e)) {
	        currentValue = e.target.value;
	      }
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.setValue(currentValue);
	      } else {
	        var values = parseValueArray(value || [], currentValue);
	        this.$emit('change', values);
	      }
	    },
	    getComponent: function getComponent$1() {
	      var _this$$data = this.$data,
	        currentValue = _this$$data.currentValue,
	        modifiedOptions = _this$$data.modifiedOptions;
	      var transformData = this.$props.transformData;
	      var itemsToRender = modifiedOptions;
	      if (transformData) {
	        itemsToRender = transformData(itemsToRender);
	      }
	      var data = {
	        error: this.error,
	        loading: this.isLoading,
	        value: currentValue,
	        data: itemsToRender,
	        rawData: this.rawData,
	        handleChange: this.handleClick
	      };
	      return getComponent(data, this);
	    },
	    renderNoResult: function renderNoResult() {
	      var h = this.$createElement;
	      var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
	      return h("p", {
	        "class": getClassName$6(this.$props.innerClass, 'noResults') || null
	      }, [isFunction$1(renderNoResults) ? renderNoResults() : renderNoResults]);
	    }
	  },
	  computed: {
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    }
	  }
	};
	MultiList.defaultQuery = function (value, props) {
	  var query = null;
	  var queryFormat = props.queryFormat;
	  if (queryFormat === undefined) {
	    queryFormat = 'or';
	  }
	  var type = queryFormat === 'or' ? 'terms' : 'term';
	  if (!Array.isArray(value) || value.length === 0) {
	    return null;
	  }
	  if (props.selectAllLabel && value.includes(props.selectAllLabel)) {
	    if (props.showMissing) {
	      query = {
	        match_all: {}
	      };
	    } else {
	      query = {
	        exists: {
	          field: props.dataField
	        }
	      };
	    }
	  } else if (value) {
	    var listQuery;
	    if (queryFormat === 'or') {
	      if (props.showMissing) {
	        var _type, _ref;
	        var hasMissingTerm = value.includes(props.missingLabel);
	        var should = [(_ref = {}, _ref[type] = (_type = {}, _type[props.dataField] = value.filter(function (item) {
	          return item !== props.missingLabel;
	        }), _type), _ref)];
	        if (hasMissingTerm) {
	          should = should.concat({
	            bool: {
	              must_not: {
	                exists: {
	                  field: props.dataField
	                }
	              }
	            }
	          });
	        }
	        listQuery = {
	          bool: {
	            should: should
	          }
	        };
	      } else {
	        var _type2, _listQuery;
	        listQuery = (_listQuery = {}, _listQuery[type] = (_type2 = {}, _type2[props.dataField] = value, _type2), _listQuery);
	      }
	    } else {
	      // adds a sub-query with must as an array of objects for each term/value
	      var queryArray = value.map(function (item) {
	        var _type3, _ref2;
	        return _ref2 = {}, _ref2[type] = (_type3 = {}, _type3[props.dataField] = item, _type3), _ref2;
	      });
	      listQuery = {
	        bool: {
	          must: queryArray
	        }
	      };
	    }
	    query = value.length ? listQuery : null;
	  }
	  if (query && props.nestedField) {
	    query = {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	MultiList.generateQueryOptions = function (props) {
	  var queryOptions = getQueryOptions$2(props);
	  return getAggsQuery(queryOptions, props);
	};
	var mapStateToProps$6 = function mapStateToProps(state, props) {
	  return {
	    options: props.nestedField && state.aggregations[props.componentId] ? state.aggregations[props.componentId].reactivesearch_nested : state.aggregations[props.componentId],
	    rawData: state.rawData[props.componentId],
	    isLoading: state.isLoading[props.componentId],
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    themePreset: state.config.themePreset,
	    totalDocumentCount: state.hits[props.componentId] && state.hits[props.componentId].total,
	    error: state.error[props.componentId],
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$3 = {
	  setQueryOptions: setQueryOptions$3,
	  updateQuery: updateQuery$4,
	  setCustomQuery: setCustomQuery$3,
	  setDefaultQuery: setDefaultQuery$4
	};
	MultiList.hasInternalComponent = function () {
	  return true;
	};
	var ListConnected$1 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$6, mapDispatchtoProps$3)(MultiList), {
	  componentType: constants_1$1.multiList,
	  internalComponent: MultiList.hasInternalComponent()
	}));
	ListConnected$1.name = MultiList.name;
	ListConnected$1.defaultQuery = MultiList.defaultQuery;
	ListConnected$1.generateQueryOptions = MultiList.generateQueryOptions;
	ListConnected$1.hasInternalComponent = MultiList.hasInternalComponent;
	// Add componentType for SSR
	ListConnected$1.componentType = constants_1$1.multiList;
	ListConnected$1.install = function (Vue) {
	  Vue.component(ListConnected$1.name, ListConnected$1);
	};

	var _templateObject$m, _templateObject2$9, _templateObject3$7, _templateObject4$6;
	var small = css(_templateObject$m || (_templateObject$m = _taggedTemplateLiteralLoose(["\n\tmin-height: 0;\n\theight: 30px;\n\tborder: 0;\n\tbox-shadow: rgba(0, 0, 0, 0.3) 0px 1px 4px -1px;\n\tborder-radius: 2px;\n"])));
	var dark$2 = function dark(_ref) {
	  var theme = _ref.theme;
	  return css(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteralLoose(["\n\tbackground-color: ", ";\n\tborder-color: ", ";\n\tcolor: ", ";\n\n\t&:hover,\n\t&:focus {\n\t\tbackground-color: ", ";\n\t}\n"])), theme.colors.backgroundColor, theme.colors.borderColor, theme.colors.textColor, theme.colors.backgroundColor);
	};
	var Select = index$1('button')(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteralLoose(["\n\twidth: 100%;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: space-between;\n\tmin-height: 42px;\n\tborder-radius: 0;\n\toutline: none;\n\tpadding: 5px 12px;\n\tfont-size: 0.9rem;\n\tline-height: 1.2rem;\n\tbackground-color: #fff;\n\tborder: 1px solid #ccc;\n\tcolor: #424242;\n\tcursor: pointer;\n\tuser-select: none;\n\ttransition: all 0.3s ease;\n\n\t", ";\n\n\t& > div {\n\t\twidth: calc(100% - 24px);\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t\ttext-align: left;\n\t}\n\n\t&:hover,\n\t&:focus {\n\t\tbackground-color: #fcfcfc;\n\t}\n\n\t", ";\n"])), function (props) {
	  return props.small ? small : null;
	}, function (_ref2) {
	  var themePreset = _ref2.themePreset;
	  return themePreset === 'dark' && dark$2;
	});
	var Tick = index$1('span')(_templateObject4$6 || (_templateObject4$6 = _taggedTemplateLiteralLoose(["\n\twidth: 16px;\n\theight: 16px;\n\tdisplay: inline-block;\n\tposition: relative;\n\tuser-select: none;\n\talign-items: center;\n\n\t&::after {\n\t\tbox-sizing: content-box;\n\t\tcontent: '';\n\t\tposition: absolute;\n\t\tbackground-color: transparent;\n\t\ttop: 50%;\n\t\tleft: 0;\n\t\twidth: 8px;\n\t\theight: 4px;\n\t\tmargin-top: -4px;\n\t\tborder-style: solid;\n\t\tborder-color: ", ";\n\t\tborder-width: 0 0 2px 2px;\n\t\tborder-radius: 0;\n\t\tborder-image: none;\n\t\ttransform: rotate(-45deg) scale(1);\n\t\ttransition: all 200ms ease-out;\n\t}\n"])), function (_ref3) {
	  var theme = _ref3.theme;
	  return theme.colors.primaryColor;
	});

	var _templateObject$n, _templateObject2$a;
	var open = css(_templateObject$n || (_templateObject$n = _taggedTemplateLiteralLoose(["\n\ttop: 0.55em;\n\ttransform: rotate(-45deg);\n"])));
	var Chevron = index$1('span')(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteralLoose(["\n\t&::before {\n\t\tcontent: '';\n\t\tborder-style: solid;\n\t\tborder-width: 0.15em 0.15em 0 0;\n\t\tdisplay: inline-block;\n\t\theight: 0.45em;\n\t\tposition: relative;\n\t\ttop: 0.35em;\n\t\tleft: 0;\n\t\ttransform: rotate(135deg);\n\t\tvertical-align: top;\n\t\twidth: 0.45em;\n\n\t\t", ";\n\t}\n"])), function (props) {
	  return props.open ? open : null;
	});

	var getClassName$7 = lib_8.getClassName;
	var Dropdown = {
	  data: function data() {
	    this.__state = {
	      isOpen: false,
	      searchTerm: ''
	    };
	    return this.__state;
	  },
	  inject: {
	    theme: {
	      from: 'theme_reactivesearch'
	    }
	  },
	  props: {
	    innerClass: types.style,
	    items: types.data,
	    keyField: VueTypes.string.def('key'),
	    labelField: VueTypes.string.def('label'),
	    multi: VueTypes.bool,
	    // change event
	    placeholder: types.string,
	    returnsObject: VueTypes.bool,
	    customLabelRenderer: types.func,
	    hasCustomRenderer: VueTypes.bool,
	    customRenderer: types.func,
	    renderItem: types.func,
	    renderNoResults: VueTypes.any,
	    handleChange: types.func,
	    transformData: types.func,
	    selectedItem: types.selectedValue,
	    showCount: VueTypes.bool,
	    single: VueTypes.bool,
	    small: VueTypes.bool.def(false),
	    themePreset: types.themePreset,
	    showSearch: VueTypes.bool,
	    showClear: VueTypes.bool,
	    searchPlaceholder: VueTypes.string.def('Type here to search...')
	  },
	  render: function render() {
	    var _this = this;
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      items = _this$$props.items,
	      selectedItem = _this$$props.selectedItem,
	      placeholder = _this$$props.placeholder,
	      labelField = _this$$props.labelField,
	      keyField = _this$$props.keyField,
	      themePreset = _this$$props.themePreset,
	      renderItem = _this$$props.renderItem,
	      transformData = _this$$props.transformData,
	      footer = _this$$props.footer,
	      customLabelRenderer = _this$$props.customLabelRenderer,
	      hasCustomRenderer = _this$$props.hasCustomRenderer,
	      customRenderer = _this$$props.customRenderer;
	    var itemsToRender = items;
	    if (transformData) {
	      itemsToRender = transformData(itemsToRender);
	    }
	    var filteredItemsToRender = itemsToRender.filter(function (item) {
	      if (String(item[labelField]).length) {
	        if (_this.$props.showSearch && _this.$data.searchTerm) {
	          return suggestions_1(String(item[labelField])).toLowerCase().includes(suggestions_1(_this.$data.searchTerm.toLowerCase()));
	        }
	        return true;
	      }
	      return false;
	    });
	    return h(Downshift, {
	      "attrs": {
	        "isOpen": this.$data.isOpen,
	        "selectedItem": selectedItem,
	        "handleChange": this.onChange,
	        "handleMouseup": this.handleStateChange
	      },
	      "scopedSlots": {
	        "default": function _default(_ref) {
	          var getItemProps = _ref.getItemProps,
	            isOpen = _ref.isOpen,
	            highlightedIndex = _ref.highlightedIndex,
	            getButtonProps = _ref.getButtonProps,
	            getItemEvents = _ref.getItemEvents,
	            getInputEvents = _ref.getInputEvents;
	          return h("div", {
	            "class": suggestionsContainer
	          }, [h(Select, {
	            "on": _extends({}, _extends({}, getButtonProps({
	              onClick: _this.toggle
	            }))),
	            "class": getClassName$7(_this.$props.innerClass, 'select') || '',
	            "attrs": {
	              "title": selectedItem ? _this.renderToString(selectedItem) : placeholder,
	              "small": _this.$props.small,
	              "themePreset": _this.$props.themePreset
	            }
	          }, [customLabelRenderer ? customLabelRenderer(selectedItem) : h("div", [selectedItem ? _this.renderToString(selectedItem) : placeholder]), h(Chevron, {
	            "attrs": {
	              "open": isOpen
	            }
	          })]), hasCustomRenderer ? customRenderer(itemsToRender, {
	            getItemProps: getItemProps,
	            isOpen: isOpen,
	            highlightedIndex: highlightedIndex,
	            getButtonProps: getButtonProps,
	            getItemEvents: getItemEvents
	          }) : isOpen && itemsToRender.length ? h("ul", {
	            "class": suggestions$1(themePreset, _this.theme) + " " + (_this.$props.small ? 'small' : '') + " " + getClassName$7(_this.$props.innerClass, 'list')
	          }, [_this.$props.showSearch ? _this.renderSearchbox({
	            on: {
	              input: getInputEvents({
	                onInput: _this.handleInputChange
	              }).input
	            }
	          }) : null, !hasCustomRenderer && filteredItemsToRender.length === 0 ? _this.renderNoResult() : filteredItemsToRender.map(function (item, index) {
	            var selected = _this.$props.multi // MultiDropdownList
	            && (selectedItem && !!selectedItem[item[keyField]] // MultiDropdownRange
	            || Array.isArray(selectedItem) && selectedItem.find(function (value) {
	              return value[labelField] === item[labelField];
	            }));
	            if (!_this.$props.multi) selected = item.key === selectedItem;
	            return h("li", {
	              "domProps": _extends({}, getItemProps({
	                item: item
	              })),
	              "on": _extends({}, getItemEvents({
	                item: item
	              })),
	              "key": item[keyField],
	              "class": "" + (selected ? 'active' : ''),
	              "style": {
	                backgroundColor: _this.getBackgroundColor(highlightedIndex === index, selected)
	              }
	            }, [renderItem ? renderItem({
	              label: item[labelField],
	              count: item.doc_count,
	              isChecked: selected && _this.$props.multi
	            }) : h("div", [typeof item[labelField] === 'string' ? h("span", {
	              "domProps": {
	                "innerHTML": item[labelField]
	              }
	            }) : item[labelField], _this.$props.showCount && item.doc_count && h("span", {
	              "class": getClassName$7(_this.$props.innerClass, 'count') || ''
	            }, ["\xA0(", item.doc_count, ")"])]), selected && _this.$props.multi ? h(Tick, {
	              "class": getClassName$7(_this.$props.innerClass, 'icon') || ''
	            }) : null]);
	          }), footer]) : null]);
	        }
	      }
	    });
	  },
	  methods: {
	    toggle: function toggle() {
	      this.isOpen = !this.$data.isOpen;
	    },
	    close: function close() {
	      this.isOpen = false;
	    },
	    onChange: function onChange(item) {
	      if (this.$props.returnsObject) {
	        this.$props.handleChange(item);
	      } else {
	        this.$props.handleChange(item[this.$props.keyField]);
	      }
	      if (!this.$props.multi) {
	        this.isOpen = false;
	        this.searchTerm = '';
	      }
	    },
	    handleStateChange: function handleStateChange(_ref2) {
	      var isOpen = _ref2.isOpen;
	      this.isOpen = isOpen;
	    },
	    getBackgroundColor: function getBackgroundColor(highlighted, selected) {
	      var isDark = this.$props.themePreset === 'dark';
	      if (highlighted) {
	        return isDark ? '#555' : '#eee';
	      }
	      if (selected) {
	        return isDark ? '#686868' : '#fafafa';
	      }
	      return isDark ? '#424242' : '#fff';
	    },
	    handleInputChange: function handleInputChange(e) {
	      var value = e.target.value;
	      this.searchTerm = value;
	    },
	    clearSearchTerm: function clearSearchTerm() {
	      this.searchTerm = '';
	    },
	    renderToString: function renderToString(value) {
	      var _this2 = this;
	      var customLabelRenderer = this.$props.customLabelRenderer;
	      if (customLabelRenderer) {
	        var customLabel = customLabelRenderer(value);
	        if (typeof customLabel === 'string') {
	          return customLabel;
	        }
	      }
	      if (Array.isArray(value) && value.length) {
	        var arrayToRender = value.map(function (item) {
	          return _this2.renderToString(item);
	        });
	        return arrayToRender.join(', ');
	      }
	      if (value && typeof value === 'object') {
	        if (value[this.$props.labelField]) {
	          return value[this.$props.labelField];
	        }
	        if (Object.keys(value).length) {
	          return this.renderToString(Object.keys(value));
	        }
	        return this.$props.placeholder;
	      }
	      return value;
	    },
	    renderNoResult: function renderNoResult() {
	      var h = this.$createElement;
	      var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
	      return h("p", {
	        "class": getClassName$7(this.$props.innerClass, 'noResults') || null
	      }, [isFunction$1(renderNoResults) ? renderNoResults() : renderNoResults]);
	    },
	    renderSearchbox: function renderSearchbox(eventObject) {
	      var h = this.$createElement;
	      var _this$$props2 = this.$props,
	        componentId = _this$$props2.componentId,
	        searchPlaceholder = _this$$props2.searchPlaceholder,
	        showClear = _this$$props2.showClear,
	        themePreset = _this$$props2.themePreset,
	        innerClass = _this$$props2.innerClass;
	      var InputComponent = h(Input, helper$1([{
	        "attrs": {
	          "id": componentId + "-input",
	          "showIcon": false,
	          "showClear": showClear,
	          "placeholder": searchPlaceholder,
	          "value": this.$data.searchTerm,
	          "themePreset": themePreset
	        },
	        "style": {
	          border: 0,
	          borderBottom: '1px solid #ddd'
	        },
	        "class": getClassName$7(innerClass, 'input')
	      }, eventObject]));
	      if (showClear) {
	        return h(InputWrapper, [InputComponent, this.searchTerm && h(IconGroup, {
	          "attrs": {
	            "groupPosition": "right",
	            "positionType": "absolute"
	          }
	        }, [h(IconWrapper, {
	          "on": {
	            "click": this.clearSearchTerm
	          },
	          "attrs": {
	            "isClearIcon": true
	          }
	        }, [h(CancelSvg)])])]);
	      }
	      return InputComponent;
	    }
	  }
	};

	var updateQuery$5 = lib_5.updateQuery,
	  setQueryOptions$4 = lib_5.setQueryOptions,
	  setCustomQuery$4 = lib_5.setCustomQuery,
	  setDefaultQuery$5 = lib_5.setDefaultQuery;
	var getQueryOptions$3 = lib_8.getQueryOptions,
	  checkValueChange$4 = lib_8.checkValueChange,
	  checkPropChange$1 = lib_8.checkPropChange,
	  getClassName$8 = lib_8.getClassName,
	  isEqual$8 = lib_8.isEqual,
	  getCompositeAggsQuery$3 = lib_8.getCompositeAggsQuery,
	  extractQueryFromCustomQuery$4 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$4 = lib_8.getOptionsForCustomQuery;
	var SingleDropdownList = {
	  name: 'SingleDropdownList',
	  data: function data() {
	    var props = this.$props;
	    this.__state = {
	      currentValue: '',
	      modifiedOptions: [],
	      after: {},
	      // for composite aggs
	      isLastBucket: false
	    };
	    this.internalComponent = props.componentId + "__internal";
	    return this.__state;
	  },
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    dataField: types.stringRequired,
	    defaultQuery: types.func,
	    defaultValue: types.string,
	    value: types.value,
	    filterLabel: types.string,
	    innerClass: types.style,
	    placeholder: VueTypes.string.def('Select a value'),
	    react: types.react,
	    renderLabel: types.func,
	    render: types.func,
	    renderItem: types.func,
	    renderError: types.title,
	    renderNoResults: VueTypes.any,
	    transformData: types.func,
	    selectAllLabel: types.string,
	    showCount: VueTypes.bool.def(true),
	    showFilter: VueTypes.bool.def(true),
	    size: VueTypes.number,
	    sortBy: VueTypes.oneOf(['asc', 'desc', 'count']).def('count'),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    showMissing: VueTypes.bool.def(false),
	    missingLabel: VueTypes.string.def('N/A'),
	    showSearch: VueTypes.bool.def(false),
	    showClear: VueTypes.bool.def(false),
	    showLoadMore: VueTypes.bool.def(false),
	    loadMoreLabel: VueTypes.oneOfType([VueTypes.string, VueTypes.any]).def('Load More'),
	    nestedField: types.string,
	    index: VueTypes.string,
	    searchPlaceholder: VueTypes.string.def('Type here to search...'),
	    endpoint: types.endpointConfig
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    var props = this.$props;
	    this.modifiedOptions = this.options && this.options[props.dataField] ? this.options[props.dataField].buckets : [];
	    // Set custom and default queries in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	    updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    this.updateQueryOptions(this.$props);
	    if (this.selectedValue) {
	      this.setValue(this.selectedValue);
	    } else if (this.$props.value) {
	      this.setValue(this.$props.value);
	    } else if (this.$props.defaultValue) {
	      this.setValue(this.$props.defaultValue);
	    }
	  },
	  watch: {
	    options: function options(newVal, oldVal) {
	      var _this = this;
	      if (newVal) {
	        checkPropChange$1(oldVal, newVal, function () {
	          var _this$$props = _this.$props,
	            showLoadMore = _this$$props.showLoadMore,
	            dataField = _this$$props.dataField;
	          var modifiedOptions = _this.$data.modifiedOptions;
	          if (showLoadMore) {
	            // append options with showLoadMore
	            var buckets = newVal[dataField].buckets;
	            var nextOptions = [].concat(modifiedOptions, buckets.map(function (bucket) {
	              return {
	                key: bucket.key[dataField],
	                doc_count: bucket.doc_count
	              };
	            }));
	            var after = newVal[dataField].after_key; // detect the last bucket by checking if the next set of buckets were empty
	            var isLastBucket = !buckets.length;
	            _this.after = {
	              after: after
	            };
	            _this.isLastBucket = isLastBucket;
	            _this.modifiedOptions = nextOptions;
	          } else {
	            _this.modifiedOptions = newVal[_this.$props.dataField] ? newVal[_this.$props.dataField].buckets : [];
	          }
	        });
	      }
	    },
	    size: function size() {
	      this.updateQueryOptions(this.$props);
	    },
	    sortBy: function sortBy() {
	      this.updateQueryOptions(this.$props);
	    },
	    dataField: function dataField() {
	      this.updateQueryOptions(this.$props);
	      this.updateQueryHandler(this.$data.currentValue, this.$props);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(newVal);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$8(newVal, oldVal)) {
	        this.setValue(newVal);
	      }
	    },
	    selectedValue: function selectedValue(newVal) {
	      if (this.$data.currentValue !== newVal) {
	        this.setValue(newVal || '');
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateDefaultQueryHandler(this.$data.currentValue, this.$props);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props2 = this.$props,
	      showLoadMore = _this$$props2.showLoadMore,
	      loadMoreLabel = _this$$props2.loadMoreLabel,
	      renderItem = _this$$props2.renderItem,
	      renderError = _this$$props2.renderError,
	      renderLabel = _this$$props2.renderLabel;
	    var isLastBucket = this.$data.isLastBucket;
	    var selectAll = [];
	    var renderItemCalc = this.$scopedSlots.renderItem || renderItem;
	    var renderErrorCalc = this.$scopedSlots.renderError || renderError;
	    var renderLabelCalc = this.$scopedSlots.renderLabel || renderLabel;
	    var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
	    if (renderErrorCalc && this.error) {
	      return isFunction$1(renderErrorCalc) ? renderErrorCalc(this.error) : renderErrorCalc;
	    }
	    if (!this.hasCustomRenderer && this.$data.modifiedOptions.length === 0 && !this.isLoading) {
	      if (renderNoResults && isFunction$1(renderNoResults)) {
	        return h("div", [renderNoResults()]);
	      }
	      if (renderNoResults && !isFunction$1(renderNoResults)) {
	        return renderNoResults;
	      }
	      return null;
	    }
	    if (this.$props.selectAllLabel) {
	      selectAll = [{
	        key: this.$props.selectAllLabel,
	        doc_count: this.totalDocumentCount
	      }];
	    }
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$8(this.$props.innerClass, 'title') || ''
	    }, [this.$props.title]), h(Dropdown, {
	      "attrs": {
	        "innerClass": this.$props.innerClass,
	        "items": [].concat(selectAll, this.$data.modifiedOptions.filter(function (item) {
	          return String(item.key).trim().length;
	        }).map(function (item) {
	          return _extends({}, item, {
	            key: String(item.key)
	          });
	        })),
	        "handleChange": this.handleChange,
	        "selectedItem": this.$data.currentValue,
	        "placeholder": this.$props.placeholder,
	        "labelField": "key",
	        "showCount": this.$props.showCount,
	        "hasCustomRenderer": this.hasCustomRenderer,
	        "customRenderer": this.getComponent,
	        "renderItem": renderItemCalc,
	        "renderNoResults": this.$scopedSlots.renderNoResults || this.$props.renderNoResults,
	        "themePreset": this.themePreset,
	        "showSearch": this.$props.showSearch,
	        "showClear": this.$props.showClear,
	        "searchPlaceholder": this.$props.searchPlaceholder,
	        "transformData": this.$props.transformData,
	        "footer": showLoadMore && !isLastBucket && h("div", {
	          "attrs": {
	            "css": loadMoreContainer
	          }
	        }, [h(Button, {
	          "on": {
	            "click": this.handleLoadMore
	          }
	        }, [loadMoreLabel])]),
	        "customLabelRenderer": renderLabelCalc
	      }
	    })]);
	  },
	  methods: {
	    setValue: function setValue(value, props) {
	      var _this2 = this;
	      if (props === void 0) {
	        props = this.$props;
	      }
	      var performUpdate = function performUpdate() {
	        _this2.currentValue = value;
	        _this2.updateQueryHandler(value, props);
	        _this2.$emit('valueChange', value);
	        _this2.$emit('value-change', value);
	      };
	      checkValueChange$4(props.componentId, value, props.beforeValueChange, performUpdate);
	    },
	    handleChange: function handleChange(item) {
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.setValue(item);
	      } else {
	        this.$emit('change', item);
	      }
	    },
	    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props) {
	      var query = SingleDropdownList.defaultQuery(value, props);
	      if (this.defaultQuery) {
	        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
	        var defaultQueryObj = extractQueryFromCustomQuery$4(defaultQueryToBeSet);
	        if (defaultQueryObj) {
	          query = defaultQueryObj;
	        }
	        // Update calculated default query in store
	        updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
	        var defaultQueryOptions = getOptionsForCustomQuery$4(defaultQueryToBeSet);
	        this.setQueryOptions(this.internalComponent, defaultQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query,
	        value: value,
	        componentType: constants_1$1.singleDropdownList
	      });
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = SingleDropdownList.defaultQuery(value, props);
	      if (customQuery) {
	        var customQueryCalc = customQuery(value, props);
	        query = extractQueryFromCustomQuery$4(customQueryCalc);
	        updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
	        var customQueryOptions = getOptionsForCustomQuery$4(customQueryCalc);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.singleDropdownList
	      });
	    },
	    generateQueryOptions: function generateQueryOptions(props, after) {
	      var queryOptions = getQueryOptions$3(props);
	      return props.showLoadMore ? getCompositeAggsQuery$3({
	        query: queryOptions,
	        props: props,
	        after: after
	      }) : getAggsQuery(queryOptions, props);
	    },
	    updateQueryOptions: function updateQueryOptions(props, addAfterKey) {
	      if (addAfterKey === void 0) {
	        addAfterKey = false;
	      }
	      // when using composite aggs flush the current options for a fresh query
	      if (props.showLoadMore && !addAfterKey) {
	        this.modifiedOptions = [];
	      } // for a new query due to other changes don't append after to get fresh results

	      var queryOptions = SingleDropdownList.generateQueryOptions(props, addAfterKey ? this.$data.after : {});
	      if (props.defaultQuery) {
	        var value = this.$data.currentValue;
	        var defaultQueryOptions = getOptionsForCustomQuery$4(props.defaultQuery(value, props));
	        this.setQueryOptions(this.internalComponent, _extends({}, queryOptions, defaultQueryOptions));
	      } else {
	        this.setQueryOptions(this.internalComponent, queryOptions);
	      }
	    },
	    handleLoadMore: function handleLoadMore() {
	      this.updateQueryOptions(this.$props, true);
	    },
	    getComponent: function getComponent$1(items, downshiftProps) {
	      if (downshiftProps === void 0) {
	        downshiftProps = {};
	      }
	      var currentValue = this.$data.currentValue;
	      var data = {
	        error: this.error,
	        loading: this.isLoading,
	        value: currentValue,
	        data: items || [],
	        rawData: this.rawData,
	        handleChange: this.handleChange,
	        downshiftProps: downshiftProps
	      };
	      return getComponent(data, this);
	    }
	  },
	  computed: {
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    }
	  }
	};
	SingleDropdownList.defaultQuery = function (value, props) {
	  var query = null;
	  if (props.selectAllLabel && props.selectAllLabel === value) {
	    if (props.showMissing) {
	      query = {
	        match_all: {}
	      };
	    }
	    query = {
	      exists: {
	        field: props.dataField
	      }
	    };
	  } else if (value) {
	    var _term;
	    if (props.showMissing && props.missingLabel === value) {
	      query = {
	        bool: {
	          must_not: {
	            exists: {
	              field: props.dataField
	            }
	          }
	        }
	      };
	    }
	    query = {
	      term: (_term = {}, _term[props.dataField] = value, _term)
	    };
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	SingleDropdownList.generateQueryOptions = function (props, after) {
	  var queryOptions = getQueryOptions$3(props);
	  return props.showLoadMore ? getCompositeAggsQuery$3({
	    query: queryOptions,
	    props: props,
	    after: after
	  }) : getAggsQuery(queryOptions, props);
	};
	SingleDropdownList.hasInternalComponent = function () {
	  return true;
	};
	var mapStateToProps$7 = function mapStateToProps(state, props) {
	  return {
	    options: props.nestedField && state.aggregations[props.componentId] ? state.aggregations[props.componentId].reactivesearch_nested : state.aggregations[props.componentId],
	    rawData: state.rawData[props.componentId],
	    isLoading: state.isLoading[props.componentId],
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || '',
	    totalDocumentCount: state.hits[props.componentId] && state.hits[props.componentId].total,
	    themePreset: state.config.themePreset,
	    error: state.error[props.componentId],
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$4 = {
	  setQueryOptions: setQueryOptions$4,
	  updateQuery: updateQuery$5,
	  setCustomQuery: setCustomQuery$4,
	  setDefaultQuery: setDefaultQuery$5
	};
	var ListConnected$2 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$7, mapDispatchtoProps$4)(SingleDropdownList), {
	  componentType: constants_1$1.singleDropdownList,
	  internalComponent: SingleDropdownList.hasInternalComponent()
	}));
	ListConnected$2.defaultQuery = SingleDropdownList.defaultQuery;
	ListConnected$2.generateQueryOptions = SingleDropdownList.generateQueryOptions;
	ListConnected$2.hasInternalComponent = SingleDropdownList.hasInternalComponent;
	ListConnected$2.name = SingleDropdownList.name;
	// Add componentType for SSR
	ListConnected$2.componentType = constants_1$1.singleDropdownList;
	ListConnected$2.install = function (Vue) {
	  Vue.component(ListConnected$2.name, ListConnected$2);
	};

	var updateQuery$6 = lib_5.updateQuery,
	  setQueryOptions$5 = lib_5.setQueryOptions,
	  setCustomQuery$5 = lib_5.setCustomQuery,
	  setDefaultQuery$6 = lib_5.setDefaultQuery;
	var isEqual$9 = lib_8.isEqual,
	  getQueryOptions$4 = lib_8.getQueryOptions,
	  checkValueChange$5 = lib_8.checkValueChange,
	  checkPropChange$2 = lib_8.checkPropChange,
	  getClassName$9 = lib_8.getClassName,
	  getCompositeAggsQuery$4 = lib_8.getCompositeAggsQuery,
	  extractQueryFromCustomQuery$5 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$5 = lib_8.getOptionsForCustomQuery;
	var MultiDropdownList = {
	  name: 'MultiDropdownList',
	  data: function data() {
	    var props = this.$props;
	    this.__state = {
	      currentValue: {},
	      modifiedOptions: [],
	      after: {},
	      // for composite aggs
	      isLastBucket: false
	    };
	    this.internalComponent = props.componentId + "__internal";
	    return this.__state;
	  },
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    dataField: types.stringRequired,
	    defaultValue: types.stringArray,
	    value: types.stringArray,
	    defaultQuery: types.func,
	    filterLabel: types.string,
	    innerClass: types.style,
	    placeholder: VueTypes.string.def('Select values'),
	    queryFormat: VueTypes.oneOf(['and', 'or']).def('or'),
	    react: types.react,
	    renderLabel: types.func,
	    render: types.func,
	    renderItem: types.func,
	    renderError: types.title,
	    renderNoResults: VueTypes.any,
	    transformData: types.func,
	    selectAllLabel: types.string,
	    showCount: VueTypes.bool.def(true),
	    showFilter: VueTypes.bool.def(true),
	    size: VueTypes.number,
	    sortBy: VueTypes.oneOf(['asc', 'desc', 'count']).def('count'),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    showMissing: VueTypes.bool.def(false),
	    missingLabel: VueTypes.string.def('N/A'),
	    showSearch: VueTypes.bool.def(false),
	    showClear: VueTypes.bool.def(false),
	    showLoadMore: VueTypes.bool.def(false),
	    loadMoreLabel: VueTypes.oneOfType([VueTypes.string, VueTypes.any]).def('Load More'),
	    nestedField: types.string,
	    index: VueTypes.string,
	    searchPlaceholder: VueTypes.string.def('Type here to search...'),
	    endpoint: types.endpointConfig
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    var props = this.$props;
	    this.modifiedOptions = this.options && this.options[props.dataField] ? this.options[props.dataField].buckets : [];
	    // Set custom and default queries in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	    updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    this.updateQueryOptions(this.$props);
	    if (this.selectedValue) {
	      this.setValue(this.selectedValue, true);
	    } else if (this.$props.value) {
	      this.setValue(this.$props.value, true);
	    } else if (this.$props.defaultValue) {
	      this.setValue(this.$props.defaultValue, true);
	    }
	  },
	  watch: {
	    selectedValue: function selectedValue(newVal) {
	      var _this = this;
	      var selectedValue = Object.keys(this.$data.currentValue);
	      if (this.$props.selectAllLabel) {
	        selectedValue = selectedValue.filter(function (val) {
	          return val !== _this.$props.selectAllLabel;
	        });
	        if (this.$data.currentValue[this.$props.selectAllLabel]) {
	          selectedValue = [this.$props.selectAllLabel];
	        }
	      }
	      if (!isEqual$9(selectedValue, newVal)) {
	        this.setValue(newVal || [], true);
	      }
	    },
	    options: function options(newVal, oldVal) {
	      var _this2 = this;
	      if (newVal) {
	        checkPropChange$2(oldVal, newVal, function () {
	          var _this2$$props = _this2.$props,
	            showLoadMore = _this2$$props.showLoadMore,
	            dataField = _this2$$props.dataField;
	          var modifiedOptions = _this2.$data.modifiedOptions;
	          if (showLoadMore) {
	            // append options with showLoadMore
	            var buckets = newVal[dataField].buckets;
	            var nextOptions = [].concat(modifiedOptions, buckets.map(function (bucket) {
	              return {
	                key: bucket.key[dataField],
	                doc_count: bucket.doc_count
	              };
	            }));
	            var after = newVal[dataField].after_key; // detect the last bucket by checking if the next set of buckets were empty
	            var isLastBucket = !buckets.length;
	            _this2.after = {
	              after: after
	            };
	            _this2.isLastBucket = isLastBucket;
	            _this2.modifiedOptions = nextOptions;
	          } else {
	            _this2.modifiedOptions = newVal[_this2.$props.dataField] ? newVal[_this2.$props.dataField].buckets : [];
	          }
	        });
	      }
	    },
	    size: function size() {
	      this.updateQueryOptions(this.$props);
	    },
	    sortBy: function sortBy() {
	      this.updateQueryOptions(this.$props);
	    },
	    dataField: function dataField() {
	      this.updateQueryOptions(this.$props);
	      this.updateQueryHandler(this.$data.currentValue, this.$props);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(newVal, true);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$9(newVal, oldVal)) {
	        this.setValue(newVal, true);
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateDefaultQueryHandler(this.$data.currentValue, this.$props);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.componentId, this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      showLoadMore = _this$$props.showLoadMore,
	      loadMoreLabel = _this$$props.loadMoreLabel,
	      renderItem = _this$$props.renderItem,
	      renderError = _this$$props.renderError,
	      renderLabel = _this$$props.renderLabel;
	    var renderItemCalc = this.$scopedSlots.renderItem || renderItem;
	    var renderErrorCalc = this.$scopedSlots.renderError || renderError;
	    var renderLabelCalc = this.$scopedSlots.renderLabel || renderLabel;
	    var isLastBucket = this.$data.isLastBucket;
	    var renderNoResults = this.$scopedSlots.renderNoResults || this.$props.renderNoResults;
	    var selectAll = [];
	    if (renderErrorCalc && this.error) {
	      return isFunction$1(renderErrorCalc) ? renderErrorCalc(this.error) : renderErrorCalc;
	    }
	    if (!this.hasCustomRenderer && this.$data.modifiedOptions.length === 0 && !this.isLoading) {
	      if (renderNoResults && isFunction$1(renderNoResults)) {
	        return h("div", [renderNoResults()]);
	      }
	      if (renderNoResults && !isFunction$1(renderNoResults)) {
	        return renderNoResults;
	      }
	      return null;
	    }
	    if (this.$props.selectAllLabel) {
	      selectAll = [{
	        key: this.$props.selectAllLabel,
	        doc_count: this.totalDocumentCount
	      }];
	    }
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$9(this.$props.innerClass, 'title') || ''
	    }, [this.$props.title]), h(Dropdown, {
	      "attrs": {
	        "innerClass": this.$props.innerClass,
	        "items": [].concat(selectAll, this.$data.modifiedOptions.filter(function (item) {
	          return String(item.key).trim().length;
	        }).map(function (item) {
	          return _extends({}, item, {
	            key: String(item.key)
	          });
	        })),
	        "hasCustomRenderer": this.hasCustomRenderer,
	        "customRenderer": this.getComponent,
	        "handleChange": this.handleChange,
	        "selectedItem": this.$data.currentValue,
	        "placeholder": this.$props.placeholder,
	        "labelField": "key",
	        "multi": true,
	        "showCount": this.$props.showCount,
	        "themePreset": this.themePreset,
	        "renderItem": renderItemCalc,
	        "renderNoResults": this.$scopedSlots.renderNoResults || this.$props.renderNoResults,
	        "showSearch": this.$props.showSearch,
	        "showClear": this.$props.showClear,
	        "searchPlaceholder": this.$props.searchPlaceholder,
	        "transformData": this.$props.transformData,
	        "footer": showLoadMore && !isLastBucket && h("div", {
	          "attrs": {
	            "css": loadMoreContainer
	          }
	        }, [h(Button, {
	          "on": {
	            "click": this.handleLoadMore
	          }
	        }, [loadMoreLabel])]),
	        "customLabelRenderer": renderLabelCalc
	      }
	    })]);
	  },
	  methods: {
	    handleChange: function handleChange(item) {
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.setValue(item);
	      } else {
	        var values = parseValueArray(this.currentValue, item);
	        this.$emit('change', values);
	      }
	    },
	    setValue: function setValue(value, isDefaultValue, props) {
	      var _this3 = this;
	      if (isDefaultValue === void 0) {
	        isDefaultValue = false;
	      }
	      if (props === void 0) {
	        props = this.$props;
	      }
	      var selectAllLabel = this.$props.selectAllLabel;
	      var currentValue = this.$data.currentValue;
	      var finalValues = null;
	      if (selectAllLabel && value.includes(selectAllLabel)) {
	        if (currentValue[selectAllLabel]) {
	          currentValue = {};
	          finalValues = [];
	        } else {
	          this.$data.modifiedOptions.forEach(function (item) {
	            currentValue[item.key] = true;
	          });
	          currentValue[selectAllLabel] = true;
	          finalValues = [selectAllLabel];
	        }
	      } else if (isDefaultValue) {
	        finalValues = value;
	        currentValue = {};
	        if (Array.isArray(value)) {
	          value.forEach(function (item) {
	            currentValue[item] = true;
	          });
	        }
	        if (selectAllLabel && selectAllLabel in currentValue) {
	          var _currentValue = currentValue,
	            del = _currentValue[selectAllLabel],
	            obj = _objectWithoutPropertiesLoose(_currentValue, [selectAllLabel].map(_toPropertyKey));
	          currentValue = _extends({}, obj);
	        }
	      } else {
	        if (currentValue[value]) {
	          var _currentValue2 = currentValue,
	            _del = _currentValue2[value],
	            rest = _objectWithoutPropertiesLoose(_currentValue2, [value].map(_toPropertyKey));
	          currentValue = _extends({}, rest);
	        } else {
	          currentValue[value] = true;
	        }
	        if (selectAllLabel && selectAllLabel in currentValue) {
	          var _currentValue3 = currentValue,
	            _del2 = _currentValue3[selectAllLabel],
	            _obj = _objectWithoutPropertiesLoose(_currentValue3, [selectAllLabel].map(_toPropertyKey));
	          currentValue = _extends({}, _obj);
	        }
	        finalValues = Object.keys(currentValue);
	      }
	      var performUpdate = function performUpdate() {
	        _this3.currentValue = _extends({}, currentValue);
	        _this3.updateQueryHandler(finalValues, props);
	        _this3.$emit('valueChange', finalValues);
	        _this3.$emit('value-change', finalValues);
	      };
	      checkValueChange$5(props.componentId, finalValues, props.beforeValueChange, performUpdate);
	    },
	    updateDefaultQueryHandler: function updateDefaultQueryHandler(value, props) {
	      var query = MultiDropdownList.defaultQuery(value, props);
	      if (this.defaultQuery) {
	        var defaultQueryToBeSet = this.defaultQuery(value, props) || {};
	        var defaultQueryObj = extractQueryFromCustomQuery$5(defaultQueryToBeSet);
	        if (defaultQueryObj) {
	          query = defaultQueryObj;
	        }
	        // Update calculated default query in store
	        updateDefaultQuery(props.componentId, this.setDefaultQuery, props, value);
	        var defaultQueryOptions = getOptionsForCustomQuery$5(defaultQueryToBeSet);
	        this.setQueryOptions(this.internalComponent, defaultQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: query,
	        value: value,
	        componentType: constants_1$1.multiDropdownList
	      });
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = MultiDropdownList.defaultQuery(value, props);
	      if (customQuery) {
	        var customQueryCalc = customQuery(value, props);
	        query = extractQueryFromCustomQuery$5(customQueryCalc);
	        updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
	        var customQueryOptions = getOptionsForCustomQuery$5(customQueryCalc);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.multiDropdownList
	      });
	    },
	    generateQueryOptions: function generateQueryOptions(props, after) {
	      var queryOptions = getQueryOptions$4(props);
	      return props.showLoadMore ? getCompositeAggsQuery$4({
	        query: queryOptions,
	        props: props,
	        after: after
	      }) : getAggsQuery(queryOptions, props);
	    },
	    updateQueryOptions: function updateQueryOptions(props, addAfterKey) {
	      if (addAfterKey === void 0) {
	        addAfterKey = false;
	      }
	      // when using composite aggs flush the current options for a fresh query
	      if (props.showLoadMore && !addAfterKey) {
	        this.modifiedOptions = [];
	      } // for a new query due to other changes don't append after to get fresh results

	      var queryOptions = MultiDropdownList.generateQueryOptions(props, addAfterKey ? this.$data.after : {});
	      if (props.defaultQuery) {
	        var value = Object.keys(this.$data.currentValue);
	        var defaultQueryOptions = getOptionsForCustomQuery$5(props.defaultQuery(value, props));
	        this.setQueryOptions(this.internalComponent, _extends({}, queryOptions, defaultQueryOptions));
	      } else {
	        this.setQueryOptions(this.internalComponent, queryOptions);
	      }
	    },
	    handleLoadMore: function handleLoadMore() {
	      this.updateQueryOptions(this.$props, true);
	    },
	    getComponent: function getComponent$1(items, downshiftProps) {
	      if (downshiftProps === void 0) {
	        downshiftProps = {};
	      }
	      var currentValue = this.$data.currentValue;
	      var data = {
	        error: this.error,
	        loading: this.isLoading,
	        value: currentValue,
	        data: items || [],
	        rawData: this.rawData,
	        handleChange: this.handleChange,
	        downshiftProps: downshiftProps
	      };
	      return getComponent(data, this);
	    }
	  },
	  computed: {
	    hasCustomRenderer: function hasCustomRenderer$1() {
	      return hasCustomRenderer(this);
	    }
	  }
	};
	MultiDropdownList.defaultQuery = function (value, props) {
	  var query = null;
	  var queryFormat = props.queryFormat;
	  if (queryFormat === undefined) {
	    queryFormat = 'or';
	  }
	  var type = queryFormat === 'or' ? 'terms' : 'term';
	  if (!Array.isArray(value) || value.length === 0) {
	    return null;
	  }
	  if (props.selectAllLabel && value.includes(props.selectAllLabel)) {
	    if (props.showMissing) {
	      query = {
	        match_all: {}
	      };
	    } else {
	      query = {
	        exists: {
	          field: props.dataField
	        }
	      };
	    }
	  } else if (value) {
	    var listQuery;
	    if (queryFormat === 'or') {
	      if (props.showMissing) {
	        var _type, _ref;
	        var hasMissingTerm = value.includes(props.missingLabel);
	        var should = [(_ref = {}, _ref[type] = (_type = {}, _type[props.dataField] = value.filter(function (item) {
	          return item !== props.missingLabel;
	        }), _type), _ref)];
	        if (hasMissingTerm) {
	          should = should.concat({
	            bool: {
	              must_not: {
	                exists: {
	                  field: props.dataField
	                }
	              }
	            }
	          });
	        }
	        listQuery = {
	          bool: {
	            should: should
	          }
	        };
	      } else {
	        var _type2, _listQuery;
	        listQuery = (_listQuery = {}, _listQuery[type] = (_type2 = {}, _type2[props.dataField] = value, _type2), _listQuery);
	      }
	    } else {
	      // adds a sub-query with must as an array of objects for each term/value
	      var queryArray = value.map(function (item) {
	        var _type3, _ref2;
	        return _ref2 = {}, _ref2[type] = (_type3 = {}, _type3[props.dataField] = item, _type3), _ref2;
	      });
	      listQuery = {
	        bool: {
	          must: queryArray
	        }
	      };
	    }
	    query = value.length ? listQuery : null;
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	MultiDropdownList.generateQueryOptions = function (props, after) {
	  var queryOptions = getQueryOptions$4(props);
	  return props.showLoadMore ? getCompositeAggsQuery$4({
	    query: queryOptions,
	    props: props,
	    after: after
	  }) : getAggsQuery(queryOptions, props);
	};
	MultiDropdownList.hasInternalComponent = function () {
	  return true;
	};
	var mapStateToProps$8 = function mapStateToProps(state, props) {
	  return {
	    options: props.nestedField && state.aggregations[props.componentId] ? state.aggregations[props.componentId].reactivesearch_nested : state.aggregations[props.componentId],
	    rawData: state.rawData[props.componentId],
	    isLoading: state.isLoading[props.componentId],
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    totalDocumentCount: state.hits[props.componentId] && state.hits[props.componentId].total,
	    themePreset: state.config.themePreset,
	    error: state.error[props.componentId],
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$5 = {
	  setQueryOptions: setQueryOptions$5,
	  updateQuery: updateQuery$6,
	  setCustomQuery: setCustomQuery$5,
	  setDefaultQuery: setDefaultQuery$6
	};
	var ListConnected$3 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$8, mapDispatchtoProps$5)(MultiDropdownList), {
	  componentType: constants_1$1.multiDropdownList,
	  internalComponent: MultiDropdownList.hasInternalComponent()
	}));
	ListConnected$3.name = MultiDropdownList.name;

	// Add componentType for SSR
	ListConnected$3.componentType = constants_1$1.multiDropdownList;
	ListConnected$3.defaultQuery = MultiDropdownList.defaultQuery;
	ListConnected$3.generateQueryOptions = MultiDropdownList.generateQueryOptions;
	ListConnected$3.hasInternalComponent = MultiDropdownList.hasInternalComponent;
	ListConnected$3.install = function (Vue) {
	  Vue.component(ListConnected$3.name, ListConnected$3);
	};

	var updateQuery$7 = lib_5.updateQuery,
	  setQueryOptions$6 = lib_5.setQueryOptions,
	  setCustomQuery$6 = lib_5.setCustomQuery;
	var isEqual$a = lib_8.isEqual,
	  checkValueChange$6 = lib_8.checkValueChange,
	  getClassName$a = lib_8.getClassName,
	  getOptionsFromQuery = lib_8.getOptionsFromQuery,
	  handleA11yAction$1 = lib_8.handleA11yAction;
	var ToggleButton = {
	  name: 'ToggleButton',
	  props: {
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    data: types.data,
	    dataField: types.stringRequired,
	    defaultValue: types.any,
	    value: types.stringOrArray,
	    filterLabel: types.string,
	    nestedField: types.string,
	    innerClass: types.style,
	    multiSelect: VueTypes.bool,
	    react: types.react,
	    showFilter: VueTypes.bool,
	    title: types.title,
	    URLParams: VueTypes.bool,
	    renderItem: types.func,
	    index: VueTypes.string,
	    enableStrictSelection: VueTypes.bool,
	    endpoint: types.endpointConfig
	  },
	  data: function data() {
	    this.__state = {
	      currentValue: []
	    };
	    return this.__state;
	  },
	  beforeMount: function beforeMount() {
	    var props = this.$props;
	    var hasMounted = false;
	    var value = this.selectedValue || props.value || props.defaultValue || [];
	    var currentValue = ToggleButton.parseValue(value, props);
	    this.setValue(currentValue);
	    if (this.$data.currentValue.length) {
	      this.handleToggle(this.$data.currentValue, true, props, hasMounted);
	    }
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    // Set custom query in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	  },
	  watch: {
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(ToggleButton.parseValue(newVal, this.$props));
	    },
	    dataField: function dataField() {
	      this.updateQuery(this.$data.currentValue, this.$props);
	    },
	    nestedField: function nestedField() {
	      this.updateQuery(this.$data.currentValue, this.$props);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$a(newVal, oldVal)) {
	        this.handleToggle(newVal, true, this.$props);
	      }
	    },
	    selectedValue: function selectedValue(newVal, oldVal) {
	      if (this.$props.multiSelect) {
	        // for multiselect selectedValue will be an array
	        if (!isEqual$a(this.$data.currentValue, newVal) && !isEqual$a(oldVal, newVal)) {
	          this.handleToggle(newVal || [], true, this.$props);
	        }
	      } else {
	        // else selectedValue will be a string
	        var currentValue = this.$data.currentValue[0] ? this.$data.currentValue[0].value : null;
	        if (!isEqual$a(currentValue, this.selectedValue) && !isEqual$a(oldVal, this.selectedValue)) {
	          this.handleToggle(this.selectedValue || [], true, this.$props);
	        }
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQuery(this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  methods: {
	    handleToggle: function handleToggle(value, isDefaultValue, props, hasMounted) {
	      if (isDefaultValue === void 0) {
	        isDefaultValue = false;
	      }
	      if (props === void 0) {
	        props = this.$props;
	      }
	      if (hasMounted === void 0) {
	        hasMounted = true;
	      }
	      var currentValue = this.$data.currentValue;
	      var toggleValue = value;
	      var finalValue = [];
	      if (isDefaultValue) {
	        finalValue = ToggleButton.parseValue(toggleValue, props);
	      } else if (this.$props.multiSelect) {
	        finalValue = currentValue.some(function (item) {
	          return item.value === toggleValue.value;
	        }) ? currentValue.filter(function (item) {
	          return item.value !== toggleValue.value;
	        }) : currentValue.concat(toggleValue);
	      } else {
	        finalValue = currentValue.some(function (item) {
	          return item.value === toggleValue.value;
	        }) ? [] : [toggleValue];
	      }
	      this.setValue(finalValue, props, hasMounted);
	    },
	    setReact: function setReact(props) {
	      if (props.react) {
	        this.watchComponent(props.componentId, props.react);
	      }
	    },
	    setValue: function setValue(value, props, hasMounted) {
	      var _this = this;
	      if (props === void 0) {
	        props = this.$props;
	      }
	      if (hasMounted === void 0) {
	        hasMounted = true;
	      }
	      var performUpdate = function performUpdate() {
	        var handleUpdates = function handleUpdates() {
	          _this.updateQuery(value, props);
	          _this.$emit('valueChange', value);
	          _this.$emit('value-change', value);
	        };
	        if (hasMounted) {
	          _this.currentValue = value;
	          handleUpdates();
	        } else {
	          handleUpdates();
	        }
	      };
	      checkValueChange$6(props.componentId, props.multiSelect ? value : value[0], props.beforeValueChange, performUpdate);
	    },
	    updateQuery: function updateQuery(value, props) {
	      var filterValue = value;
	      if (!props.multiSelect) {
	        filterValue = value[0] ? value[0].value : null;
	      }
	      var customQuery = props.customQuery;
	      var query = ToggleButton.defaultQuery(value, props);
	      if (customQuery) {
	        var _ref = customQuery(value, props) || {};
	        query = _ref.query;
	        this.setQueryOptions(props.componentId, getOptionsFromQuery(customQuery(value, props)), false);
	        updateCustomQuery(props.componentId, this.setCustomQuery, props, value);
	      }
	      this.updateQueryHandler({
	        componentId: props.componentId,
	        query: query,
	        value: filterValue,
	        // sets a string in URL not array
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.toggleButton
	      });
	    },
	    handleClick: function handleClick(item) {
	      var _this$$props = this.$props,
	        enableStrictSelection = _this$$props.enableStrictSelection,
	        multiSelect = _this$$props.multiSelect;
	      if (enableStrictSelection && !multiSelect && this.$data.currentValue.find(function (stateItem) {
	        return isEqual$a(item, stateItem);
	      })) {
	        return false;
	      }
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.handleToggle(item);
	      } else {
	        this.$emit('change', item.value);
	      }
	      return true;
	    },
	    renderButton: function renderButton(item) {
	      var _this2 = this;
	      var h = this.$createElement;
	      var renderItem = this.$scopedSlots.renderItem || this.renderItem;
	      var isSelected = this.$data.currentValue.some(function (value) {
	        return value.value === item.value;
	      });
	      return renderItem ? renderItem({
	        item: item,
	        isSelected: isSelected,
	        handleClick: function handleClick() {
	          return _this2.handleClick(item);
	        }
	      }) : h(Button, {
	        "class": getClassName$a(this.$props.innerClass, 'button') + " " + (isSelected ? 'active' : ''),
	        "on": {
	          "click": function click() {
	            return _this2.handleClick(item);
	          },
	          "keypress": function keypress(e) {
	            return handleA11yAction$1(e, function () {
	              return _this2.handleClick(item);
	            });
	          }
	        },
	        "key": item.value,
	        "attrs": {
	          "primary": isSelected,
	          "large": true,
	          "tabIndex": isSelected ? '-1' : '0'
	        }
	      }, [item.label]);
	    }
	  },
	  render: function render() {
	    var _this3 = this;
	    var h = arguments[0];
	    return h(Container, {
	      "class": toggleButtons
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$a(this.$props.innerClass, 'title')
	    }, [this.$props.title]), this.$props.data.map(function (item) {
	      return _this3.renderButton(item);
	    })]);
	  }
	};
	ToggleButton.parseValue = function (value, props) {
	  if (Array.isArray(value)) {
	    if (typeof value[0] === 'string') {
	      return props.data.filter(function (item) {
	        return value.includes(item.value);
	      });
	    }
	    return value;
	  }
	  return props.data.filter(function (item) {
	    return item.value === value;
	  });
	};
	ToggleButton.defaultQuery = function (value, props) {
	  var query = null;
	  if (value && value.length) {
	    query = {
	      bool: {
	        boost: 1.0,
	        minimum_should_match: 1,
	        should: value.map(function (item) {
	          var _term;
	          return {
	            term: (_term = {}, _term[props.dataField] = item.value, _term)
	          };
	        })
	      }
	    };
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	var mapStateToProps$9 = function mapStateToProps(state, props) {
	  return {
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$6 = {
	  updateQueryHandler: updateQuery$7,
	  setQueryOptions: setQueryOptions$6,
	  setCustomQuery: setCustomQuery$6
	};
	var TBConnected = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$9, mapDispatchtoProps$6)(ToggleButton), {
	  componentType: constants_1$1.toggleButton
	}));
	TBConnected.parseValue = ToggleButton.parseValue;
	TBConnected.defaultQuery = ToggleButton.defaultQuery;
	TBConnected.name = ToggleButton.name;
	TBConnected.install = function (Vue) {
	  Vue.component(TBConnected.name, TBConnected);
	};
	// Add componentType for SSR
	TBConnected.componentType = constants_1$1.toggleButton;

	var _excluded = ["options"];
	var updateQuery$8 = lib_5.updateQuery,
	  setQueryOptions$7 = lib_5.setQueryOptions,
	  setCustomQuery$7 = lib_5.setCustomQuery,
	  setDefaultQuery$7 = lib_5.setDefaultQuery;
	var parseHits$1 = lib_8.parseHits,
	  isEqual$b = lib_8.isEqual,
	  getCompositeAggsQuery$5 = lib_8.getCompositeAggsQuery,
	  getResultStats$3 = lib_8.getResultStats,
	  extractQueryFromCustomQuery$6 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$6 = lib_8.getOptionsForCustomQuery;
	var ReactiveComponent = {
	  name: 'ReactiveComponent',
	  props: {
	    componentId: types.stringRequired,
	    aggregationField: types.string,
	    aggregationSize: VueTypes.number,
	    size: VueTypes.number,
	    defaultQuery: types.func,
	    customQuery: types.func,
	    filterLabel: types.string,
	    react: types.react,
	    showFilter: VueTypes.bool.def(true),
	    URLParams: VueTypes.bool.def(false),
	    distinctField: types.string,
	    distinctFieldConfig: types.props,
	    index: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  created: function created() {
	    var _this = this;
	    var props = this.$props;
	    this.internalComponent = null;
	    this.$defaultQuery = null;
	    // Set custom query in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.selectedValue);
	    var customQuery = props.customQuery,
	      componentId = props.componentId,
	      filterLabel = props.filterLabel,
	      showFilter = props.showFilter,
	      URLParams = props.URLParams,
	      distinctField = props.distinctField,
	      distinctFieldConfig = props.distinctFieldConfig,
	      index = props.index;
	    if (this.enableAppbase && this.aggregationField && this.aggregationField !== '') {
	      console.warn('Warning(ReactiveSearch): The `aggregationField` prop has been marked as deprecated, please use the `distinctField` prop instead.');
	    }
	    if (!this.enableAppbase && (distinctField || distinctFieldConfig)) {
	      console.warn('Warning(ReactiveSearch): In order to use the `distinctField` and `distinctFieldConfig` props, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    if (!this.enableAppbase && index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    if (customQuery) {
	      var calcCustomQuery = customQuery(this.selectedValue, props);
	      var query = extractQueryFromCustomQuery$6(calcCustomQuery);
	      var customQueryOptions = calcCustomQuery ? getOptionsForCustomQuery$6(calcCustomQuery) : null;
	      if (customQueryOptions) {
	        this.setQueryOptions(componentId, _extends({}, customQueryOptions, this.getAggsQuery()), false);
	      } else this.setQueryOptions(componentId, this.getAggsQuery(), false);
	      this.updateQuery({
	        componentId: componentId,
	        query: query,
	        value: this.selectedValue || null,
	        label: filterLabel,
	        showFilter: showFilter,
	        URLParams: URLParams
	      });
	    }
	    this.setQuery = function (_ref) {
	      var options = _ref.options,
	        obj = _objectWithoutPropertiesLoose(_ref, _excluded);
	      var queryToBeSet = obj.query;

	      // when enableAppbase is true, Backend throws error because of repeated query in request body
	      if (queryToBeSet && queryToBeSet.query) {
	        queryToBeSet = queryToBeSet.query;
	      }
	      var customQueryCalc = _extends({}, options, {
	        query: queryToBeSet
	      });
	      var rsAPIQuery = customQueryCalc;
	      // handle stored queries
	      if (queryToBeSet && queryToBeSet.id) {
	        rsAPIQuery = queryToBeSet;
	      }
	      // Update customQuery field for RS API
	      _this.setCustomQuery(props.componentId, rsAPIQuery);
	      if (options) {
	        _this.setQueryOptions(props.componentId, _extends({}, _this.getAggsQuery(), options), false);
	      }
	      _this.updateQuery(_extends({}, obj, {
	        query: customQueryCalc.query,
	        componentId: props.componentId,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams
	      }));
	    };
	    if (props.defaultQuery) {
	      this.internalComponent = props.componentId + "__internal";
	    }
	    if (this.internalComponent && this.$props.defaultQuery) {
	      updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.selectedValue);
	      this.$defaultQuery = this.$props.defaultQuery(this.selectedValue, this.$props);
	      var _query = extractQueryFromCustomQuery$6(this.$defaultQuery);
	      var queryOptions = getOptionsForCustomQuery$6(this.$defaultQuery);
	      if (queryOptions) {
	        this.setQueryOptions(this.internalComponent, _extends({}, queryOptions, this.getAggsQuery()), false);
	      } else this.setQueryOptions(this.internalComponent, this.getAggsQuery(), false);
	      this.updateQuery({
	        componentId: this.internalComponent,
	        query: _query
	      });
	    }
	  },
	  watch: {
	    hits: function hits(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    rawData: function rawData(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    aggregations: function aggregations(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    aggregationData: function aggregationData(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    promotedResults: function promotedResults(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    hidden: function hidden(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    total: function total(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    time: function time(newVal, oldVal) {
	      if (!isEqual$b(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      if (newVal && !isQueryIdentical(newVal, oldVal, this.selectedValue, this.$props)) {
	        this.$defaultQuery = newVal(this.selectedValue, this.$props);
	        var query = extractQueryFromCustomQuery$6(this.$defaultQuery);
	        var queryOptions = getOptionsForCustomQuery$6(this.$defaultQuery);
	        if (queryOptions) {
	          this.setQueryOptions(this.internalComponent, _extends({}, queryOptions, this.getAggsQuery()), false);
	        } else this.setQueryOptions(this.internalComponent, this.getAggsQuery(), false);
	        // Update default query for RS API
	        updateDefaultQuery(this.componentId, this.setDefaultQuery, this.$props, this.selectedValue);
	        this.updateQuery({
	          componentId: this.internalComponent,
	          query: query
	        });
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (newVal && !isQueryIdentical(newVal, oldVal, this.selectedValue, this.$props)) {
	        var componentId = this.$props.componentId;
	        this.$customQuery = newVal(this.selectedValue, this.$props);
	        var query = extractQueryFromCustomQuery$6(this.$customQuery);
	        var queryOptions = getOptionsForCustomQuery$6(this.$customQuery);
	        if (queryOptions) {
	          this.setQueryOptions(componentId, _extends({}, queryOptions, this.getAggsQuery()), false);
	        } else this.setQueryOptions(componentId, this.getAggsQuery(), false);

	        // Update custom query for RS API
	        updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.selectedValue);
	        this.updateQuery({
	          componentId: componentId,
	          query: query
	        });
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    try {
	      var dom = this.$scopedSlots["default"];
	      var error = this.error,
	        isLoading = this.isLoading,
	        selectedValue = this.selectedValue;
	      var propsToBePassed = _extends({
	        error: error,
	        loading: isLoading
	      }, this.getData(), {
	        value: selectedValue,
	        setQuery: this.setQuery
	      });
	      return h("div", [dom(propsToBePassed)]);
	    } catch (e) {
	      return null;
	    }
	  },
	  methods: {
	    getAggsQuery: function getAggsQuery() {
	      if (this.aggregationField) {
	        return {
	          aggs: getCompositeAggsQuery$5({
	            props: this.$props,
	            showTopHits: true,
	            value: this.selectedValue
	          }).aggs
	        };
	      }
	      return {};
	    },
	    getData: function getData() {
	      var hits = this.hits,
	        aggregations = this.aggregations,
	        aggregationData = this.aggregationData,
	        promotedResults = this.promotedResults,
	        rawData = this.rawData;
	      var filteredResults = parseHits$1(hits);
	      if (promotedResults.length) {
	        var ids = promotedResults.map(function (item) {
	          return item._id;
	        }).filter(Boolean);
	        if (ids) {
	          filteredResults = filteredResults.filter(function (item) {
	            return !ids.includes(item._id);
	          });
	        }
	        filteredResults = [].concat(promotedResults, filteredResults);
	      }
	      return {
	        data: filteredResults,
	        aggregationData: aggregationData,
	        rawData: rawData,
	        aggregations: aggregations,
	        promotedData: promotedResults,
	        resultStats: this.stats
	      };
	    }
	  },
	  computed: {
	    stats: function stats() {
	      return getResultStats$3(this);
	    }
	  }
	};
	ReactiveComponent.hasInternalComponent = function (props) {
	  return !!props.defaultQuery;
	};
	var mapStateToProps$a = function mapStateToProps(state, props) {
	  return {
	    aggregations: state.aggregations[props.componentId] && state.aggregations[props.componentId] || null,
	    aggregationData: state.compositeAggregations[props.componentId] || [],
	    hits: state.hits[props.componentId] && state.hits[props.componentId].hits || [],
	    rawData: state.rawData[props.componentId],
	    error: state.error[props.componentId],
	    isLoading: state.isLoading[props.componentId],
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    promotedResults: state.promotedResults[props.componentId] || [],
	    time: state.hits[props.componentId] && state.hits[props.componentId].time || 0,
	    total: state.hits[props.componentId] && state.hits[props.componentId].total,
	    hidden: state.hits[props.componentId] && state.hits[props.componentId].hidden,
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$7 = {
	  setQueryOptions: setQueryOptions$7,
	  updateQuery: updateQuery$8,
	  setCustomQuery: setCustomQuery$7,
	  setDefaultQuery: setDefaultQuery$7
	};
	var ConnectedComponent = ComponentWrapper$1(connect(mapStateToProps$a, mapDispatchtoProps$7)(ReactiveComponent), {
	  componentType: constants_1$1.reactiveComponent
	});
	var RcConnected = PreferencesConsumer({
	  name: 'RcConnected',
	  render: function render(h) {
	    return h(ConnectedComponent, {
	      attrs: this.$attrs,
	      on: this.$listeners,
	      scopedSlots: this.$scopedSlots,
	      slots: this.$slots
	    });
	  }
	});
	RcConnected.name = ReactiveComponent.name;
	RcConnected.hasInternalComponent = ReactiveComponent.hasInternalComponent;
	// Add componentType for SSR
	RcConnected.componentType = constants_1$1.reactiveComponent;
	RcConnected.install = function (Vue) {
	  Vue.component(RcConnected.name, RcConnected);
	};

	/*!
	 * vue-no-ssr v1.1.1
	 * (c) 2018-present egoist <0x142857@gmail.com>
	 * Released under the MIT License.
	 */

	var index$3 = {
	  name: 'NoSsr',
	  functional: true,
	  props: {
	    placeholder: String,
	    placeholderTag: {
	      type: String,
	      "default": 'div'
	    }
	  },
	  render: function render(h, ref) {
	    var parent = ref.parent;
	    var slots = ref.slots;
	    var props = ref.props;
	    var ref$1 = slots();
	    var defaultSlot = ref$1["default"];
	    if (defaultSlot === void 0) defaultSlot = [];
	    var placeholderSlot = ref$1.placeholder;
	    if (parent._isMounted) {
	      return defaultSlot;
	    }
	    parent.$once('hook:mounted', function () {
	      parent.$forceUpdate();
	    });
	    if (props.placeholderTag && (props.placeholder || placeholderSlot)) {
	      return h(props.placeholderTag, {
	        "class": ['no-ssr-placeholder']
	      }, props.placeholder || placeholderSlot);
	    }

	    // Return a placeholder element for each child in the default slot
	    // Or if no children return a single placeholder
	    return defaultSlot.length > 0 ? defaultSlot.map(function () {
	      return h(false);
	    }) : h(false);
	  }
	};
	var vueNoSsr_common = index$3;

	var _templateObject$o;
	var Slider = index$1('div')(_templateObject$o || (_templateObject$o = _taggedTemplateLiteralLoose(["\n\tmargin-top: 30px;\n\tpadding: 10px;\n\n\t/* component style */\n\t.vue-slider-disabled {\n\t\topacity: 0.5;\n\t\tcursor: not-allowed;\n\t}\n\n\t/* rail style */\n\t.vue-slider-rail {\n\t\tbackground-color: #ccc;\n\t\tborder-radius: 15px;\n\t\theight: 4px;\n\t}\n\n\t/* process style */\n\t.vue-slider-process {\n\t\tbackground-color: #0b6aff;\n\t\tborder-radius: 15px;\n\t}\n\n\t/* mark style */\n\t.vue-slider-mark {\n\t\tz-index: 4;\n\t}\n\n\t.vue-slider-mark:first-child .vue-slider-mark-step,\n\t.vue-slider-mark:last-child .vue-slider-mark-step {\n\t\tdisplay: none;\n\t}\n\n\t.vue-slider-mark-step {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tborder-radius: 50%;\n\t\tbackground-color: rgba(0, 0, 0, 0.16);\n\t}\n\n\t.vue-slider-mark-label {\n\t\tfont-size: 14px;\n\t\twhite-space: nowrap;\n\t}\n\n\t/* dot style */\n\t.vue-slider-dot {\n\t\tz-index: 2;\n\t}\n\n\t.vue-slider-dot-handle {\n\t\tcursor: pointer;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tborder-radius: 50%;\n\t\tbackground-color: #fff;\n\t\tbox-sizing: border-box;\n\t\tborder: 1px solid #9a9a9a;\n\t\tz-index: 2;\n\t\tbox-shadow: 0.5px 0.5px 2px 1px rgb(0 0 0 / 32%);\n\t}\n\n\t.vue-slider-dot-handle-disabled {\n\t\tcursor: not-allowed;\n\t\tbackground-color: #ccc;\n\t}\n\n\t.vue-slider-dot-tooltip-inner {\n\t\tfont-size: 14px;\n\t\twhite-space: nowrap;\n\t\tpadding: 2px 5px;\n\t\tmin-width: 20px;\n\t\ttext-align: center;\n\t\tcolor: #fff;\n\t\tborder-radius: 5px;\n\t\tborder: 1px solid #3498db;\n\t\tbackground-color: #3498db;\n\t\tbox-sizing: content-box;\n\t}\n\n\t.vue-slider-dot-tooltip-inner::after {\n\t\tcontent: '';\n\t\tposition: absolute;\n\t}\n\n\t.vue-slider-dot-tooltip-inner-top::after {\n\t\ttop: 100%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, 0);\n\t\theight: 0;\n\t\twidth: 0;\n\t\tborder-color: transparent;\n\t\tborder-style: solid;\n\t\tborder-width: 5px;\n\t\tborder-top-color: inherit;\n\t}\n\n\t.vue-slider-dot-tooltip-inner-bottom::after {\n\t\tbottom: 100%;\n\t\tleft: 50%;\n\t\ttransform: translate(-50%, 0);\n\t\theight: 0;\n\t\twidth: 0;\n\t\tborder-color: transparent;\n\t\tborder-style: solid;\n\t\tborder-width: 5px;\n\t\tborder-bottom-color: inherit;\n\t}\n\n\t.vue-slider-dot-tooltip-inner-left::after {\n\t\tleft: 100%;\n\t\ttop: 50%;\n\t\ttransform: translate(0, -50%);\n\t\theight: 0;\n\t\twidth: 0;\n\t\tborder-color: transparent;\n\t\tborder-style: solid;\n\t\tborder-width: 5px;\n\t\tborder-left-color: inherit;\n\t}\n\n\t.vue-slider-dot-tooltip-inner-right::after {\n\t\tright: 100%;\n\t\ttop: 50%;\n\t\ttransform: translate(0, -50%);\n\t\theight: 0;\n\t\twidth: 0;\n\t\tborder-color: transparent;\n\t\tborder-style: solid;\n\t\tborder-width: 5px;\n\t\tborder-right-color: inherit;\n\t}\n\n\t.vue-slider-dot-tooltip-wrapper {\n\t\topacity: 0;\n\t\ttransition: all 0.3s;\n\t}\n\t.vue-slider-dot-tooltip-wrapper-show {\n\t\topacity: 1;\n\t}\n\n\t.label-container {\n\t\tmargin: 10px 0;\n\t\twidth: 100%;\n\t}\n\n\t.range-label-right {\n\t\tfloat: right;\n\t}\n"])));

	/**
	 * Caution: Please do not change this file without having a discussion with the Team.
	 * Any change may break the umd build, we're directly replacing the line no: 14
	 * `
						var s = document.createElement("script");
						s.setAttribute("src","https://cdn.jsdelivr.net/npm/vue-slider-component@3.2.15/dist/vue-slider-component.umd.min.js");
						s.onload = function(){
							var VueSlider = global['vue-slider-component'];
							components['vue-slider-component'] = VueSlider;
						}
						document.head.appendChild(s);
					` in rollup umd build process with some script.
	 */
	// eslint-disable-next-line
	var getComponents = function getComponents() {
	  var components = {
	    NoSSR: vueNoSsr_common
	  };
	  {
	    try {
	      // in older versions of nuxt, it's process.BROWSER_BUILD
	      // eslint-disable-next-line
	      
						var s = document.createElement("script");
						s.setAttribute("src","https://cdn.jsdelivr.net/npm/vue-slider-component@3.2.15/dist/vue-slider-component.umd.min.js");
						s.onload = function(){
							var VueSlider = global$1['vue-slider-component'];
							components['vue-slider-component'] = VueSlider;
						};
						document.head.appendChild(s);
					
	    } catch (e) {
	      console.error('Unable to load vue-slider', e);
	    }
	  }
	  return components;
	};

	var addComponent$1 = lib_5.addComponent,
	  removeComponent$1 = lib_5.removeComponent,
	  watchComponent$1 = lib_5.watchComponent,
	  updateQuery$9 = lib_5.updateQuery,
	  setQueryListener$1 = lib_5.setQueryListener,
	  setQueryOptions$8 = lib_5.setQueryOptions,
	  setComponentProps$1 = lib_5.setComponentProps,
	  setCustomQuery$8 = lib_5.setCustomQuery,
	  updateComponentProps$2 = lib_5.updateComponentProps;
	var checkValueChange$7 = lib_8.checkValueChange,
	  getClassName$b = lib_8.getClassName,
	  isEqual$c = lib_8.isEqual,
	  checkSomePropChange$1 = lib_8.checkSomePropChange,
	  extractQueryFromCustomQuery$7 = lib_8.extractQueryFromCustomQuery,
	  getOptionsForCustomQuery$7 = lib_8.getOptionsForCustomQuery;
	var DynamicRangeSlider = {
	  name: 'DynamicRangeSlider',
	  components: getComponents(),
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    rangeLabels: types.func,
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    data: types.data,
	    dataField: types.stringRequired,
	    defaultValue: types.func,
	    filterLabel: types.string,
	    innerClass: types.style,
	    react: types.react,
	    showFilter: VueTypes.bool.def(true),
	    destroyOnUnmount: VueTypes.bool,
	    showCheckbox: VueTypes.bool.def(true),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    sliderOptions: VueTypes.object.def({}),
	    nestedField: types.string,
	    index: VueTypes.string,
	    value: types.range,
	    endpoint: types.endpointConfig
	  },
	  data: function data() {
	    this.internalRangeComponent = this.$props.componentId + "__range__internal";
	    return {
	      currentValue: null,
	      stats: []
	    };
	  },
	  created: function created() {
	    var _this = this;
	    this.$timestamp = new Date().getTime();
	    var onQueryChange = function onQueryChange() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      _this.$emit.apply(_this, ['queryChange'].concat(args));
	      _this.$emit.apply(_this, ['query-change'].concat(args));
	    };
	    this.setQueryListener(this.$props.componentId, onQueryChange, null);
	    // Update props in store
	    this.setComponentProps(this.componentId, this.$props, constants_1$1.dynamicRangeSlider);
	    this.setComponentProps(this.internalRangeComponent, this.$props, constants_1$1.dynamicRangeSlider);
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    // Set custom query in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	  },
	  mounted: function mounted() {
	    this.setReact();
	  },
	  beforeMount: function beforeMount() {
	    var components = [];
	    if (this.$$store) {
	      var _this$$$store$getStat = this.$$store.getState();
	      components = _this$$$store$getStat.components;
	    }
	    var value = this.$props.value;
	    if (this.destroyOnUnmount || components.indexOf(this.componentId) === -1) {
	      this.addComponent(this.componentId, this.$timestamp);
	      this.addComponent(this.internalRangeComponent, this.$timestamp);
	      if (Array.isArray(this.selectedValue)) {
	        this.handleChange(this.selectedValue);
	      } else if (this.selectedValue) {
	        this.handleChange(DynamicRangeSlider.parseValue(this.selectedValue, this.$props));
	      } else if (value) {
	        this.handleChange(DynamicRangeSlider.parseValue(value, this.$props));
	      }

	      // get range before executing other queries
	      this.updateRangeQueryOptions();
	    }
	  },
	  beforeUpdate: function beforeUpdate() {
	    if (!this.currentValue) {
	      this.setDefaultValue(this.range);
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.destroyOnUnmount) {
	      this.removeComponent(this.$props.componentId);
	      this.removeComponent(this.internalRangeComponent);
	    }
	  },
	  methods: {
	    isControlled: function isControlled() {
	      if (this.$props.value && this.$listeners) {
	        return true;
	      }
	      return false;
	    },
	    setDefaultValue: function setDefaultValue(_ref) {
	      var start = _ref.start,
	        end = _ref.end;
	      if (this.$props.defaultValue) {
	        var _this$$props$defaultV = this.$props.defaultValue(start, end),
	          defaultStart = _this$$props$defaultV.start,
	          defaultEnd = _this$$props$defaultV.end;
	        this.handleChange([defaultStart, defaultEnd]);
	      } else if (this.isControlled()) {
	        this.handleChange(DynamicRangeSlider.parseValue(this.$props.value), 'change');
	      } else {
	        this.currentValue = [start, end];
	      }
	    },
	    setReact: function setReact() {
	      if (this.$props.react) {
	        this.watchComponent(this.internalRangeComponent, this.$props.react);
	        this.watchComponent(this.$props.componentId, this.$props.react);
	      } else {
	        this.watchComponent(this.internalRangeComponent, {});
	        this.watchComponent(this.$props.componentId, {});
	      }
	    },
	    rangeQuery: function rangeQuery() {
	      return {
	        min: {
	          min: {
	            field: this.$props.dataField
	          }
	        },
	        max: {
	          max: {
	            field: this.$props.dataField
	          }
	        }
	      };
	    },
	    updateRangeQueryOptions: function updateRangeQueryOptions() {
	      var aggs = {};
	      if (this.$props.nestedField) {
	        var _aggs;
	        aggs = (_aggs = {}, _aggs[this.$props.nestedField] = {
	          nested: {
	            path: this.$props.nestedField
	          },
	          aggs: this.rangeQuery()
	        }, _aggs);
	      } else {
	        aggs = this.rangeQuery();
	      }
	      this.setQueryOptions(this.internalRangeComponent, {
	        aggs: aggs
	      });
	    },
	    handleSlider: function handleSlider() {
	      var sliderValues = this.$refs.slider.getValue();
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.handleChange(sliderValues);
	      } else {
	        this.$emit('change', {
	          start: sliderValues[0],
	          end: sliderValues[1]
	        });
	      }
	    },
	    handleChange: function handleChange(currentValue) {
	      var _this2 = this;
	      // Always keep the values within range
	      var normalizedValue = [this.range ? Math.max(this.range.start, currentValue[0]) : currentValue[0], this.range ? Math.min(this.range.end, currentValue[1]) : currentValue[1]];
	      var performUpdate = function performUpdate() {
	        _this2.currentValue = normalizedValue;
	        _this2.updateQueryHandler(normalizedValue, _this2.$props);
	        _this2.$emit('valueChange', {
	          start: normalizedValue[0],
	          end: normalizedValue[1]
	        });
	        _this2.$emit('value-change', {
	          start: normalizedValue[0],
	          end: normalizedValue[1]
	        });
	      };
	      checkValueChange$7(this.$props.componentId, {
	        start: normalizedValue[0],
	        end: normalizedValue[1]
	      }, this.$props.beforeValueChange, performUpdate);
	    },
	    updateQueryHandler: function updateQueryHandler(value) {
	      var query = DynamicRangeSlider.defaultQuery(value, this.$props);
	      if (this.$props.customQuery) {
	        var customQueryTobeSet = this.$props.customQuery(value, this.$props);
	        var queryTobeSet = extractQueryFromCustomQuery$7(customQueryTobeSet);
	        if (queryTobeSet) {
	          query = queryTobeSet;
	        }
	        var customQueryOptions = getOptionsForCustomQuery$7(customQueryTobeSet);
	        updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, value);
	        this.setQueryOptions(this.$props.componentId, customQueryOptions, false);
	      }
	      var _ref2 = this.range || {
	          start: value[0],
	          end: value[1]
	        },
	        start = _ref2.start,
	        end = _ref2.end;
	      var currentStart = value[0],
	        currentEnd = value[1];
	      // check if the slider is at its initial position
	      var isInitialValue = currentStart === start && currentEnd === end;
	      this.updateQuery({
	        componentId: this.$props.componentId,
	        query: query,
	        value: value,
	        label: this.$props.filterLabel,
	        showFilter: this.$props.showFilter && !isInitialValue,
	        URLParams: this.$props.URLParams,
	        componentType: constants_1$1.dynamicRangeSlider
	      });
	    }
	  },
	  computed: {
	    labels: function labels() {
	      if (!this.rangeLabels) return null;
	      return this.rangeLabels(this.range.start, this.range.end);
	    }
	  },
	  watch: {
	    $props: {
	      deep: true,
	      handler: function handler(newVal) {
	        var _this3 = this;
	        var propsKeys = getValidPropsKeys(newVal);
	        checkSomePropChange$1(newVal, this.componentProps, propsKeys, function () {
	          _this3.updateComponentProps(_this3.componentId, newVal, constants_1$1.dynamicRangeSlider);
	          _this3.updateComponentProps(_this3.internalRangeComponent, newVal, constants_1$1.dynamicRangeSlider);
	        });
	      }
	    },
	    react: function react() {
	      this.setReact();
	    },
	    selectedValue: function selectedValue(newValue) {
	      if (isEqual$c(newValue, this.currentValue)) return;
	      var value = newValue || {
	        start: this.range.start,
	        end: this.range.end
	      };
	      this.$emit('change', value);
	      this.handleChange(DynamicRangeSlider.parseValue(value, this.$props));
	    },
	    range: function range(newValue, oldValue) {
	      if (isEqual$c(newValue, oldValue) || !this.currentValue) return;
	      var _ref3 = this.currentValue || [],
	        currentStart = _ref3[0],
	        currentEnd = _ref3[1];
	      var _ref4 = oldValue || {},
	        oldStart = _ref4.start,
	        oldEnd = _ref4.end;
	      var newStart = currentStart === oldStart ? newValue.start : currentStart;
	      var newEnd = currentEnd === oldEnd ? newValue.end : currentEnd;
	      this.handleChange([newStart, newEnd]);
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.$data.currentValue);
	      }
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$c(newVal, oldVal)) {
	        this.handleChange(DynamicRangeSlider.parseValue(newVal, this.$props));
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    if (!this.range || !this.currentValue) {
	      return null;
	    }
	    var _this$range = this.range,
	      start = _this$range.start,
	      end = _this$range.end;
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$b(this.$props.innerClass, 'title')
	    }, [this.$props.title]), h(vueNoSsr_common, [h(Slider, {
	      "class": getClassName$b(this.$props.innerClass, 'slider')
	    }, [h("vue-slider-component", {
	      "ref": "slider",
	      "attrs": {
	        "value": [Math.floor(Math.max(start, this.currentValue[0])), Math.ceil(Math.min(end, this.currentValue[1]))],
	        "min": Math.floor(Math.min(start, this.currentValue[0])),
	        "max": Math.ceil(Math.max(end, this.currentValue[1])),
	        "dotSize": 20,
	        "height": 4,
	        "enable-cross": false,
	        "tooltip": "always"
	      },
	      "on": {
	        "drag-end": this.handleSlider
	      },
	      "props": _extends({}, this.$props.sliderOptions)
	    }), this.labels ? h("div", {
	      "class": "label-container"
	    }, [h("label", {
	      "class": getClassName$b(this.$props.innerClass, 'label') || 'range-label-left'
	    }, [this.labels.start]), h("label", {
	      "class": getClassName$b(this.$props.innerClass, 'label') || 'range-label-right'
	    }, [this.labels.end])]) : null])])]);
	  }
	};
	DynamicRangeSlider.defaultQuery = function (values, props) {
	  var query = null;
	  if (Array.isArray(values) && values.length) {
	    var _range;
	    query = {
	      range: (_range = {}, _range[props.dataField] = {
	        gte: values[0],
	        lte: values[1],
	        boost: 2.0
	      }, _range)
	    };
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	DynamicRangeSlider.parseValue = function (value) {
	  if (value) {
	    return Array.isArray(value) ? value : [value.start, value.end];
	  }
	  return [];
	};
	DynamicRangeSlider.hasInternalComponent = function () {
	  return true;
	};
	var mapStateToProps$b = function mapStateToProps(state, props) {
	  var componentId = state.aggregations[props.componentId];
	  var internalRange = state.aggregations[props.componentId + "__range__internal"];
	  var options = componentId && componentId[props.dataField];
	  var range = state.aggregations[props.componentId + "__range__internal"];
	  if (props.nestedField) {
	    options = options && componentId[props.dataField][props.nestedField] && componentId[props.dataField][props.nestedField].buckets ? componentId[props.dataField][props.nestedField].buckets : [];
	    range = range && internalRange[props.nestedField].min ? {
	      start: internalRange[props.nestedField].min.value,
	      end: internalRange[props.nestedField].max.value
	    } : null;
	  } else {
	    options = options && componentId[props.dataField].buckets ? componentId[props.dataField].buckets : [];
	    range = range && internalRange.min ? {
	      start: internalRange.min.value,
	      end: internalRange.max.value
	    } : null;
	  }
	  return {
	    options: options,
	    range: range,
	    selectedValue: state.selectedValues[props.componentId] ? state.selectedValues[props.componentId].value : null,
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$8 = {
	  addComponent: addComponent$1,
	  removeComponent: removeComponent$1,
	  updateQuery: updateQuery$9,
	  watchComponent: watchComponent$1,
	  setQueryListener: setQueryListener$1,
	  setQueryOptions: setQueryOptions$8,
	  setComponentProps: setComponentProps$1,
	  setCustomQuery: setCustomQuery$8,
	  updateComponentProps: updateComponentProps$2
	};
	var RangeConnected = PreferencesConsumer(connect(mapStateToProps$b, mapDispatchtoProps$8)(DynamicRangeSlider));
	RangeConnected.defaultQuery = DynamicRangeSlider.defaultQuery;
	RangeConnected.parseValue = DynamicRangeSlider.parseValue;
	RangeConnected.hasInternalComponent = DynamicRangeSlider.hasInternalComponent;
	RangeConnected.name = DynamicRangeSlider.name;

	// Add componentType for SSR
	RangeConnected.componentType = constants_1$1.dynamicRangeSlider;
	RangeConnected.install = function (Vue) {
	  Vue.component(RangeConnected.name, RangeConnected);
	};

	var updateQuery$a = lib_5.updateQuery,
	  setQueryOptions$9 = lib_5.setQueryOptions,
	  setCustomQuery$9 = lib_5.setCustomQuery;
	var isEqual$d = lib_8.isEqual,
	  checkValueChange$8 = lib_8.checkValueChange,
	  getClassName$c = lib_8.getClassName,
	  getOptionsFromQuery$1 = lib_8.getOptionsFromQuery;
	var SingleRange = {
	  name: 'SingleRange',
	  data: function data() {
	    this.__state = {
	      currentValue: null
	    };
	    this.type = 'range';
	    return this.__state;
	  },
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    data: types.data,
	    dataField: types.stringRequired,
	    defaultValue: types.string,
	    value: types.value,
	    filterLabel: types.string,
	    innerClass: types.style,
	    react: types.react,
	    showFilter: VueTypes.bool.def(true),
	    showRadio: VueTypes.bool.def(true),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    nestedField: types.string,
	    index: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    // Set custom query in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    if (this.selectedValue) {
	      this.setValue(this.selectedValue);
	    } else if (this.$props.value) {
	      this.setValue(this.$props.value);
	    } else if (this.$props.defaultValue) {
	      this.setValue(this.$props.defaultValue);
	    }
	  },
	  watch: {
	    dataField: function dataField() {
	      this.updateQueryHandler(this.$data.currentValue, this.$props);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.setValue(newVal);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$d(newVal, oldVal)) {
	        this.setValue(newVal);
	      }
	    },
	    selectedValue: function selectedValue(newVal) {
	      if (!isEqual$d(this.$data.currentValue, newVal)) {
	        this.setValue(newVal);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  render: function render() {
	    var _this = this;
	    var h = arguments[0];
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$c(this.$props.innerClass, 'title')
	    }, [this.$props.title]), h(UL, {
	      "class": getClassName$c(this.$props.innerClass, 'list')
	    }, [this.$props.data.map(function (item) {
	      var selected = !!_this.$data.currentValue && _this.$data.currentValue.label === item.label;
	      return h("li", {
	        "key": item.label,
	        "class": "" + (selected ? 'active' : '')
	      }, [h(Radio, {
	        "class": getClassName$c(_this.$props.innerClass, 'radio'),
	        "attrs": {
	          "id": _this.$props.componentId + "-" + item.label,
	          "name": _this.$props.componentId,
	          "value": item.label,
	          "type": "radio",
	          "checked": selected,
	          "show": _this.$props.showRadio
	        },
	        "on": {
	          "change": _this.handleChange
	        }
	      }), h("label", {
	        "class": getClassName$c(_this.$props.innerClass, 'label'),
	        "attrs": {
	          "for": _this.$props.componentId + "-" + item.label
	        }
	      }, [item.label])]);
	    })])]);
	  },
	  methods: {
	    setValue: function setValue(value, props) {
	      var _this2 = this;
	      if (props === void 0) {
	        props = this.$props;
	      }
	      var currentValue = typeof value === 'string' ? SingleRange.parseValue(value, props) : value;
	      var performUpdate = function performUpdate() {
	        _this2.currentValue = currentValue;
	        _this2.updateQueryHandler(currentValue, props);
	        _this2.$emit('valueChange', currentValue);
	        _this2.$emit('value-change', currentValue);
	      };
	      checkValueChange$8(props.componentId, currentValue, props.beforeValueChange, performUpdate);
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = SingleRange.defaultQuery(value, props);
	      if (customQuery) {
	        var _ref = customQuery(value, props) || {};
	        query = _ref.query;
	        var customQueryOptions = getOptionsFromQuery$1(customQuery(value, props));
	        updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.singleRange
	      });
	    },
	    handleChange: function handleChange(e) {
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.setValue(e.target.value);
	      } else {
	        this.$emit('change', e.target.value);
	      }
	    }
	  }
	};
	SingleRange.parseValue = function (value, props) {
	  return props.data.find(function (item) {
	    return item.label === value;
	  }) || null;
	};
	SingleRange.defaultQuery = function (value, props) {
	  var query = null;
	  if (value) {
	    var _range;
	    query = {
	      range: (_range = {}, _range[props.dataField] = {
	        gte: value.start,
	        lte: value.end,
	        boost: 2.0
	      }, _range)
	    };
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	var mapStateToProps$c = function mapStateToProps(state, props) {
	  return {
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$9 = {
	  updateQuery: updateQuery$a,
	  setQueryOptions: setQueryOptions$9,
	  setCustomQuery: setCustomQuery$9
	};
	var RangeConnected$1 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$c, mapDispatchtoProps$9)(SingleRange), {
	  componentType: constants_1$1.singleRange
	}));
	RangeConnected$1.name = SingleRange.name;
	RangeConnected$1.defaultQuery = SingleRange.defaultQuery;
	RangeConnected$1.parseValue = SingleRange.parseValue;
	RangeConnected$1.hasInternalComponent = SingleRange.hasInternalComponent;
	RangeConnected$1.install = function (Vue) {
	  Vue.component(RangeConnected$1.name, RangeConnected$1);
	};
	// Add componentType for SSR
	RangeConnected$1.componentType = constants_1$1.singleRange;

	var updateQuery$b = lib_5.updateQuery,
	  setQueryOptions$a = lib_5.setQueryOptions,
	  setCustomQuery$a = lib_5.setCustomQuery;
	var isEqual$e = lib_8.isEqual,
	  checkValueChange$9 = lib_8.checkValueChange,
	  getClassName$d = lib_8.getClassName,
	  getOptionsFromQuery$2 = lib_8.getOptionsFromQuery;
	var MultiRange = {
	  name: 'MultiRange',
	  data: function data() {
	    this.state = {
	      currentValue: [],
	      showModal: false,
	      selectedValues: {}
	    };
	    this.type = 'range';
	    return this.state;
	  },
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    data: types.data,
	    dataField: types.stringRequired,
	    defaultValue: types.stringArray,
	    value: types.stringArray,
	    filterLabel: types.string,
	    innerClass: types.style,
	    react: types.react,
	    showFilter: VueTypes.bool.def(true),
	    showCheckbox: VueTypes.bool.def(true),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    nestedField: types.string,
	    index: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  methods: {
	    handleClick: function handleClick(e) {
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.selectItem(e.target.value);
	      } else {
	        var values = parseValueArray(this.selectedValues, e.target.value);
	        this.$emit('change', values);
	      }
	    },
	    selectItem: function selectItem(item, isDefaultValue, props, reset) {
	      var _this = this;
	      if (isDefaultValue === void 0) {
	        isDefaultValue = false;
	      }
	      if (props === void 0) {
	        props = this.$props;
	      }
	      if (reset === void 0) {
	        reset = false;
	      }
	      var currentValue = this.currentValue,
	        selectedValues = this.selectedValues;
	      if (!item) {
	        currentValue = [];
	        selectedValues = {};
	      } else if (isDefaultValue) {
	        currentValue = MultiRange.parseValue(item, props);
	        var values = {};
	        currentValue.forEach(function (value) {
	          values[[value.label]] = true;
	        });
	        if (reset) {
	          selectedValues = values;
	        } else {
	          selectedValues = _extends({}, selectedValues, values);
	        }
	      } else if (selectedValues[item]) {
	        currentValue = currentValue.filter(function (value) {
	          return value.label !== item;
	        });
	        var _selectedValues = selectedValues,
	          del = _selectedValues[item],
	          selected = _objectWithoutPropertiesLoose(_selectedValues, [item].map(_toPropertyKey));
	        selectedValues = selected;
	      } else {
	        var _extends2;
	        var currentItems = props.data.filter(function (value) {
	          return item.indexOf(value.label) !== -1;
	        });
	        currentValue = [].concat(currentValue, currentItems);
	        selectedValues = _extends({}, selectedValues, (_extends2 = {}, _extends2[typeof item === 'object' ? item.label : item] = true, _extends2));
	      }
	      var performUpdate = function performUpdate() {
	        _this.currentValue = currentValue;
	        _this.selectedValues = selectedValues;
	        _this.updateQueryHandler(currentValue, props);
	        _this.$emit('valueChange', Object.keys(selectedValues));
	        _this.$emit('value-change', Object.keys(selectedValues));
	      };
	      checkValueChange$9(props.componentId, currentValue, props.beforeValueChange, performUpdate);
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = MultiRange.defaultQuery(value, props);
	      if (customQuery) {
	        var _ref = customQuery(value, props) || {};
	        query = _ref.query;
	        var customQueryOptions = getOptionsFromQuery$2(customQuery(value, props));
	        updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: props.showFilter,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.multiRange
	      });
	    }
	  },
	  watch: {
	    dataField: function dataField() {
	      this.updateQueryHandler(this.$data.currentValue, this.$props);
	    },
	    defaultValue: function defaultValue(newVal) {
	      this.selectItem(newVal, true, undefined, true);
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$e(newVal, oldVal)) {
	        this.selectItem(newVal, true, undefined, true);
	      }
	    },
	    selectedValue: function selectedValue(newVal) {
	      if (!isEqual$e(this.$data.currentValue, newVal)) {
	        var processSelectedValues = newVal ? newVal.map(function (item) {
	          if (typeof item === 'object' && 'label' in item) {
	            return item.label;
	          }
	          return item;
	        }) : null;
	        this.selectItem(processSelectedValues, true, undefined, true);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  created: function created() {
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    // Set custom query in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    if (this.selectedValue) {
	      this.selectItem(this.selectedValue, true);
	    } else if (this.$props.value) {
	      this.selectItem(this.$props.value, true);
	    } else if (this.$props.defaultValue) {
	      this.selectItem(this.$props.defaultValue, true);
	    }
	  },
	  render: function render() {
	    var _this2 = this;
	    var h = arguments[0];
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$d(this.$props.innerClass, 'title')
	    }, [this.$props.title]), h(UL, {
	      "class": getClassName$d(this.$props.innerClass, 'list')
	    }, [this.$props.data.map(function (item) {
	      var selected = !!_this2.$data.currentValue && _this2.$data.currentValue.label === item.label;
	      return h("li", {
	        "key": item.label,
	        "class": "" + (selected ? 'active' : '')
	      }, [h(Checkbox, {
	        "class": getClassName$d(_this2.$props.innerClass, 'checkbox'),
	        "attrs": {
	          "id": _this2.$props.componentId + "-" + item.label,
	          "name": _this2.$props.componentId,
	          "value": item.label,
	          "type": "Checkbox",
	          "show": _this2.$props.showCheckbox
	        },
	        "domProps": _extends({}, {
	          checked: _this2.selectedValues[item.label]
	        }),
	        "on": _extends({}, {
	          click: _this2.handleClick
	        })
	      }), h("label", {
	        "class": getClassName$d(_this2.$props.innerClass, 'label'),
	        "attrs": {
	          "for": _this2.$props.componentId + "-" + item.label
	        }
	      }, [item.label])]);
	    })])]);
	  }
	};
	MultiRange.parseValue = function (value, props) {
	  return value ? props.data.filter(function (item) {
	    return value.includes(item.label);
	  }) : null;
	};
	MultiRange.defaultQuery = function (values, props) {
	  var generateRangeQuery = function generateRangeQuery(dataField, items) {
	    if (items.length > 0) {
	      return items.map(function (value) {
	        var _range;
	        return {
	          range: (_range = {}, _range[dataField] = {
	            gte: value.start,
	            lte: value.end,
	            boost: 2.0
	          }, _range)
	        };
	      });
	    }
	    return null;
	  };
	  var query = null;
	  if (values && values.length) {
	    query = {
	      bool: {
	        should: generateRangeQuery(props.dataField, values),
	        minimum_should_match: 1,
	        boost: 1.0
	      }
	    };
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	var mapStateToProps$d = function mapStateToProps(state, props) {
	  return {
	    selectedValue: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value || null,
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$a = {
	  updateQuery: updateQuery$b,
	  setQueryOptions: setQueryOptions$a,
	  setCustomQuery: setCustomQuery$a
	};
	var RangeConnected$2 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$d, mapDispatchtoProps$a)(MultiRange), {
	  componentType: constants_1$1.multiRange
	}));
	RangeConnected$2.name = MultiRange.name;
	RangeConnected$2.defaultQuery = MultiRange.defaultQuery;
	RangeConnected$2.parseValue = MultiRange.parseValue;
	RangeConnected$2.hasInternalComponent = MultiRange.hasInternalComponent;
	RangeConnected$2.install = function (Vue) {
	  Vue.component(RangeConnected$2.name, RangeConnected$2);
	};
	// Add componentType for SSR
	RangeConnected$2.componentType = constants_1$1.multiRange;

	var updateQuery$c = lib_5.updateQuery,
	  setQueryOptions$b = lib_5.setQueryOptions,
	  setCustomQuery$b = lib_5.setCustomQuery;
	var checkValueChange$a = lib_8.checkValueChange,
	  getClassName$e = lib_8.getClassName,
	  getOptionsFromQuery$3 = lib_8.getOptionsFromQuery,
	  isEqual$f = lib_8.isEqual;
	var RangeSlider = {
	  name: 'RangeSlider',
	  components: getComponents(),
	  inject: {
	    theme: {
	      from: 'theme_reactivesearch'
	    }
	  },
	  data: function data() {
	    var state = {
	      currentValue: this.$props.range ? [this.$props.range.start, this.$props.range.end] : [],
	      stats: []
	    };
	    return state;
	  },
	  props: {
	    beforeValueChange: types.func,
	    className: VueTypes.string.def(''),
	    range: VueTypes.shape({
	      start: VueTypes.integer.def(0),
	      end: VueTypes.integer.def(10)
	    }),
	    rangeLabels: types.rangeLabels,
	    componentId: types.stringRequired,
	    customQuery: types.func,
	    data: types.data,
	    dataField: types.stringRequired,
	    defaultValue: types.range,
	    value: types.range,
	    filterLabel: types.string,
	    innerClass: types.style,
	    react: types.react,
	    showFilter: VueTypes.bool.def(true),
	    showCheckbox: VueTypes.bool.def(true),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    sliderOptions: VueTypes.object.def({}),
	    nestedField: types.string,
	    index: VueTypes.string,
	    endpoint: types.endpointConfig
	  },
	  methods: {
	    handleSliderChange: function handleSliderChange(values) {
	      var value = this.$props.value;
	      if (value === undefined) {
	        this.handleChange(values);
	      } else {
	        this.$emit('change', {
	          start: values[0],
	          end: values[1]
	        });
	      }
	    },
	    handleSlider: function handleSlider() {
	      var sliderValues = this.$refs.slider.getValue();
	      this.handleSliderChange(sliderValues);
	    },
	    handleChange: function handleChange(currentValue, props) {
	      var _this = this;
	      if (props === void 0) {
	        props = this.$props;
	      }
	      var performUpdate = function performUpdate() {
	        _this.currentValue = currentValue;
	        _this.updateQueryHandler([currentValue[0], currentValue[1]], props);
	        _this.$emit('valueChange', {
	          start: currentValue[0],
	          end: currentValue[1]
	        });
	        _this.$emit('value-change', {
	          start: currentValue[0],
	          end: currentValue[1]
	        });
	      };
	      checkValueChange$a(props.componentId, {
	        start: currentValue[0],
	        end: currentValue[1]
	      }, props.beforeValueChange, performUpdate);
	    },
	    updateQueryHandler: function updateQueryHandler(value, props) {
	      var customQuery = props.customQuery;
	      var query = RangeSlider.defaultQuery(value, props);
	      if (customQuery) {
	        var _ref = customQuery(value, props) || {};
	        query = _ref.query;
	        var customQueryOptions = getOptionsFromQuery$3(customQuery(value, props));
	        updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	        this.setQueryOptions(props.componentId, customQueryOptions, false);
	      }
	      var showFilter = props.showFilter,
	        _props$range = props.range,
	        start = _props$range.start,
	        end = _props$range.end;
	      var currentStart = value[0],
	        currentEnd = value[1];
	      // check if the slider is at its initial position
	      var isInitialValue = currentStart === start && currentEnd === end;
	      this.updateQuery({
	        componentId: props.componentId,
	        query: query,
	        value: value,
	        label: props.filterLabel,
	        showFilter: showFilter && !isInitialValue,
	        URLParams: props.URLParams,
	        componentType: constants_1$1.rangeSlider
	      });
	    }
	  },
	  watch: {
	    defaultValue: function defaultValue(newVal) {
	      this.handleChange(RangeSlider.parseValue(newVal, this.$props));
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$f(newVal, oldVal)) {
	        this.handleChange(RangeSlider.parseValue(newVal, this.$props));
	      }
	    },
	    selectedValue: function selectedValue(newVal) {
	      if (!isEqual$f(this.$data.currentValue, newVal)) {
	        this.handleChange(RangeSlider.parseValue(newVal, this.$props));
	        this.$emit('change', newVal);
	      }
	    },
	    customQuery: function customQuery(newVal, oldVal) {
	      if (!isQueryIdentical(newVal, oldVal, this.$data.currentValue, this.$props)) {
	        this.updateQueryHandler(this.$data.currentValue, this.$props);
	      }
	    }
	  },
	  created: function created() {
	    if (!this.$props.range) {
	      console.error('%crange is not defined. Read more about this at https://opensource.appbase.io/reactive-manual/vue/range-components/rangeslider.html#props', 'font-size: 12.5px;');
	    }
	    if (!this.enableAppbase && this.$props.index) {
	      console.warn('Warning(ReactiveSearch): In order to use the `index` prop, the `enableAppbase` prop must be set to true in `ReactiveBase`.');
	    }
	    // Set custom query in store
	    updateCustomQuery(this.componentId, this.setCustomQuery, this.$props, this.currentValue);
	  },
	  beforeMount: function beforeMount() {
	    var _this$$props = this.$props,
	      value = _this$$props.value,
	      defaultValue = _this$$props.defaultValue;
	    var selectedValue = this.selectedValue;
	    if (this.$props.range) {
	      if (Array.isArray(selectedValue)) {
	        this.handleChange(selectedValue);
	      } else if (selectedValue) {
	        this.handleChange(RangeSlider.parseValue(selectedValue, this.$props));
	      } else if (value) {
	        this.handleChange(RangeSlider.parseValue(value, this.$props));
	      } else if (defaultValue) {
	        this.handleChange(RangeSlider.parseValue(defaultValue, this.$props));
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    return h(Container, {
	      "class": this.$props.className
	    }, [this.$props.title && h(Title, {
	      "class": getClassName$e(this.$props.innerClass, 'title')
	    }, [this.$props.title]), this.$props.range ? h(vueNoSsr_common, [h(Slider, {
	      "class": getClassName$e(this.$props.innerClass, 'slider')
	    }, [h("vue-slider-component", {
	      "ref": "slider",
	      "attrs": {
	        "value": this.currentValue,
	        "min": this.$props.range.start,
	        "max": this.$props.range.end,
	        "dotSize": 20,
	        "height": 4,
	        "enable-cross": false,
	        "tooltip": "always"
	      },
	      "on": {
	        "drag-end": this.handleSlider
	      },
	      "props": _extends({}, this.$props.sliderOptions)
	    }), this.$props.rangeLabels && h("div", {
	      "class": "label-container"
	    }, [h("label", {
	      "class": getClassName$e(this.$props.innerClass, 'label') || 'range-label-left'
	    }, [this.$props.rangeLabels.start]), h("label", {
	      "class": getClassName$e(this.$props.innerClass, 'label') || 'range-label-right'
	    }, [this.$props.rangeLabels.end])])])]) : null]);
	  }
	};
	RangeSlider.defaultQuery = function (values, props) {
	  var query = null;
	  if (Array.isArray(values) && values.length) {
	    var _range;
	    query = {
	      range: (_range = {}, _range[props.dataField] = {
	        gte: values[0],
	        lte: values[1],
	        boost: 2.0
	      }, _range)
	    };
	  }
	  if (query && props.nestedField) {
	    return {
	      query: {
	        nested: {
	          path: props.nestedField,
	          query: query
	        }
	      }
	    };
	  }
	  return query;
	};
	RangeSlider.parseValue = function (value, props) {
	  if (value) {
	    return Array.isArray(value) ? value : [value.start, value.end];
	  }
	  if (props.range) {
	    return [props.range.start, props.range.end];
	  }
	  return [];
	};
	var mapStateToProps$e = function mapStateToProps(state, props) {
	  return {
	    options: state.aggregations[props.componentId] ? state.aggregations[props.componentId][props.dataField] && state.aggregations[props.componentId][props.dataField].buckets // eslint-disable-line
	    : [],
	    selectedValue: state.selectedValues[props.componentId] ? state.selectedValues[props.componentId].value : null,
	    componentProps: state.props[props.componentId],
	    enableAppbase: state.config.enableAppbase
	  };
	};
	var mapDispatchtoProps$b = {
	  updateQuery: updateQuery$c,
	  setQueryOptions: setQueryOptions$b,
	  setCustomQuery: setCustomQuery$b
	};
	var RangeConnected$3 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$e, mapDispatchtoProps$b)(RangeSlider), {
	  componentType: constants_1$1.rangeSlider
	}));
	RangeConnected$3.name = RangeSlider.name;
	RangeConnected$3.defaultQuery = RangeSlider.defaultQuery;
	RangeConnected$3.parseValue = RangeSlider.parseValue;
	RangeConnected$3.hasInternalComponent = RangeSlider.hasInternalComponent;
	RangeConnected$3.install = function (Vue) {
	  Vue.component(RangeConnected$3.name, RangeConnected$3);
	};

	// Add componentType for SSR
	RangeConnected$3.componentType = constants_1$1.rangeSlider;

	var _templateObject$p, _templateObject2$b;
	var alert = function alert(_ref) {
	  var theme = _ref.theme;
	  return css(_templateObject$p || (_templateObject$p = _taggedTemplateLiteralLoose(["\n\tcolor: ", ";\n"])), theme.colors.alertColor);
	};
	var Content = index$1('div')(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteralLoose(["\n\t", ";\n\tfont-size: 13px;\n\tmargin: 8px;\n"])), function (props) {
	  return props.alert && alert;
	});

	var getClassName$f = lib_8.getClassName,
	  isEqual$g = lib_8.isEqual;
	var RangeInput = {
	  name: 'RangeInput',
	  components: {
	    RangeSlider: RangeConnected$3
	  },
	  inject: {
	    theme: {
	      from: 'theme_reactivesearch'
	    }
	  },
	  data: function data() {
	    var state = {
	      currentValue: {
	        start: this.$props.range ? this.$props.range.start : 0,
	        end: this.$props.range ? this.$props.range.end : 10
	      },
	      isStartValid: true,
	      isEndValid: true
	    };
	    return state;
	  },
	  props: {
	    className: {
	      types: types.string,
	      "default": ''
	    },
	    defaultValue: types.range,
	    validateRange: types.func,
	    value: types.range,
	    dataField: types.stringRequired,
	    innerClass: types.style,
	    range: {
	      types: types.range,
	      "default": function _default() {
	        return {
	          start: 0,
	          end: 10
	        };
	      }
	    },
	    rangeLabels: types.rangeLabels,
	    stepValue: types.number,
	    componentStyle: types.style,
	    componentId: types.stringRequired,
	    includeNullValues: VueTypes.bool,
	    beforeValueChange: types.func,
	    customQuery: types.func,
	    data: types.data,
	    filterLabel: types.string,
	    react: types.react,
	    showFilter: VueTypes.bool.def(true),
	    showCheckbox: VueTypes.bool.def(true),
	    title: types.title,
	    URLParams: VueTypes.bool.def(false),
	    sliderOptions: VueTypes.object.def({}),
	    nestedField: types.string,
	    endpoint: types.endpointConfig
	  },
	  methods: {
	    shouldUpdate: function shouldUpdate(value) {
	      var validateRange = this.$props.validateRange;
	      if (validateRange && value) {
	        return validateRange([value.start, value.end]);
	      }
	      if (value) {
	        return value.start <= value.end;
	      }
	      return false;
	    },
	    isControlled: function isControlled() {
	      if (this.$props.value && this.$listeners) {
	        return true;
	      }
	      return false;
	    },
	    handleChange: function handleChange(value, event) {
	      var currentValue = value;
	      if (this.shouldUpdate(value) && !isEqual$g(value, this.currentValue)) {
	        switch (event) {
	          case 'change':
	            if (!value) {
	              currentValue = {
	                start: this.$props.range ? this.$props.range.start : 0,
	                end: this.$props.range ? this.$props.range.end : 10
	              };
	            }
	            this.$data.currentValue = _extends({}, currentValue);
	            this.$emit('change', this.$data.currentValue);
	            break;
	          case 'value-change':
	            this.$emit('valueChange', this.$data.currentValue);
	            this.$emit('value-change', this.$data.currentValue);
	            break;
	          default:
	            this.$data.currentValue = _extends({}, currentValue);
	            break;
	        }
	      }
	    },
	    handleOnChange: function handleOnChange(value) {
	      this.handleChange(value || this.$props.range, 'change');
	    },
	    handleValueChange: function handleValueChange(value) {
	      this.handleChange(value, 'value-change');
	    },
	    handleInputChange: function handleInputChange(e) {
	      var _e$target = e.target,
	        name = _e$target.name,
	        value = _e$target.value;
	      if (Number.isNaN(value)) {
	        if (name === 'start') {
	          this.$data.isStartValid = false;
	        } else {
	          this.$data.isEndValid = false;
	        }
	      } else if (name === 'start' && !this.$data.isStartValid) {
	        this.$data.isStartValid = true;
	      } else if (name === 'end' && !this.$data.isEndValid) {
	        this.$data.isEndValid = true;
	      }
	      if (this.$data.isStartValid && this.$data.isEndValid) {
	        if (name === 'start') {
	          this.handleChange({
	            start: Number(value),
	            end: this.$data.currentValue.end
	          }, 'change');
	        } else {
	          this.handleChange({
	            start: this.$data.currentValue.start,
	            end: Number(value)
	          }, 'change');
	        }
	      }
	    }
	  },
	  watch: {
	    defaultValue: function defaultValue(newVal, oldVal) {
	      if (oldVal.start !== newVal.start || oldVal.end !== newVal.end) {
	        this.handleChange(newVal);
	      }
	    },
	    value: function value(newVal, oldVal) {
	      if (!isEqual$g(newVal, oldVal)) {
	        if (this.isControlled()) {
	          this.handleChange(newVal, 'change');
	        }
	      }
	    }
	  },
	  created: function created() {
	    if (this.$props.defaultValue && this.$props.defaultValue.start && this.$props.defaultValue.end) {
	      this.handleChange(this.$props.defaultValue);
	    }
	    if (this.isControlled()) {
	      this.handleChange(this.$props.value, 'change');
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      className = _this$$props.className,
	      dataField = _this$$props.dataField,
	      range = _this$$props.range,
	      rangeLabels = _this$$props.rangeLabels,
	      componentId = _this$$props.componentId,
	      innerClass = _this$$props.innerClass,
	      stepValue = _this$$props.stepValue,
	      componentStyle = _this$$props.componentStyle,
	      themePreset = _this$$props.themePreset,
	      includeNullValues = _this$$props.includeNullValues,
	      beforeValueChange = _this$$props.beforeValueChange,
	      customQuery = _this$$props.customQuery,
	      data = _this$$props.data,
	      filterLabel = _this$$props.filterLabel,
	      react = _this$$props.react,
	      showFilter = _this$$props.showFilter,
	      showCheckbox = _this$$props.showCheckbox,
	      title = _this$$props.title,
	      URLParams = _this$$props.URLParams,
	      sliderOptions = _this$$props.sliderOptions,
	      nestedField = _this$$props.nestedField;
	    return h(Container, {
	      "style": componentStyle,
	      "class": className
	    }, [h(RangeConnected$3, {
	      "attrs": {
	        "componentId": componentId,
	        "value": {
	          start: this.currentValue.start,
	          end: this.currentValue.end
	        },
	        "range": range,
	        "dataField": dataField,
	        "rangeLabels": rangeLabels,
	        "includeNullValues": includeNullValues,
	        "beforeValueChange": beforeValueChange,
	        "customQuery": customQuery,
	        "data": data,
	        "filterLabel": filterLabel,
	        "react": react,
	        "showFilter": showFilter,
	        "showCheckbox": showCheckbox,
	        "title": title,
	        "uRLParams": URLParams,
	        "sliderOptions": sliderOptions,
	        "nestedField": nestedField
	      },
	      "on": {
	        "change": this.handleOnChange,
	        "value-change": this.handleValueChange
	      }
	    }), h(Flex, {
	      "class": getClassName$f(innerClass, 'input-container') || ''
	    }, [h(Flex, {
	      "attrs": {
	        "direction": "column",
	        "flex": 2
	      }
	    }, [h(Input, {
	      "key": componentId + "-start-value",
	      "attrs": {
	        "name": "start",
	        "type": "number",
	        "step": stepValue,
	        "themePreset": themePreset,
	        "aria-label": componentId + "-start-input",
	        "min": this.$props.range ? this.$props.range.start : 0,
	        "alert": !this.isStartValid
	      },
	      "on": {
	        "change": this.handleInputChange
	      },
	      "class": getClassName$f(innerClass, 'input') || '',
	      "domProps": _extends({}, {
	        value: this.currentValue.start
	      })
	    }), !this.isStartValid && h(Content, {
	      "attrs": {
	        "alert": true
	      }
	    }, ["Input range is invalid"])]), h(Flex, {
	      "attrs": {
	        "justifyContent": "center",
	        "alignItems": "center",
	        "flex": 1
	      }
	    }, ["-"]), h(Flex, {
	      "attrs": {
	        "direction": "column",
	        "flex": 2
	      }
	    }, [h(Input, {
	      "key": componentId + "-end-value",
	      "attrs": {
	        "name": "end",
	        "type": "number",
	        "step": stepValue,
	        "themePreset": themePreset,
	        "aria-label": componentId + "-end-input",
	        "max": this.$props.range ? this.$props.range.end : 10,
	        "alert": !this.isEndValid
	      },
	      "on": {
	        "change": this.handleInputChange
	      },
	      "class": getClassName$f(innerClass, 'input') || '',
	      "domProps": _extends({}, {
	        value: this.currentValue.end
	      })
	    }), !this.isEndValid && h(Content, {
	      "attrs": {
	        "alert": true
	      }
	    }, ["Input range is invalid"])])])]);
	  }
	};
	var mapStateToProps$f = function mapStateToProps(state) {
	  return {
	    themePreset: state.config.themePreset
	  };
	};
	var RangeConnected$4 = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$f, {})(RangeInput), {
	  componentType: constants_1$1.rangeInput
	}));
	RangeConnected$4.name = RangeInput.name;
	RangeConnected$4.install = function (Vue) {
	  Vue.component(RangeConnected$4.name, RangeConnected$4);
	};

	// Add componentType for SSR
	RangeConnected$4.componentType = constants_1$1.rangeInput;

	var RcConnected$1 = PreferencesConsumer({
	  name: 'RcConnected',
	  render: function render(h) {
	    var component = RcConnected;
	    switch (this.$attrs.componentType) {
	      case constants_1$1.reactiveList:
	        component = RLConnected;
	        break;
	      case constants_1$1.searchBox:
	        component = SBConnected;
	        break;
	      // list components
	      case constants_1$1.singleList:
	        component = ListConnected;
	        break;
	      case constants_1$1.multiList:
	        component = ListConnected$1;
	        break;
	      case constants_1$1.singleDropdownList:
	        component = ListConnected$2;
	        break;
	      case constants_1$1.multiDropdownList:
	        component = ListConnected$3;
	        break;
	      // basic components
	      case constants_1$1.toggleButton:
	        component = TBConnected;
	        break;
	      // range components
	      case constants_1$1.dynamicRangeSlider:
	        component = RangeConnected;
	        break;
	      case constants_1$1.singleRange:
	        component = RangeConnected$1;
	        break;
	      case constants_1$1.multiRange:
	        component = RangeConnected$2;
	        break;
	      case constants_1$1.rangeSlider:
	        component = RangeConnected$3;
	        break;
	      case constants_1$1.rangeInput:
	        component = RangeConnected$4;
	        break;
	    }
	    return h(component, {
	      attrs: this.$attrs,
	      on: this.$listeners,
	      scopedSlots: this.$scopedSlots,
	      slots: this.$slots
	    });
	  }
	});
	RcConnected$1.name = 'ReactiveComponentPrivate';
	RcConnected$1.hasInternalComponent = RcConnected.hasInternalComponent;
	// Add componentType for SSR
	RcConnected$1.componentType = constants_1$1.reactiveComponent;
	RcConnected$1.install = function (Vue) {
	  Vue.component(RcConnected$1.name, RcConnected$1);
	};

	var setValue$2 = lib_5.setValue,
	  clearValues = lib_5.clearValues,
	  resetValuesToDefault = lib_5.resetValuesToDefault;
	var getClassName$g = lib_8.getClassName,
	  handleA11yAction$2 = lib_8.handleA11yAction;
	var SelectedFilters = {
	  name: 'SelectedFilters',
	  props: {
	    className: VueTypes.string.def(''),
	    clearAllLabel: VueTypes.string.def('Clear All'),
	    innerClass: types.style,
	    showClearAll: VueTypes.bool.def(true),
	    title: types.title,
	    resetToDefault: VueTypes.bool.def(false),
	    clearAllBlacklistComponents: VueTypes.array,
	    resetToValues: VueTypes.object
	  },
	  inject: {
	    theme: {
	      from: 'theme_reactivesearch'
	    }
	  },
	  render: function render() {
	    var _this = this;
	    var h = arguments[0];
	    if (this.$scopedSlots["default"]) {
	      return this.$scopedSlots["default"]({
	        components: this.components,
	        selectedValues: this.selectedValues,
	        clearValues: this.clearValues,
	        clearValue: this.clearValue,
	        setValue: this.setValue,
	        resetValuesToDefault: this.resetValuesToDefault
	      });
	    }
	    var filtersToRender = this.renderFilters();
	    var hasValues = !!filtersToRender.length;
	    return h(Container, {
	      "class": filters(this.theme) + " " + (this.$props.className || '')
	    }, [this.$props.title && hasValues && h(Title, {
	      "class": getClassName$g(this.$props.innerClass, 'title') || ''
	    }, [this.$props.title]), filtersToRender, this.$props.showClearAll && hasValues && filtersToRender.length > 1 ? h(Button, {
	      "class": getClassName$g(this.$props.innerClass, 'button') || '',
	      "on": _extends({}, {
	        click: this.clearValues,
	        keypress: function keypress(event) {
	          return handleA11yAction$2(event, function () {
	            return _this.clearValues();
	          });
	        }
	      }),
	      "attrs": {
	        "tabIndex": "0"
	      }
	    }, [this.$props.clearAllLabel]) : null]);
	  },
	  methods: {
	    remove: function remove(component, value) {
	      if (value === void 0) {
	        value = null;
	      }
	      this.setValue(component, null);
	      this.$emit('clear', component, value);
	    },
	    clearValues: function clearValues() {
	      var resetToDefault = this.resetToDefault,
	        resetToValues = this.resetToValues,
	        clearAllBlacklistComponents = this.clearAllBlacklistComponents;
	      if (resetToDefault) {
	        this.resetValuesToDefault(clearAllBlacklistComponents);
	      } else {
	        this.clearValuesAction(resetToValues, clearAllBlacklistComponents);
	      }
	      this.$emit('clear', resetToValues);
	    },
	    clearValue: function clearValue(componentId) {
	      var resetToDefault = this.resetToDefault,
	        resetToValues = this.resetToValues;
	      if (resetToDefault) {
	        this.resetValuesToDefault(this.components.filter(function (component) {
	          return component !== componentId;
	        }));
	      } else {
	        this.setValue(componentId, (resetToValues == null ? void 0 : resetToValues[componentId]) || null);
	      }
	      this.$emit('clear', resetToValues == null ? void 0 : resetToValues[componentId]);
	    },
	    renderValue: function renderValue(value, isArray) {
	      var _this2 = this;
	      if (isArray && value.length) {
	        var arrayToRender = value.map(function (item) {
	          return _this2.renderValue(item);
	        });
	        return arrayToRender.join(', ');
	      }
	      if (value && typeof value === 'object') {
	        // TODO: support for NestedList
	        var label = (typeof value.label === 'string' ? value.label : value.value) || value.key || value.distance || null;
	        if (value.location) {
	          label = value.location + " - " + label;
	        }
	        return label;
	      }
	      return value;
	    },
	    renderFilterButton: function renderFilterButton(component, keyProp, handleRemove, label) {
	      var h = this.$createElement;
	      return h(Button, {
	        "class": getClassName$g(this.$props.innerClass, 'button') || '',
	        "key": keyProp,
	        "on": _extends({}, {
	          click: handleRemove,
	          keypress: function keypress(event) {
	            return handleA11yAction$2(event, handleRemove);
	          }
	        }),
	        "attrs": {
	          "tabIndex": "0"
	        }
	      }, [h("span", [label]), h("span", ["\u2715"])]);
	    },
	    renderFilters: function renderFilters() {
	      var _this3 = this;
	      var selectedValues = this.selectedValues;
	      var filterComponents = Object.keys(selectedValues).filter(function (id) {
	        return _this3.components.includes(id) && selectedValues[id].showFilter;
	      });
	      return filterComponents.map(function (component, index) {
	        var _selectedValues$compo = selectedValues[component],
	          label = _selectedValues$compo.label,
	          value = _selectedValues$compo.value;
	        var isArray = Array.isArray(value);

	        // default behaviour
	        if (label && (isArray && value.length || !isArray && value)) {
	          var valueToRender = _this3.renderValue(value, isArray);
	          return _this3.renderFilterButton(component, component + "-" + (index + 1), function () {
	            return _this3.remove(component, value);
	          }, selectedValues[component].label + ": " + decodeHtml(valueToRender));
	        }
	        return null;
	      }).filter(Boolean);
	    }
	  },
	  watch: {
	    selectedValues: function selectedValues(newVal) {
	      this.$emit('change', newVal);
	    }
	  }
	};
	var mapStateToProps$g = function mapStateToProps(state) {
	  return {
	    components: state.components,
	    selectedValues: state.selectedValues
	  };
	};
	var mapDispatchtoProps$c = {
	  clearValuesAction: clearValues,
	  setValue: setValue$2,
	  resetValuesToDefault: resetValuesToDefault
	};
	var RcConnected$2 = connect(mapStateToProps$g, mapDispatchtoProps$c)(SelectedFilters);
	RcConnected$2.name = SelectedFilters.name;
	RcConnected$2.install = function (Vue) {
	  Vue.component(RcConnected$2.name, RcConnected$2);
	};

	var ResultCardTitle = {
	  name: 'ResultCardTitle',
	  render: function render() {
	    var h = arguments[0];
	    var children = this.$slots["default"];
	    return h(Title, helper$1([{}, this.$props]), [children]);
	  }
	};
	ResultCardTitle.install = function (Vue) {
	  Vue.component(ResultCardTitle.name, ResultCardTitle);
	};

	var _excluded$1 = ["src"];
	var ResultCardImage = {
	  name: 'ResultCardImage',
	  props: {
	    src: VueTypes.string.isRequired
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      src = _this$$props.src,
	      props = _objectWithoutPropertiesLoose(_this$$props, _excluded$1);
	    return h(Image$1, helper$1([{
	      "style": {
	        backgroundImage: "url(" + src + ")"
	      }
	    }, props]));
	  }
	};
	ResultCardImage.install = function (Vue) {
	  Vue.component(ResultCardImage.name, ResultCardImage);
	};

	var ResultCardDescription = {
	  name: 'ResultCardDescription',
	  functional: true,
	  render: function render(_, _ref) {
	    var props = _ref.props,
	      children = _ref.children;
	    var h = arguments[0];
	    return h("article", helper$1([{}, props]), [children]);
	  }
	};
	ResultCardDescription.install = function (Vue) {
	  Vue.component(ResultCardDescription.name, ResultCardDescription);
	};

	var _excluded$2 = ["href", "target"];
	var ResultCard = {
	  name: 'ResultCard',
	  components: {
	    ResultCardTitle: ResultCardTitle,
	    ResultCardImage: ResultCardImage,
	    ResultCardDescription: ResultCardDescription
	  },
	  props: {
	    target: VueTypes.string.def('_blank'),
	    href: types.string
	  },
	  render: function render() {
	    var h = arguments[0];
	    var children = this.$slots["default"];
	    var _this$$props = this.$props,
	      href = _this$$props.href,
	      target = _this$$props.target,
	      rest = _objectWithoutPropertiesLoose(_this$$props, _excluded$2);
	    return h(Card, helper$1([{
	      "attrs": {
	        "href": href,
	        "target": target,
	        "rel": target === '_blank' ? 'noopener noreferrer' : null
	      }
	    }, rest]), [children]);
	  }
	};
	ResultCard.install = function (Vue) {
	  Vue.component(ResultCard.name, ResultCard);
	  Vue.component(ResultCardTitle.name, ResultCardTitle);
	  Vue.component(ResultCardImage.name, ResultCardImage);
	  Vue.component(ResultCardDescription.name, ResultCardDescription);
	};

	var ResultListContent = {
	  name: 'ResultListContent',
	  functional: true,
	  render: function render(_, _ref) {
	    var props = _ref.props,
	      children = _ref.children;
	    var h = arguments[0];
	    return h("article", helper$1([{}, props]), [children]);
	  }
	};
	ResultListContent.install = function (Vue) {
	  Vue.component(ResultListContent.name, ResultListContent);
	};

	var ResultListDescription = {
	  name: 'ResultListDescription',
	  functional: true,
	  render: function render(_, _ref) {
	    var props = _ref.props,
	      children = _ref.children;
	    var h = arguments[0];
	    return h("div", helper$1([{}, props]), [children]);
	  }
	};
	ResultListDescription.install = function (Vue) {
	  Vue.component(ResultListDescription.name, ResultListDescription);
	};

	var _excluded$3 = ["src", "small"];
	var ResultListImage = {
	  name: 'ResultListImage',
	  props: {
	    src: VueTypes.string.isRequired,
	    small: VueTypes.bool.def(false)
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      src = _this$$props.src,
	      small = _this$$props.small,
	      props = _objectWithoutPropertiesLoose(_this$$props, _excluded$3);
	    return h(Image, helper$1([{
	      "attrs": {
	        "src": src,
	        "small": small
	      }
	    }, props]));
	  }
	};
	ResultListImage.install = function (Vue) {
	  Vue.component(ResultListImage.name, ResultListImage);
	};

	var ResultListTitle = {
	  name: 'ResultListTitle',
	  render: function render() {
	    var h = arguments[0];
	    var children = this.$slots["default"];
	    return h(Title, helper$1([{}, this.$props]), [children]);
	  }
	};
	ResultListTitle.install = function (Vue) {
	  Vue.component(ResultListTitle.name, ResultListTitle);
	};

	var _excluded$4 = ["href", "target"];
	var ResultList = {
	  name: 'ResultList',
	  props: {
	    href: types.string,
	    target: VueTypes.string.def('_blank')
	  },
	  components: {
	    ResultListContent: ResultListContent,
	    ResultListDescription: ResultListDescription,
	    ResultListImage: ResultListImage,
	    ResultListTitle: ResultListTitle
	  },
	  data: function data() {
	    this.__state = {
	      hasImage: false,
	      isSmall: false
	    };
	    return this.__state;
	  },
	  mounted: function mounted() {
	    var children = this.$slots["default"];
	    var ImageChild = children.find(function (o) {
	      return o.componentOptions && o.componentOptions.tag === ResultListImage.name;
	    });
	    if (ImageChild && ImageChild.componentOptions && ImageChild.componentOptions.propsData) {
	      this.hasImage = true;
	      if (ImageChild.componentOptions.propsData.small) {
	        this.isSmall = true;
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var _this$$props = this.$props,
	      href = _this$$props.href,
	      target = _this$$props.target,
	      props = _objectWithoutPropertiesLoose(_this$$props, _excluded$4);
	    var hasImage = this.hasImage,
	      isSmall = this.isSmall;
	    var children = this.$slots["default"];
	    return h(ListItem, helper$1([{
	      "attrs": {
	        "href": href,
	        "image": hasImage,
	        "small": isSmall,
	        "target": target,
	        "rel": target === '_blank' ? 'noopener noreferrer' : null
	      }
	    }, props]), [children]);
	  }
	};
	ResultList.install = function (Vue) {
	  Vue.component(ResultList.name, ResultList);
	  Vue.component(ResultListContent.name, ResultListContent);
	  Vue.component(ResultListDescription.name, ResultListDescription);
	  Vue.component(ResultListImage.name, ResultListImage);
	  Vue.component(ResultListTitle.name, ResultListTitle);
	};

	var setSearchState = lib_5.setSearchState;
	var getSearchState = lib_8.getSearchState;
	var defaultKeys = ['hits', 'value', 'aggregations', 'error'];
	var filterProps = function filterProps(props) {
	  if (props === void 0) {
	    props = {};
	  }
	  return _extends({}, props, {
	    props: props.componentProps
	  });
	};
	var convertArrayLike = function convertArrayLike(arrayLike) {
	  var arr = [];
	  var i = 0;
	  while (arrayLike[i]) {
	    arr[i] = arrayLike[i];
	    i += 1;
	  }
	  return arr;
	};
	var filterByComponentIds = function filterByComponentIds(state, props) {
	  if (props === void 0) {
	    props = {};
	  }
	  var _props = props,
	    componentIds = _props.componentIds,
	    excludeComponentIds = _props.excludeComponentIds;
	  if (componentIds) {
	    if (typeof componentIds === 'string') {
	      var _ref;
	      return _ref = {}, _ref[componentIds] = state[componentIds], _ref;
	    }
	    if (Array.isArray(componentIds) && componentIds.length) {
	      var _filteredState = {};
	      componentIds.forEach(function (componentId) {
	        _filteredState[componentId] = state[componentId];
	      });
	      return _filteredState;
	    }
	  }
	  var filteredState = {};
	  if (!props.includeInternalComponents) {
	    Object.keys(state).forEach(function (componentId) {
	      if (componentId.endsWith('internal') || componentId.endsWith('active') || componentId.endsWith('timestamp')) {
	        return;
	      }
	      filteredState[componentId] = state[componentId];
	    });
	  } else {
	    filteredState = state;
	  }
	  // Apply exclude component ids
	  if (excludeComponentIds) {
	    if (typeof excludeComponentIds === 'string') {
	      Object.keys(state).forEach(function (componentId) {
	        if (componentId === excludeComponentIds) {
	          // Delete state
	          delete filteredState[componentId];
	        }
	      });
	    }
	    if (Array.isArray(excludeComponentIds) && excludeComponentIds.length) {
	      Object.keys(state).forEach(function (componentId) {
	        if (excludeComponentIds.includes(componentId)) {
	          // Delete state
	          delete filteredState[componentId];
	        }
	      });
	    }
	  }
	  return filteredState;
	};
	var filterByKeys = function filterByKeys(state, allowedKeys) {
	  return Object.keys(state).reduce(function (components, componentId) {
	    var _extends2;
	    return _extends({}, components, (_extends2 = {}, _extends2[componentId] = Object.keys(state[componentId]).filter(function (key) {
	      return allowedKeys.includes(key);
	    }).reduce(function (obj, key) {
	      // eslint-disable-next-line
	      obj[key] = state[componentId][key];
	      return obj;
	    }, {}), _extends2));
	  }, {});
	};
	var StateProvider = {
	  name: 'StateProvider',
	  props: {
	    onChange: VueTypes.func,
	    componentIds: VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string)]),
	    includeKeys: VueTypes.arrayOf(VueTypes.string).def(defaultKeys),
	    strict: VueTypes.bool.def(true),
	    includeInternalComponents: VueTypes.bool.def(false),
	    excludeComponentIds: VueTypes.oneOfType([VueTypes.string, VueTypes.arrayOf(VueTypes.string)])
	  },
	  data: function data() {
	    this.__state = {
	      searchState: null
	    };
	    return this.__state;
	  },
	  created: function created() {
	    this.searchState = filterByKeys(getSearchState(filterProps(this.searchStateProps)), this.includeKeys);
	  },
	  computed: {
	    searchStateProps: function searchStateProps() {
	      return {
	        selectedValues: this.selectedValues || {},
	        queryLog: this.queryLog || {},
	        dependencyTree: this.dependencyTree || {},
	        componentProps: this.componentProps || {},
	        hits: this.hits || {},
	        aggregations: this.aggregations || {},
	        isLoading: this.isLoading || {},
	        error: this.error || {},
	        promotedResults: this.promotedResults || {},
	        rawData: this.rawData || {}
	      };
	    }
	  },
	  watch: {
	    searchState: function searchState(newVal, oldVal) {
	      if (oldVal != null && this.isStateChanged(newVal, oldVal)) {
	        this.$emit('change', oldVal, newVal);
	      }
	    },
	    selectedValues: function selectedValues(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    queryLog: function queryLog(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    dependencyTree: function dependencyTree(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    componentProps: function componentProps(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    hits: function hits(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    aggregations: function aggregations(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    isLoading: function isLoading(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    error: function error(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    componentIds: function componentIds(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    excludeComponentIds: function excludeComponentIds(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    includeKeys: function includeKeys(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    promotedResults: function promotedResults(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    rawData: function rawData(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    customData: function customData(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    },
	    settings: function settings(newVal, oldVal) {
	      this.calculateSearchState(newVal, oldVal);
	    }
	  },
	  methods: {
	    isStateChanged: function isStateChanged(prevState, nextState) {
	      return JSON.stringify(nextState) !== JSON.stringify(prevState);
	    },
	    calculateSearchState: function calculateSearchState(newVal, oldVal) {
	      if (this.isStateChanged(newVal, oldVal)) {
	        this.searchState = filterByKeys(getSearchState(filterProps(this.searchStateProps)), this.includeKeys);
	      }
	    },
	    setSearchState: function setSearchState(valuesMap) {
	      var _this = this;
	      if (valuesMap === void 0) {
	        valuesMap = {};
	      }
	      var components = this.components;
	      var computedValuesMap = {};
	      convertArrayLike(components).filter(function (component) {
	        return !transform_12(component);
	      }).forEach(function (component) {
	        if (component in valuesMap) {
	          computedValuesMap[component] = {
	            value: valuesMap[component],
	            componentProps: _this.componentProps[component]
	          };
	        } else {
	          computedValuesMap[component] = {
	            value: null,
	            componentProps: _this.componentProps[component]
	          };
	        }
	      });
	      this.setSearchStateFn(computedValuesMap);
	    }
	  },
	  render: function render() {
	    var searchState = this.searchState;
	    var dom = this.$scopedSlots["default"];
	    return dom ? dom({
	      searchState: searchState,
	      setSearchState: this.setSearchState
	    }) : null;
	  }
	};
	var mapStateToProps$h = function mapStateToProps(state, props) {
	  return {
	    selectedValues: filterByComponentIds(state.selectedValues, props),
	    queryLog: filterByComponentIds(state.queryLog, props),
	    dependencyTree: filterByComponentIds(state.dependencyTree, props),
	    componentProps: filterByComponentIds(state.props, props),
	    hits: filterByComponentIds(state.hits, props),
	    aggregations: filterByComponentIds(state.aggregations, props),
	    isLoading: filterByComponentIds(state.isLoading, props),
	    error: filterByComponentIds(state.error, props),
	    promotedResults: filterByComponentIds(state.promotedResults, props),
	    customData: filterByComponentIds(state.customData, props),
	    settings: filterByComponentIds(state.settings, props),
	    rawData: filterByComponentIds(state.rawData, props),
	    components: state.components
	  };
	};
	var mapDispatchtoProps$d = {
	  setSearchStateFn: setSearchState
	};
	var StateProviderConnected = connect(mapStateToProps$h, mapDispatchtoProps$d)(StateProvider);
	StateProviderConnected.name = StateProvider.name;
	StateProviderConnected.install = function (Vue) {
	  Vue.component(StateProviderConnected.name, StateProviderConnected);
	};

	function ownKeys$1(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}
	function _objectSpread2$1(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
	      _defineProperty$2(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }
	  return target;
	}
	function _typeof$2(obj) {
	  "@babel/helpers - typeof";

	  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof$2(obj);
	}
	function _defineProperty$2(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}

	/**
	 * This function helps you to bind events from Google Maps API to Vue events
	 *
	 * @param  {Object} vueInst the Vue instance
	 * @param  {Object} googleMapsInst the Google Maps instance
	 * @param  {string[]} events an array of string with all events that you want to bind
	 * @returns {void}
	 */
	function bindEvents(vueInst, googleMapsInst, events) {
	  events.forEach(function (eventName) {
	    if (vueInst.$gmapOptions.autoBindAllEvents || vueInst.$listeners[eventName]) {
	      googleMapsInst.addListener(eventName, function (ev) {
	        vueInst.$emit(eventName, ev);
	      });
	    }
	  });
	}
	/**
	 * Function that helps you to capitalize the first letter on a word
	 *
	 * @param  {string} text the text that you want to capitalize
	 * @returns {string}
	 */

	function capitalizeFirstLetter(text) {
	  return text.charAt(0).toUpperCase() + text.slice(1);
	}
	/**
	 * Function that helps you to get all non nullable props from a component
	 *
	 * @param  {Object} vueInst the Vue component instance
	 * @param  {Object} props the props object
	 * @returns {Object}
	 */

	function getPropsValues(vueInst, props) {
	  return Object.keys(props).reduce(function (acc, prop) {
	    if (vueInst[prop] !== undefined) {
	      acc[prop] = vueInst[prop];
	    }
	    return acc;
	  }, {});
	}
	/**
	 * This function is a helper for return to the user the internal Google Maps promise
	 * and can wait until it is ready.
	 * This piece of code was orignally written by sindresorhus and can be seen here
	 * @see https://github.com/sindresorhus/lazy-value/blob/master/index.js
	 *
	 *  @param  {Function} fn a function that actually return the promise or async value
	 * @returns {Function} anonymous function that returns the value returned by the fn parameter
	 */

	function getLazyValue(fn) {
	  var called = false;
	  var ret;
	  return function () {
	    if (!called) {
	      called = true;
	      ret = fn();
	    }
	    return ret;
	  };
	}
	/**
	 * This function simulates a down arrow key event when user
	 * hits return (enter) on the autocomplete component selection
	 * the first occurrence in the list.
	 *
	 * This piece of code was orignally written by amirnissim
	 * and has been ported to Vanilla.js by GuillaumeLeclerc
	 * @see http://stackoverflow.com/a/11703018/2694653
	 *
	 * @param  {Object} input the HTML input node element reference
	 * @returns {void}
	 */

	function downArrowSimulator(input) {
	  // eslint-disable-next-line no-underscore-dangle -- Is old style should be analyzed
	  var _addEventListener = input.addEventListener ? input.addEventListener : input.attachEvent;
	  /**
	   * Add event listener wrapper that will replace to default addEventListener or attachEvent function
	   *
	   * @param  {string} type the event type
	   * @param  {Function} listener function should be executed when the event is fired
	   * @returns {void}
	   */

	  function addEventListenerWrapper(type, listener) {
	    // Simulate a 'down arrow' keypress on hitting 'return' when no pac suggestion is selected,
	    // and then trigger the original listener.
	    if (type === 'keydown') {
	      var origListener = listener; // eslint-disable-next-line no-param-reassign -- Is old style this should be analyzed

	      listener = function listener(event) {
	        var suggestionSelected = document ? document.getElementsByClassName('pac-item-selected').length > 0 : null;
	        if (event.which === 13 && !suggestionSelected) {
	          var simulatedEvent = document.createEvent('Event');
	          simulatedEvent.keyCode = 40;
	          simulatedEvent.which = 40;
	          origListener.apply(input, [simulatedEvent]);
	        }
	        origListener.apply(input, [event]);
	      };
	    }
	    _addEventListener.apply(input, [type, listener]);
	  }
	  input.addEventListener = addEventListenerWrapper;
	  input.attachEvent = addEventListenerWrapper;
	}
	/**
	 * When you have two-way bindings, but the actual bound value will not equal
	 * the value you initially passed in, then to avoid an infinite loop you
	 * need to increment a counter every time you pass in a value, decrement the
	 * same counter every time the bound value changed, but only bubble up
	 * the event when the counter is zero.
	 *
	 * @param  {Function} fn Function to be executed to determine if the event was executed
	 *
	    Example:

	    Let's say DrawingRecognitionCanvas is a deep-learning backed canvas
	    that, when given the name of an object (e.g. 'dog'), draws a dog.
	    But whenever the drawing on it changes, it also sends back its interpretation
	    of the image by way of the @newObjectRecognized event.

	    <input
	      type="text"
	      placeholder="an object, e.g. Dog, Cat, Frog"
	      v-model="identifiedObject" />
	    <DrawingRecognitionCanvas
	      :object="identifiedObject"
	      @newObjectRecognized="identifiedObject = $event"
	      />

	    new TwoWayBindingWrapper((increment, decrement, shouldUpdate) => {
	      this.$watch('identifiedObject', () => {
	        // new object passed in
	        increment()
	      })
	      this.$deepLearningBackend.on('drawingChanged', () => {
	        recognizeObject(this.$deepLearningBackend)
	          .then((object) => {
	            decrement()
	            if (shouldUpdate()) {
	              this.$emit('newObjectRecognized', object.name)
	            }
	          })
	      })
	    })
	 */

	function twoWayBindingWrapper(fn) {
	  var counter = 0;
	  fn(function () {
	    counter += 1;
	  }, function () {
	    counter = Math.max(0, counter - 1);
	  }, function () {
	    return counter === 0;
	  });
	}
	/**
	 * Watch the individual properties of a PoD object, instead of the object
	 * per se. This is different from a deep watch where both the reference
	 * and the individual values are watched.
	 *
	 * In effect, it throttles the multiple $watch to execute at most once per tick.
	 *
	 * @param  {Object} vueInst the component instance
	 * @param  {string[]} propertiesToTrack string array with all properties that you want to track
	 * @param  {Function} handler function to be fired when the prop change
	 * @param  {boolean} immediate=false
	 * @returns {void}
	 */

	function watchPrimitiveProperties(vueInst, propertiesToTrack, handler) {
	  var immediate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	  var isHandled = false;
	  /**
	   * Function in charge to execute the handler function if it was not fired
	   *
	   * @returns void
	   */

	  function requestHandle() {
	    if (!isHandled) {
	      isHandled = true;
	      vueInst.$nextTick(function () {
	        isHandled = false;
	        handler();
	      });
	    }
	  }
	  propertiesToTrack.forEach(function (prop) {
	    vueInst.$watch(prop, requestHandle, {
	      immediate: immediate
	    });
	  });
	}
	/**
	 * Binds the properties defined in props to the google maps instance.
	 * If the prop is an Object type, and we wish to track the properties
	 * of the object (e.g. the lat and lng of a LatLng), then we do a deep
	 * watch. For deep watch, we also prevent the _changed event from being
	 * emitted if the data source was external.
	 *
	 * @param  {Object} vueInst the component instance
	 * @param  {Object} googleMapsInst the Google Maps instance
	 * @param  {Object} props object with the component props tha should be synched with the Google Maps instances props
	 * @returns {void}
	 */

	function bindProps(vueInst, googleMapsInst, props) {
	  Object.keys(props).forEach(function (attribute) {
	    var _props$attribute = props[attribute],
	      twoWay = _props$attribute.twoWay,
	      type = _props$attribute.type,
	      trackProperties = _props$attribute.trackProperties,
	      noBind = _props$attribute.noBind;
	    if (!noBind) {
	      var setMethodName = "set".concat(capitalizeFirstLetter(attribute));
	      var getMethodName = "get".concat(capitalizeFirstLetter(attribute));
	      var eventName = "".concat(attribute.toLowerCase(), "_changed");
	      var initialValue = vueInst[attribute];
	      if (typeof googleMapsInst[setMethodName] === 'undefined') {
	        throw new Error(
	        // TODO: Analyze all disabled rules in the file
	        // eslint-disable-next-line no-underscore-dangle -- old code should be analyzed
	        "".concat(setMethodName, " is not a method of (the Maps object corresponding to) ").concat(vueInst.$options._componentTag));
	      } // We need to avoid an endless
	      // propChanged -> event emitted -> propChanged -> event emitted loop
	      // although this may really be the user's responsibility

	      if (type !== Object || !trackProperties) {
	        // Track the object deeply
	        vueInst.$watch(attribute, function () {
	          var attributeValue = vueInst[attribute];
	          googleMapsInst[setMethodName](attributeValue);
	        }, {
	          immediate: typeof initialValue !== 'undefined',
	          deep: type === Object
	        });
	      } else {
	        watchPrimitiveProperties(vueInst, trackProperties.map(function (prop) {
	          return "".concat(attribute, ".").concat(prop);
	        }), function () {
	          googleMapsInst[setMethodName](vueInst[attribute]);
	        }, vueInst[attribute] !== undefined);
	      }
	      if (twoWay && (vueInst.$gmapOptions.autoBindAllEvents || vueInst.$listeners[eventName])) {
	        googleMapsInst.addListener(eventName, function () {
	          vueInst.$emit(eventName, googleMapsInst[getMethodName]());
	        });
	      }
	    }
	  });
	}

	/**
	 * This are GoogleMapsOptions that we want to have like
	 * props in our Vue component.
	 * This properties are in the way that GoogleMaps accept it
	 * and with extraneous properties for the VueJs API.
	 * In a previous version of this plugin, to avoid repetition,
	 * we created a .js file component with a `mappedProps` key on it
	 * and used a variety of helper functions to clean it and bind it
	 * to Vue props and watch them, etc.
	 * To day our primary main goal is get a more intuitive and descriptive
	 * API and a better documentation of it, following this goals we move
	 * this extraneous properties to an independent file in order to consume
	 * it when is needed.
	 * Please you need to remind that you need to create properties in the
	 * correspondent Vue component with the same names and the same values
	 * for those properties that are not extraneous to Vue.
	 */
	var autocompleteMappedProps = {
	  bounds: {
	    type: Object
	  },
	  componentRestrictions: {
	    type: Object,
	    // Do not bind -- must check for undefined
	    // in the property
	    noBind: true
	  },
	  types: {
	    type: Array,
	    "default": function _default() {
	      return [];
	    }
	  }
	};
	var drawingManagerMappedProps = {
	  circleOptions: {
	    type: Object,
	    twoWay: false,
	    noBind: true
	  },
	  markerOptions: {
	    type: Object,
	    twoWay: false,
	    noBind: true
	  },
	  polygonOptions: {
	    type: Object,
	    twoWay: false,
	    noBind: true
	  },
	  polylineOptions: {
	    type: Object,
	    twoWay: false,
	    noBind: true
	  },
	  rectangleOptions: {
	    type: Object,
	    twoWay: false,
	    noBind: true
	  }
	};
	var heatMapLayerMappedProps = {
	  options: {
	    type: Object,
	    twoWay: false,
	    "default": function _default() {}
	  },
	  data: {
	    type: Array,
	    twoWay: true
	  }
	};
	var infoWindowMappedProps = {
	  content: {
	    type: Object,
	    twoWay: true
	  },
	  options: {
	    type: Object,
	    required: false,
	    "default": function _default() {
	      return {};
	    }
	  },
	  position: {
	    type: Object,
	    twoWay: true
	  },
	  zIndex: {
	    type: Number,
	    twoWay: true
	  }
	};
	var kmlLayerMappedProps = {
	  clickable: {
	    type: Boolean,
	    twoWay: true,
	    noBind: true
	  },
	  map: {
	    type: Object,
	    twoWay: true
	  },
	  preserveViewport: {
	    type: Boolean,
	    twoWay: true,
	    noBind: true
	  },
	  screenOverlays: {
	    type: Boolean,
	    twoWay: true,
	    noBind: true
	  },
	  suppressInfoWindows: {
	    type: Boolean,
	    twoWay: true,
	    noBind: true
	  },
	  url: {
	    type: String,
	    twoWay: false
	  },
	  zIndex: {
	    type: Number,
	    twoWay: true
	  },
	  options: {
	    type: Object,
	    "default": function _default() {
	      return {};
	    }
	  }
	};
	var mapMappedProps = {
	  center: {
	    required: true,
	    twoWay: true,
	    type: Object,
	    noBind: true
	  },
	  zoom: {
	    required: false,
	    twoWay: true,
	    type: Number,
	    noBind: true
	  },
	  heading: {
	    type: Number,
	    twoWay: true
	  },
	  mapTypeId: {
	    twoWay: true,
	    type: String
	  },
	  tilt: {
	    twoWay: true,
	    type: Number
	  },
	  options: {
	    type: Object,
	    "default": function _default() {
	      return {};
	    }
	  }
	};
	var markerMappedProps = {
	  animation: {
	    twoWay: true,
	    type: Number
	  },
	  attribution: {
	    type: Object
	  },
	  clickable: {
	    type: Boolean,
	    twoWay: true,
	    "default": true
	  },
	  cursor: {
	    type: String,
	    twoWay: true
	  },
	  draggable: {
	    type: Boolean,
	    twoWay: true,
	    "default": false
	  },
	  icon: {
	    twoWay: true
	  },
	  label: {},
	  opacity: {
	    type: Number,
	    "default": 1
	  },
	  options: {
	    type: Object
	  },
	  place: {
	    type: Object
	  },
	  position: {
	    type: Object,
	    twoWay: true
	  },
	  shape: {
	    type: Object,
	    twoWay: true
	  },
	  title: {
	    type: String,
	    twoWay: true
	  },
	  zIndex: {
	    type: Number,
	    twoWay: true
	  },
	  visible: {
	    twoWay: true,
	    "default": true
	  }
	};
	var streetViewPanoramaMappedProps = {
	  zoom: {
	    twoWay: true,
	    type: Number
	  },
	  pov: {
	    twoWay: true,
	    type: Object,
	    trackProperties: ['pitch', 'heading']
	  },
	  position: {
	    twoWay: true,
	    type: Object,
	    noBind: true
	  },
	  pano: {
	    twoWay: true,
	    type: String
	  },
	  motionTracking: {
	    twoWay: false,
	    type: Boolean
	  },
	  visible: {
	    twoWay: true,
	    type: Boolean,
	    "default": true
	  },
	  options: {
	    twoWay: false,
	    type: Object,
	    "default": function _default() {
	      return {};
	    }
	  }
	};
	var polygonMappedProps = {
	  clickable: {
	    type: Boolean,
	    noBind: true
	  },
	  draggable: {
	    type: Boolean
	  },
	  editable: {
	    type: Boolean
	  },
	  fillColor: {
	    type: String,
	    noBind: true
	  },
	  fillOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokeColor: {
	    type: String,
	    noBind: true
	  },
	  strokeOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokePosition: {
	    type: Number,
	    noBind: true
	  },
	  strokeWeight: {
	    type: Number,
	    noBind: true
	  },
	  visible: {
	    type: Boolean
	  },
	  options: {
	    type: Object
	  },
	  path: {
	    type: Array,
	    twoWay: true,
	    noBind: true
	  },
	  paths: {
	    type: Array,
	    twoWay: true,
	    noBind: true
	  }
	};
	var polylineMappedProps = {
	  clickable: {
	    type: Boolean,
	    noBind: true
	  },
	  draggable: {
	    type: Boolean
	  },
	  editable: {
	    type: Boolean
	  },
	  strokeColor: {
	    type: String,
	    noBind: true
	  },
	  strokeOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokeWeight: {
	    type: Number,
	    noBind: true
	  },
	  visible: {
	    type: Boolean
	  },
	  options: {
	    twoWay: false,
	    type: Object
	  },
	  path: {
	    type: Array,
	    twoWay: true
	  }
	};
	var rectangleMappedProps = {
	  bounds: {
	    type: Object,
	    twoWay: true
	  },
	  clickable: {
	    type: Boolean,
	    noBind: true
	  },
	  draggable: {
	    type: Boolean,
	    "default": false
	  },
	  editable: {
	    type: Boolean,
	    "default": false
	  },
	  fillColor: {
	    type: String,
	    noBind: true
	  },
	  fillOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokeColor: {
	    type: String,
	    noBind: true
	  },
	  strokeOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokePosition: {
	    type: Number,
	    noBind: true
	  },
	  strokeWeight: {
	    type: Number,
	    noBind: true
	  },
	  visible: {
	    type: Boolean
	  },
	  options: {
	    type: Object,
	    twoWay: false
	  }
	};
	var circleMappedProps = {
	  center: {
	    type: Object,
	    twoWay: true,
	    required: true
	  },
	  radius: {
	    type: Number,
	    twoWay: true
	  },
	  clickable: {
	    type: Boolean,
	    noBind: true
	  },
	  draggable: {
	    type: Boolean,
	    "default": false
	  },
	  editable: {
	    type: Boolean,
	    "default": false
	  },
	  fillColor: {
	    type: String,
	    noBind: true
	  },
	  fillOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokeColor: {
	    type: String,
	    noBind: true
	  },
	  strokeOpacity: {
	    type: Number,
	    noBind: true
	  },
	  strokePosition: {
	    type: Number,
	    noBind: true
	  },
	  strokeWeight: {
	    type: Number,
	    noBind: true
	  },
	  visible: {
	    type: Boolean
	  },
	  options: {
	    type: Object,
	    twoWay: false
	  }
	};
	var placeInputMappedProps = {
	  bounds: {
	    type: Object
	  },
	  defaultPlace: {
	    type: String,
	    "default": ''
	  },
	  componentRestrictions: {
	    type: Object,
	    "default": null
	  },
	  types: {
	    type: Array,
	    "default": function _default() {
	      return [];
	    }
	  },
	  placeholder: {
	    required: false,
	    type: String
	  },
	  className: {
	    required: false,
	    type: String
	  },
	  label: {
	    required: false,
	    type: String,
	    "default": null
	  },
	  selectFirstOnEnter: {
	    require: false,
	    type: Boolean,
	    "default": false
	  }
	};
	var clusterIconMappedProps = {
	  algorithm: {
	    type: Object
	  },
	  onClusterClick: {
	    type: Function
	  },
	  renderer: {
	    type: Object
	  },
	  options: {
	    type: Object
	  }
	};

	//

	/**
	 * Autocomplete component
	 * @displayName GmapAutocomplete
	 * @see [source code](/guide/autocomplete.html#source-code)
	 */
	var script = {
	  name: 'AutocompleteInput',
	  props: {
	    /**
	     * Map bounds this is an LatLngBounds
	     * object builded with
	     * @value new google.maps.LatLngBounds(...)
	     * @see [Map Bounds](https://developers.google.com/maps/documentation/javascript/places-autocomplete#set-the-bounds-on-creation-of-the-autocomplete-object)
	     */
	    bounds: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Restrict the search to a specific country
	     * @value `{[key: string]: string}`
	     * @see [componentRestrictions](https://developers.google.com/maps/documentation/javascript/places-autocomplete#restrict-the-search-to-a-specific-country)
	     */
	    componentRestrictions: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Map types this is an array of strings
	     * @value string[]
	     * @see [Map Bounds](https://developers.google.com/maps/documentation/javascript/places-autocomplete#set-the-bounds-on-creation-of-the-autocomplete-object)
	     */
	    types: {
	      type: Array,
	      "default": undefined
	    },
	    /**
	     * Select the first result in the list when press enter keyboard
	     * @values true, false
	     */
	    selectFirstOnEnter: {
	      required: false,
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * the unique ref set to the component passed in the slot input
	     */
	    slotRefName: {
	      required: false,
	      type: String,
	      "default": 'input'
	    },
	    /**
	     * The name of the ref to obtain the html input element
	     * if its a child  of component in the slot input
	     * very useful whe we use a component like v-text-field of vuetify
	     * that has a 'input' ref pointing to the final html input element
	     */
	    childRefName: {
	      required: false,
	      type: String,
	      "default": 'input'
	    },
	    /**
	     * Other options that you can pass to the Google Mapas
	     * Autocomplete API
	     * @values geocode, address, regions
	     * @see [Options](https://developers.google.com/maps/documentation/javascript/places-autocomplete#add-autocomplete)
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * To avoid paying for data that you don't need,
	     * be sure to use Autocomplete.setFields() to specify
	     * only the place data that you will use.
	     *
	     * @see [Place information](https://developers.google.com/maps/documentation/javascript/places-autocomplete#get-place-information)
	     * @see [setFields](https://developers.google.com/maps/documentation/javascript/reference/places-widget#Autocomplete.setFields)
	     * @see [PlaceResult](https://developers.google.com/maps/documentation/javascript/reference/places-service#PlaceResult)
	     */
	    setFieldsTo: {
	      required: false,
	      type: Array,
	      "default": null
	    }
	  },
	  watch: {
	    /**
	     * This watcher is incharge to update
	     * the component restrictions when is
	     * changed from the parent
	     */
	    componentRestrictions: function componentRestrictions(v) {
	      if (v !== undefined) {
	        this.$autocomplete.setComponentRestrictions(v);
	      }
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;
	    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
	      var scopedInput, autocompleteOptions;
	      return _regeneratorRuntime().wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return _this.$gmapApiPromiseLazy();
	            case 2:
	              scopedInput = null;
	              if (!_this.$scopedSlots["default"]) {
	                _context.next = 9;
	                break;
	              }
	              if (Object.keys(_this.$scopedSlots["default"]()[0].context.$refs).length) {
	                _context.next = 6;
	                break;
	              }
	              throw new Error('If you use the slot input you must add a ref to the element that you will use as the input, and if you use a vue component, eg: v-text-field, etc, you need to set the childRefName indicating what is the ref name of the html input elemnt behind your component.');
	            case 6:
	              scopedInput = _this.$scopedSlots["default"]()[0].context.$refs[_this.slotRefName];
	              if (scopedInput && scopedInput.$refs) {
	                scopedInput = scopedInput.$refs[_this.childRefName];
	              }
	              if (scopedInput) {
	                _this.$refs.input = scopedInput;
	              }
	            case 9:
	              if (_this.selectFirstOnEnter) {
	                downArrowSimulator(_this.$refs.input);
	              }
	              if (!(typeof google.maps.places.Autocomplete !== 'function')) {
	                _context.next = 12;
	                break;
	              }
	              throw new Error("google.maps.places.Autocomplete is undefined. Did you add 'places' to libraries when loading Google Maps?");
	            case 12:
	              autocompleteOptions = _extends({}, getPropsValues(_this, autocompleteMappedProps), _this.options);
	              _this.$autocomplete = new google.maps.places.Autocomplete(_this.$refs.input, autocompleteOptions);
	              bindProps(_this, _this.$autocomplete, autocompleteMappedProps);
	              if (_this.setFieldsTo) {
	                _this.$autocomplete.setFields(_this.setFieldsTo);
	              }

	              // Not using `bindEvents` because we also want
	              // to return the result of `getPlace()`
	              _this.$autocomplete.addListener('place_changed', function () {
	                /**
	                 * Place change event
	                 * @event place_changed
	                 * @property {object} place `this.$autocomplete.getPlace()`
	                 * @see [Get place information](https://developers.google.com/maps/documentation/javascript/places-autocomplete#get-place-information)
	                 */
	                _this.$emit('place_changed', _this.$autocomplete.getPlace());
	              });
	            case 17:
	            case "end":
	              return _context.stop();
	          }
	        }
	      }, _callee);
	    }))();
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$$autocomplete && this.$$autocomplete.setMap) {
	      this.$$autocomplete.setMap(null);
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	/* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  } // Vue.extend constructor export interop.

	  var options = typeof script === 'function' ? script.options : script; // render functions

	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true; // functional template

	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  } // scopedId

	  if (scopeId) {
	    options._scopeId = scopeId;
	  }
	  var hook;
	  if (moduleIdentifier) {
	    // server build
	    hook = function hook(context) {
	      // 2.3 injection
	      context = context ||
	      // cached call
	      this.$vnode && this.$vnode.ssrContext ||
	      // stateful
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
	      // 2.2 with runInNewContext: true

	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      } // inject component styles

	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      } // register component module identifier for async chunk inference

	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    }; // used by ssr in case component is cached and beforeCreate
	    // never gets called

	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function (context) {
	      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }
	  if (hook) {
	    if (options.functional) {
	      // register for functional component in vue file
	      var originalRender = options.render;
	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      // inject component registration as beforeCreate hook
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }
	  return script;
	}

	/* script */
	var __vue_script__ = script;

	/* template */
	var __vue_render__ = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('div', [_vm._t("default", function () {
	    return [_c('input', _vm._g(_vm._b({
	      ref: "input"
	    }, 'input', _vm.$attrs, false), _vm.$listeners))];
	  }, {
	    "attrs": _vm.$attrs,
	    "listeners": _vm.$listeners
	  })], 2);
	};
	var __vue_staticRenderFns__ = [];

	/* style */
	var __vue_inject_styles__ = undefined;
	/* scoped */
	var __vue_scope_id__ = undefined;
	/* module identifier */
	var __vue_module_identifier__ = undefined;
	/* functional template */
	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	/**
	 * @class MapElementMixin
	 *
	 * Add a inject object to inject $mapPromise and a provide function to the
	 * component this function save the returned Google Maps object in the $map
	 * property after the $mapPromise is resolved.
	 *
	 * ## The mixin code:
	 * ```js
	  export default {
	    inject: {
	      $mapPromise: { default: 'abcdef' },
	    },
	    provide() {
	      this.$mapPromise.then((map) => {
	        this.$map = map;
	      });

	      return {};
	    },
	  };
	 * ```
	 *
	 * @property $mapPromise - The map property that should return the `$map`.<br>
	 *           **Note**: although this mixin is not "providing" anything,
	 *           components' expect the `$map` property to be present on the component.
	 *           In order for that to happen, this mixin must intercept the `$mapPromise
	 *           .then(() => {})` first before its component does so.
	 *
	 *           Since a `provide()` on a mixin is executed before a `provide()` on the
	 *           component, putting this code in `provide()` ensures that the `$map` is
	 *           already set by the time the component's `provide()` is called.
	 * @property $map - The Google map (valid only after the promise (`$mapPromise`) returns)
	 */
	var mapElementMixin = {
	  inject: {
	    $mapPromise: {
	      "default": 'abcdef'
	    }
	  },
	  provide: function provide() {
	    var _this = this;

	    /**
	     * **Note**: although this mixin is not "providing" anything,
	     * components' expect the `$map` property to be present on the component.
	     * In order for that to happen, this mixin must intercept the `$mapPromise
	     * .then(() => {})` first before its component does so.
	     *
	     * Since a `provide()` on a mixin is executed before a `provide()` on the
	     * component, putting this code in `provide()` ensures that the `$map` is
	     * already set by the time the component's `provide()` is called.
	     */
	    this.$mapPromise.then(function (map) {
	      _this.$map = map;
	    });
	    return {};
	  }
	};

	var _excluded$5 = ["options"];

	/**
	 * Circle component
	 * @displayName GmapCircle
	 * @see [source code](/guide/circle.html#source-code)
	 * @see [official reference](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#Circle)
	 */
	var script$1 = {
	  name: 'CircleShape',
	  mixins: [mapElementMixin],
	  render: function render() {
	    return '';
	  },
	  provide: function provide() {
	    var _this = this;
	    // events to bind with toWay
	    var events = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, circleMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$5);
	      _this.$circleObject = new google.maps.Circle(finalOptions);
	      bindProps(_this, _this.$circleObject, circleMappedProps);
	      bindEvents(_this, _this.$circleObject, events);
	      return _this.$circleObject;
	    })["catch"](function (error) {
	      throw error;
	    });

	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$circlePromise = promise;
	    return {
	      $circlePromise: promise
	    };
	  },
	  props: {
	    /**
	     * The center of the Circle.
	     * @value { lat: 41.878, lng: -87.629 }
	     * @see [Circle simple](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.center)
	     */
	    center: {
	      type: Object,
	      required: true
	    },
	    /**
	     * The radius in meters on the Earth's surface.
	     * @value 10
	     * @see [Circle simple](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.radius)
	     */
	    radius: {
	      type: Number,
	      "default": 10
	    },
	    /**
	     * Indicates whether this Polygon handles mouse events. Defaults to true.
	     * @value true, false
	     * @see [Circle draggable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.clickable)
	     */
	    clickable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * If set to true, the user can drag this circle over the map. Defaults to false.
	     * @value true, false
	     * @see [Circle simple](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.draggable)
	     */
	    draggable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * If set to true, the user can edit this circle by dragging the control points shown at the center and around the circumference of the circle. Defaults to false.
	     * @value true, false
	     * @see [Circle simple](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.editable)
	     */
	    editable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * The fill color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.fillColor)
	     */
	    fillColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The fill opacity between 0.0 and 1.0
	     * @value 1
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.fillOpacity)
	     */
	    fillOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.strokeColor)
	     */
	    strokeColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The stroke opacity between 0.0 and 1.0.
	     * @value 1
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.strokeOpacity)
	     */
	    strokeOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke position. Defaults to CENTER.
	     * @value 1
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.strokePosition)
	     * @see [StrokePosition constant](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#StrokePosition)
	     */
	    strokePosition: {
	      type: Number,
	      "default": 0
	    },
	    /**
	     * The stroke width in pixels.
	     * @value 1
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.strokeWeight)
	     */
	    strokeWeight: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * Whether this polyline is visible on the map. Defaults to true.
	     * @value 1
	     * @see [Circle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#CircleOptions.visible)
	     */
	    visible: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * The Google Maps circle options
	     * @value {
	        strokeColor: "#FF0000",
	        strokeOpacity: 0.8,
	        strokeWeight: 2,
	        fillColor: "#FF0000",
	        fillOpacity: 0.35,
	        map,
	        center: citymap[city].center,
	        radius: Math.sqrt(citymap[city].population) * 100,
	      }
	     * @see [Circle simple](https://developers.google.com/maps/documentation/javascript/examples/circle-simple)
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$circleObject && this.$circleObject.setMap) {
	      this.$circleObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;

	/* template */

	/* style */
	var __vue_inject_styles__$1 = undefined;
	/* scoped */
	var __vue_scope_id__$1 = undefined;
	/* module identifier */
	var __vue_module_identifier__$1 = undefined;
	/* functional template */
	var __vue_is_functional_template__$1 = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$1 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

	function sortKD(ids, coords, nodeSize, left, right, depth) {
	  if (right - left <= nodeSize) return;
	  var m = left + right >> 1;
	  select(ids, coords, m, left, right, depth % 2);
	  sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
	  sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
	}
	function select(ids, coords, k, left, right, inc) {
	  while (right > left) {
	    if (right - left > 600) {
	      var n = right - left + 1;
	      var m = k - left + 1;
	      var z = Math.log(n);
	      var s = 0.5 * Math.exp(2 * z / 3);
	      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
	      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
	      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
	      select(ids, coords, k, newLeft, newRight, inc);
	    }
	    var t = coords[2 * k + inc];
	    var i = left;
	    var j = right;
	    swapItem(ids, coords, left, k);
	    if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);
	    while (i < j) {
	      swapItem(ids, coords, i, j);
	      i++;
	      j--;
	      while (coords[2 * i + inc] < t) {
	        i++;
	      }
	      while (coords[2 * j + inc] > t) {
	        j--;
	      }
	    }
	    if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);else {
	      j++;
	      swapItem(ids, coords, j, right);
	    }
	    if (j <= k) left = j + 1;
	    if (k <= j) right = j - 1;
	  }
	}
	function swapItem(ids, coords, i, j) {
	  swap(ids, i, j);
	  swap(coords, 2 * i, 2 * j);
	  swap(coords, 2 * i + 1, 2 * j + 1);
	}
	function swap(arr, i, j) {
	  var tmp = arr[i];
	  arr[i] = arr[j];
	  arr[j] = tmp;
	}

	function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
	  var stack = [0, ids.length - 1, 0];
	  var result = [];
	  var x, y;
	  while (stack.length) {
	    var axis = stack.pop();
	    var right = stack.pop();
	    var left = stack.pop();
	    if (right - left <= nodeSize) {
	      for (var i = left; i <= right; i++) {
	        x = coords[2 * i];
	        y = coords[2 * i + 1];
	        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
	      }
	      continue;
	    }
	    var m = Math.floor((left + right) / 2);
	    x = coords[2 * m];
	    y = coords[2 * m + 1];
	    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);
	    var nextAxis = (axis + 1) % 2;
	    if (axis === 0 ? minX <= x : minY <= y) {
	      stack.push(left);
	      stack.push(m - 1);
	      stack.push(nextAxis);
	    }
	    if (axis === 0 ? maxX >= x : maxY >= y) {
	      stack.push(m + 1);
	      stack.push(right);
	      stack.push(nextAxis);
	    }
	  }
	  return result;
	}

	function within(ids, coords, qx, qy, r, nodeSize) {
	  var stack = [0, ids.length - 1, 0];
	  var result = [];
	  var r2 = r * r;
	  while (stack.length) {
	    var axis = stack.pop();
	    var right = stack.pop();
	    var left = stack.pop();
	    if (right - left <= nodeSize) {
	      for (var i = left; i <= right; i++) {
	        if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
	      }
	      continue;
	    }
	    var m = Math.floor((left + right) / 2);
	    var x = coords[2 * m];
	    var y = coords[2 * m + 1];
	    if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);
	    var nextAxis = (axis + 1) % 2;
	    if (axis === 0 ? qx - r <= x : qy - r <= y) {
	      stack.push(left);
	      stack.push(m - 1);
	      stack.push(nextAxis);
	    }
	    if (axis === 0 ? qx + r >= x : qy + r >= y) {
	      stack.push(m + 1);
	      stack.push(right);
	      stack.push(nextAxis);
	    }
	  }
	  return result;
	}
	function sqDist(ax, ay, bx, by) {
	  var dx = ax - bx;
	  var dy = ay - by;
	  return dx * dx + dy * dy;
	}

	var defaultGetX = function defaultGetX(p) {
	  return p[0];
	};
	var defaultGetY = function defaultGetY(p) {
	  return p[1];
	};
	var KDBush = /*#__PURE__*/function () {
	  function KDBush(points, getX, getY, nodeSize, ArrayType) {
	    if (getX === void 0) {
	      getX = defaultGetX;
	    }
	    if (getY === void 0) {
	      getY = defaultGetY;
	    }
	    if (nodeSize === void 0) {
	      nodeSize = 64;
	    }
	    if (ArrayType === void 0) {
	      ArrayType = Float64Array;
	    }
	    this.nodeSize = nodeSize;
	    this.points = points;
	    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;
	    var ids = this.ids = new IndexArrayType(points.length);
	    var coords = this.coords = new ArrayType(points.length * 2);
	    for (var i = 0; i < points.length; i++) {
	      ids[i] = i;
	      coords[2 * i] = getX(points[i]);
	      coords[2 * i + 1] = getY(points[i]);
	    }
	    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
	  }
	  var _proto = KDBush.prototype;
	  _proto.range = function range$1(minX, minY, maxX, maxY) {
	    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
	  };
	  _proto.within = function within$1(x, y, r) {
	    return within(this.ids, this.coords, x, y, r, this.nodeSize);
	  };
	  return KDBush;
	}();

	var defaultOptions = {
	  minZoom: 0,
	  // min zoom to generate clusters on
	  maxZoom: 16,
	  // max zoom level to cluster the points on
	  minPoints: 2,
	  // minimum points to form a cluster
	  radius: 40,
	  // cluster radius in pixels
	  extent: 512,
	  // tile extent (radius is calculated relative to it)
	  nodeSize: 64,
	  // size of the KD-tree leaf node, affects performance
	  log: false,
	  // whether to log timing info
	  // whether to generate numeric ids for input features (in vector tiles)
	  generateId: false,
	  // a reduce function for calculating custom cluster properties
	  reduce: null,
	  // (accumulated, props) => { accumulated.sum += props.sum; }
	  // properties to use for individual points when running the reducer
	  map: function map(props) {
	    return props;
	  } // props => ({sum: props.my_value})
	};

	var fround = Math.fround || function (tmp) {
	  return function (x) {
	    tmp[0] = +x;
	    return tmp[0];
	  };
	}(new Float32Array(1));
	var Supercluster = /*#__PURE__*/function () {
	  function Supercluster(options) {
	    this.options = extend(Object.create(defaultOptions), options);
	    this.trees = new Array(this.options.maxZoom + 1);
	  }
	  var _proto = Supercluster.prototype;
	  _proto.load = function load(points) {
	    var _this$options = this.options,
	      log = _this$options.log,
	      minZoom = _this$options.minZoom,
	      maxZoom = _this$options.maxZoom,
	      nodeSize = _this$options.nodeSize;
	    if (log) console.time('total time');
	    var timerId = "prepare " + points.length + " points";
	    if (log) console.time(timerId);
	    this.points = points; // generate a cluster object for each point and index input points into a KD-tree

	    var clusters = [];
	    for (var i = 0; i < points.length; i++) {
	      if (!points[i].geometry) continue;
	      clusters.push(createPointCluster(points[i], i));
	    }
	    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
	    if (log) console.timeEnd(timerId); // cluster points on max zoom, then cluster the results on previous zoom, etc.;
	    // results in a cluster hierarchy across zoom levels

	    for (var z = maxZoom; z >= minZoom; z--) {
	      var now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree

	      clusters = this._cluster(clusters, z);
	      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
	      if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
	    }
	    if (log) console.timeEnd('total time');
	    return this;
	  };
	  _proto.getClusters = function getClusters(bbox, zoom) {
	    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
	    var minLat = Math.max(-90, Math.min(90, bbox[1]));
	    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
	    var maxLat = Math.max(-90, Math.min(90, bbox[3]));
	    if (bbox[2] - bbox[0] >= 360) {
	      minLng = -180;
	      maxLng = 180;
	    } else if (minLng > maxLng) {
	      var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
	      var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
	      return easternHem.concat(westernHem);
	    }
	    var tree = this.trees[this._limitZoom(zoom)];
	    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
	    var clusters = [];
	    for (var _iterator = _createForOfIteratorHelperLoose(ids), _step; !(_step = _iterator()).done;) {
	      var id = _step.value;
	      var c = tree.points[id];
	      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
	    }
	    return clusters;
	  };
	  _proto.getChildren = function getChildren(clusterId) {
	    var originId = this._getOriginId(clusterId);
	    var originZoom = this._getOriginZoom(clusterId);
	    var errorMsg = 'No cluster with the specified id.';
	    var index = this.trees[originZoom];
	    if (!index) throw new Error(errorMsg);
	    var origin = index.points[originId];
	    if (!origin) throw new Error(errorMsg);
	    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
	    var ids = index.within(origin.x, origin.y, r);
	    var children = [];
	    for (var _iterator2 = _createForOfIteratorHelperLoose(ids), _step2; !(_step2 = _iterator2()).done;) {
	      var id = _step2.value;
	      var c = index.points[id];
	      if (c.parentId === clusterId) {
	        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
	      }
	    }
	    if (children.length === 0) throw new Error(errorMsg);
	    return children;
	  };
	  _proto.getLeaves = function getLeaves(clusterId, limit, offset) {
	    limit = limit || 10;
	    offset = offset || 0;
	    var leaves = [];
	    this._appendLeaves(leaves, clusterId, limit, offset, 0);
	    return leaves;
	  };
	  _proto.getTile = function getTile(z, x, y) {
	    var tree = this.trees[this._limitZoom(z)];
	    var z2 = Math.pow(2, z);
	    var _this$options2 = this.options,
	      extent = _this$options2.extent,
	      radius = _this$options2.radius;
	    var p = radius / extent;
	    var top = (y - p) / z2;
	    var bottom = (y + 1 + p) / z2;
	    var tile = {
	      features: []
	    };
	    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);
	    if (x === 0) {
	      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);
	    }
	    if (x === z2 - 1) {
	      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);
	    }
	    return tile.features.length ? tile : null;
	  };
	  _proto.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId) {
	    var expansionZoom = this._getOriginZoom(clusterId) - 1;
	    while (expansionZoom <= this.options.maxZoom) {
	      var children = this.getChildren(clusterId);
	      expansionZoom++;
	      if (children.length !== 1) break;
	      clusterId = children[0].properties.cluster_id;
	    }
	    return expansionZoom;
	  };
	  _proto._appendLeaves = function _appendLeaves(result, clusterId, limit, offset, skipped) {
	    var children = this.getChildren(clusterId);
	    for (var _iterator3 = _createForOfIteratorHelperLoose(children), _step3; !(_step3 = _iterator3()).done;) {
	      var child = _step3.value;
	      var props = child.properties;
	      if (props && props.cluster) {
	        if (skipped + props.point_count <= offset) {
	          // skip the whole cluster
	          skipped += props.point_count;
	        } else {
	          // enter the cluster
	          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster
	        }
	      } else if (skipped < offset) {
	        // skip a single point
	        skipped++;
	      } else {
	        // add a single point
	        result.push(child);
	      }
	      if (result.length === limit) break;
	    }
	    return skipped;
	  };
	  _proto._addTileFeatures = function _addTileFeatures(ids, points, x, y, z2, tile) {
	    for (var _iterator4 = _createForOfIteratorHelperLoose(ids), _step4; !(_step4 = _iterator4()).done;) {
	      var i = _step4.value;
	      var c = points[i];
	      var isCluster = c.numPoints;
	      var tags = void 0,
	        px = void 0,
	        py = void 0;
	      if (isCluster) {
	        tags = getClusterProperties(c);
	        px = c.x;
	        py = c.y;
	      } else {
	        var p = this.points[c.index];
	        tags = p.properties;
	        px = lngX(p.geometry.coordinates[0]);
	        py = latY(p.geometry.coordinates[1]);
	      }
	      var f = {
	        type: 1,
	        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],
	        tags: tags
	      }; // assign id

	      var id = void 0;
	      if (isCluster) {
	        id = c.id;
	      } else if (this.options.generateId) {
	        // optionally generate id
	        id = c.index;
	      } else if (this.points[c.index].id) {
	        // keep id if already assigned
	        id = this.points[c.index].id;
	      }
	      if (id !== undefined) f.id = id;
	      tile.features.push(f);
	    }
	  };
	  _proto._limitZoom = function _limitZoom(z) {
	    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));
	  };
	  _proto._cluster = function _cluster(points, zoom) {
	    var clusters = [];
	    var _this$options3 = this.options,
	      radius = _this$options3.radius,
	      extent = _this$options3.extent,
	      reduce = _this$options3.reduce,
	      minPoints = _this$options3.minPoints;
	    var r = radius / (extent * Math.pow(2, zoom)); // loop through each point

	    for (var i = 0; i < points.length; i++) {
	      var p = points[i]; // if we've already visited the point at this zoom level, skip it

	      if (p.zoom <= zoom) continue;
	      p.zoom = zoom; // find all nearby points

	      var tree = this.trees[zoom + 1];
	      var neighborIds = tree.within(p.x, p.y, r);
	      var numPointsOrigin = p.numPoints || 1;
	      var numPoints = numPointsOrigin; // count the number of points in a potential cluster

	      for (var _iterator5 = _createForOfIteratorHelperLoose(neighborIds), _step5; !(_step5 = _iterator5()).done;) {
	        var _neighborId2 = _step5.value;
	        var _b2 = tree.points[_neighborId2]; // filter out neighbors that are already processed

	        if (_b2.zoom > zoom) numPoints += _b2.numPoints || 1;
	      } // if there were neighbors to merge, and there are enough points to form a cluster

	      if (numPoints > numPointsOrigin && numPoints >= minPoints) {
	        var wx = p.x * numPointsOrigin;
	        var wy = p.y * numPointsOrigin;
	        var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features

	        var id = (i << 5) + (zoom + 1) + this.points.length;
	        for (var _iterator6 = _createForOfIteratorHelperLoose(neighborIds), _step6; !(_step6 = _iterator6()).done;) {
	          var neighborId = _step6.value;
	          var b = tree.points[neighborId];
	          if (b.zoom <= zoom) continue;
	          b.zoom = zoom; // save the zoom (so it doesn't get processed twice)

	          var numPoints2 = b.numPoints || 1;
	          wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center

	          wy += b.y * numPoints2;
	          b.parentId = id;
	          if (reduce) {
	            if (!clusterProperties) clusterProperties = this._map(p, true);
	            reduce(clusterProperties, this._map(b));
	          }
	        }
	        p.parentId = id;
	        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));
	      } else {
	        // left points as unclustered
	        clusters.push(p);
	        if (numPoints > 1) {
	          for (var _iterator7 = _createForOfIteratorHelperLoose(neighborIds), _step7; !(_step7 = _iterator7()).done;) {
	            var _neighborId = _step7.value;
	            var _b = tree.points[_neighborId];
	            if (_b.zoom <= zoom) continue;
	            _b.zoom = zoom;
	            clusters.push(_b);
	          }
	        }
	      }
	    }
	    return clusters;
	  } // get index of the point from which the cluster originated
	  ;
	  _proto._getOriginId = function _getOriginId(clusterId) {
	    return clusterId - this.points.length >> 5;
	  } // get zoom of the point from which the cluster originated
	  ;
	  _proto._getOriginZoom = function _getOriginZoom(clusterId) {
	    return (clusterId - this.points.length) % 32;
	  };
	  _proto._map = function _map(point, clone) {
	    if (point.numPoints) {
	      return clone ? extend({}, point.properties) : point.properties;
	    }
	    var original = this.points[point.index].properties;
	    var result = this.options.map(original);
	    return clone && result === original ? extend({}, result) : result;
	  };
	  return Supercluster;
	}();
	function createCluster(x, y, id, numPoints, properties) {
	  return {
	    x: fround(x),
	    // weighted cluster center; round for consistency with Float32Array index
	    y: fround(y),
	    zoom: Infinity,
	    // the last zoom the cluster was processed at
	    id: id,
	    // encodes index of the first child of the cluster and its zoom level
	    parentId: -1,
	    // parent cluster id
	    numPoints: numPoints,
	    properties: properties
	  };
	}
	function createPointCluster(p, id) {
	  var _p$geometry$coordinat = p.geometry.coordinates,
	    x = _p$geometry$coordinat[0],
	    y = _p$geometry$coordinat[1];
	  return {
	    x: fround(lngX(x)),
	    // projected point coordinates
	    y: fround(latY(y)),
	    zoom: Infinity,
	    // the last zoom the point was processed at
	    index: id,
	    // index of the source feature in the original input array,
	    parentId: -1 // parent cluster id
	  };
	}

	function getClusterJSON(cluster) {
	  return {
	    type: 'Feature',
	    id: cluster.id,
	    properties: getClusterProperties(cluster),
	    geometry: {
	      type: 'Point',
	      coordinates: [xLng(cluster.x), yLat(cluster.y)]
	    }
	  };
	}
	function getClusterProperties(cluster) {
	  var count = cluster.numPoints;
	  var abbrev = count >= 10000 ? Math.round(count / 1000) + "k" : count >= 1000 ? Math.round(count / 100) / 10 + "k" : count;
	  return extend(extend({}, cluster.properties), {
	    cluster: true,
	    cluster_id: cluster.id,
	    point_count: count,
	    point_count_abbreviated: abbrev
	  });
	} // longitude/latitude to spherical mercator in [0..1] range

	function lngX(lng) {
	  return lng / 360 + 0.5;
	}
	function latY(lat) {
	  var sin = Math.sin(lat * Math.PI / 180);
	  var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
	  return y < 0 ? 0 : y > 1 ? 1 : y;
	} // spherical mercator to longitude/latitude

	function xLng(x) {
	  return (x - 0.5) * 360;
	}
	function yLat(y) {
	  var y2 = (180 - y * 360) * Math.PI / 180;
	  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
	}
	function extend(dest, src) {
	  for (var id in src) {
	    dest[id] = src[id];
	  }
	  return dest;
	}
	function getX(p) {
	  return p.x;
	}
	function getY(p) {
	  return p.y;
	}

	var fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;
	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;
	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;) {
	        if (!equal(a[i], b[i])) return false;
	      }
	      return true;
	    }
	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;
	    for (i = length; i-- !== 0;) {
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
	    }
	    for (i = length; i-- !== 0;) {
	      var key = keys[i];
	      if (!equal(a[key], b[key])) return false;
	    }
	    return true;
	  } // true if both NaN, false otherwise

	  return a !== a && b !== b;
	};

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	function __rest(s, e) {
	  var t = {};
	  for (var p in s) {
	    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	  }
	  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	  }
	  return t;
	}
	/**
	 * Copyright 2021 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var Cluster = /*#__PURE__*/function () {
	  function Cluster(_ref) {
	    var markers = _ref.markers,
	      position = _ref.position;
	    this.markers = markers;
	    if (position) {
	      if (position instanceof google.maps.LatLng) {
	        this._position = position;
	      } else {
	        this._position = new google.maps.LatLng(position);
	      }
	    }
	  }
	  var _proto = Cluster.prototype;
	  /**
	   * Add a marker to the cluster.
	   */
	  _proto.push = function push(marker) {
	    this.markers.push(marker);
	  }
	  /**
	   * Cleanup references and remove marker from map.
	   */;
	  _proto["delete"] = function _delete() {
	    if (this.marker) {
	      this.marker.setMap(null);
	      delete this.marker;
	    }
	    this.markers.length = 0;
	  };
	  _createClass(Cluster, [{
	    key: "bounds",
	    get: function get() {
	      if (this.markers.length === 0 && !this._position) {
	        return undefined;
	      }
	      return this.markers.reduce(function (bounds, marker) {
	        return bounds.extend(marker.getPosition());
	      }, new google.maps.LatLngBounds(this._position, this._position));
	    }
	  }, {
	    key: "position",
	    get: function get() {
	      return this._position || this.bounds.getCenter();
	    }
	    /**
	     * Get the count of **visible** markers.
	     */
	  }, {
	    key: "count",
	    get: function get() {
	      return this.markers.filter(function (m) {
	        return m.getVisible();
	      }).length;
	    }
	  }]);
	  return Cluster;
	}();
	/**
	 * Copyright 2021 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * @hidden
	 */
	var AbstractAlgorithm = /*#__PURE__*/function () {
	  function AbstractAlgorithm(_ref2) {
	    var _ref2$maxZoom = _ref2.maxZoom,
	      maxZoom = _ref2$maxZoom === void 0 ? 16 : _ref2$maxZoom;
	    this.maxZoom = maxZoom;
	  }
	  /**
	   * Helper function to bypass clustering based upon some map state such as
	   * zoom, number of markers, etc.
	   *
	   * ```typescript
	   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
	   *    if (shouldBypassClustering(map)) {
	   *      return this.noop({markers, map})
	   *    }
	   * }
	   * ```
	   */
	  var _proto2 = AbstractAlgorithm.prototype;
	  _proto2.noop = function noop(_ref3) {
	    var markers = _ref3.markers;
	    return _noop(markers);
	  };
	  return AbstractAlgorithm;
	}();
	/**
	 * @hidden
	 */
	var _noop = function _noop(markers) {
	  var clusters = markers.map(function (marker) {
	    return new Cluster({
	      position: marker.getPosition(),
	      markers: [marker]
	    });
	  });
	  return clusters;
	};
	/**
	 * Copyright 2021 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * A very fast JavaScript algorithm for geospatial point clustering using KD trees.
	 *
	 * @see https://www.npmjs.com/package/supercluster for more information on options.
	 */
	var SuperClusterAlgorithm = /*#__PURE__*/function (_AbstractAlgorithm) {
	  _inheritsLoose(SuperClusterAlgorithm, _AbstractAlgorithm);
	  function SuperClusterAlgorithm(_a) {
	    var _this;
	    var maxZoom = _a.maxZoom,
	      _a$radius = _a.radius,
	      radius = _a$radius === void 0 ? 60 : _a$radius,
	      options = __rest(_a, ["maxZoom", "radius"]);
	    _this = _AbstractAlgorithm.call(this, {
	      maxZoom: maxZoom
	    }) || this;
	    _this.superCluster = new Supercluster(Object.assign({
	      maxZoom: _this.maxZoom,
	      radius: radius
	    }, options));
	    _this.state = {
	      zoom: null
	    };
	    return _this;
	  }
	  var _proto3 = SuperClusterAlgorithm.prototype;
	  _proto3.calculate = function calculate(input) {
	    var changed = false;
	    if (!fastDeepEqual(input.markers, this.markers)) {
	      changed = true; // TODO use proxy to avoid copy?

	      this.markers = [].concat(input.markers);
	      var points = this.markers.map(function (marker) {
	        return {
	          type: "Feature",
	          geometry: {
	            type: "Point",
	            coordinates: [marker.getPosition().lng(), marker.getPosition().lat()]
	          },
	          properties: {
	            marker: marker
	          }
	        };
	      });
	      this.superCluster.load(points);
	    }
	    var state = {
	      zoom: input.map.getZoom()
	    };
	    if (!changed) {
	      if (this.state.zoom > this.maxZoom && state.zoom > this.maxZoom) ;else {
	        changed = changed || !fastDeepEqual(this.state, state);
	      }
	    }
	    this.state = state;
	    if (changed) {
	      this.clusters = this.cluster(input);
	    }
	    return {
	      clusters: this.clusters,
	      changed: changed
	    };
	  };
	  _proto3.cluster = function cluster(_ref4) {
	    var map = _ref4.map;
	    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(map.getZoom())).map(this.transformCluster.bind(this));
	  };
	  _proto3.transformCluster = function transformCluster(_ref5) {
	    var _ref5$geometry$coordi = _ref5.geometry.coordinates,
	      lng = _ref5$geometry$coordi[0],
	      lat = _ref5$geometry$coordi[1],
	      properties = _ref5.properties;
	    if (properties.cluster) {
	      return new Cluster({
	        markers: this.superCluster.getLeaves(properties.cluster_id, Infinity).map(function (leaf) {
	          return leaf.properties.marker;
	        }),
	        position: new google.maps.LatLng({
	          lat: lat,
	          lng: lng
	        })
	      });
	    } else {
	      var marker = properties.marker;
	      return new Cluster({
	        markers: [marker],
	        position: marker.getPosition()
	      });
	    }
	  };
	  return SuperClusterAlgorithm;
	}(AbstractAlgorithm);
	/**
	 * Copyright 2021 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.
	 */
	var ClusterStats = function ClusterStats(markers, clusters) {
	  this.markers = {
	    sum: markers.length
	  };
	  var clusterMarkerCounts = clusters.map(function (a) {
	    return a.count;
	  });
	  var clusterMarkerSum = clusterMarkerCounts.reduce(function (a, b) {
	    return a + b;
	  }, 0);
	  this.clusters = {
	    count: clusters.length,
	    markers: {
	      mean: clusterMarkerSum / clusters.length,
	      sum: clusterMarkerSum,
	      min: Math.min.apply(Math, clusterMarkerCounts),
	      max: Math.max.apply(Math, clusterMarkerCounts)
	    }
	  };
	};
	var DefaultRenderer = /*#__PURE__*/function () {
	  function DefaultRenderer() {}
	  var _proto4 = DefaultRenderer.prototype;
	  /**
	   * The default render function for the library used by {@link MarkerClusterer}.
	   *
	   * Currently set to use the following:
	   *
	   * ```typescript
	   * // change color if this cluster has more markers than the mean cluster
	   * const color =
	   *   count > Math.max(10, stats.clusters.markers.mean)
	   *     ? "#ff0000"
	   *     : "#0000ff";
	   *
	   * // create svg url with fill color
	   * const svg = window.btoa(`
	   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
	   *   <circle cx="120" cy="120" opacity=".6" r="70" />
	   *   <circle cx="120" cy="120" opacity=".3" r="90" />
	   *   <circle cx="120" cy="120" opacity=".2" r="110" />
	   *   <circle cx="120" cy="120" opacity=".1" r="130" />
	   * </svg>`);
	   *
	   * // create marker using svg icon
	   * return new google.maps.Marker({
	   *   position,
	   *   icon: {
	   *     url: `data:image/svg+xml;base64,${svg}`,
	   *     scaledSize: new google.maps.Size(45, 45),
	   *   },
	   *   label: {
	   *     text: String(count),
	   *     color: "rgba(255,255,255,0.9)",
	   *     fontSize: "12px",
	   *   },
	   *   // adjust zIndex to be above other markers
	   *   zIndex: 1000 + count,
	   * });
	   * ```
	   */
	  _proto4.render = function render(_ref6, stats) {
	    var count = _ref6.count,
	      position = _ref6.position;
	    // change color if this cluster has more markers than the mean cluster
	    var color = count > Math.max(10, stats.clusters.markers.mean) ? "#ff0000" : "#0000ff"; // create svg url with fill color

	    var svg = window.btoa("\n  <svg fill=\"" + color + "\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n  </svg>"); // create marker using svg icon

	    return new google.maps.Marker({
	      position: position,
	      icon: {
	        url: "data:image/svg+xml;base64," + svg,
	        scaledSize: new google.maps.Size(45, 45)
	      },
	      label: {
	        text: String(count),
	        color: "rgba(255,255,255,0.9)",
	        fontSize: "12px"
	      },
	      title: "Cluster of " + count + " markers",
	      // adjust zIndex to be above other markers
	      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count
	    });
	  };
	  return DefaultRenderer;
	}();
	/**
	 * Copyright 2019 Google LLC. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * Extends an object's prototype by another's.
	 *
	 * @param type1 The Type to be extended.
	 * @param type2 The Type to extend with.
	 * @ignore
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function extend$1(type1, type2) {
	  /* istanbul ignore next */
	  // eslint-disable-next-line prefer-const
	  for (var property in type2.prototype) {
	    type1.prototype[property] = type2.prototype[property];
	  }
	}
	/**
	 * @ignore
	 */
	var OverlayViewSafe = function OverlayViewSafe() {
	  // MarkerClusterer implements google.maps.OverlayView interface. We use the
	  // extend function to extend MarkerClusterer with google.maps.OverlayView
	  // because it might not always be available when the code is defined so we
	  // look for it at the last possible moment. If it doesn't exist now then
	  // there is no point going ahead :)
	  extend$1(OverlayViewSafe, google.maps.OverlayView);
	};
	/**
	 * Copyright 2021 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var MarkerClustererEvents;
	(function (MarkerClustererEvents) {
	  MarkerClustererEvents["CLUSTERING_BEGIN"] = "clusteringbegin";
	  MarkerClustererEvents["CLUSTERING_END"] = "clusteringend";
	  MarkerClustererEvents["CLUSTER_CLICK"] = "click";
	})(MarkerClustererEvents || (MarkerClustererEvents = {}));
	var defaultOnClusterClickHandler = function defaultOnClusterClickHandler(_, cluster, map) {
	  map.fitBounds(cluster.bounds);
	};
	/**
	 * MarkerClusterer creates and manages per-zoom-level clusters for large amounts
	 * of markers. See {@link MarkerClustererOptions} for more details.
	 *
	 */
	var MarkerClusterer = /*#__PURE__*/function (_OverlayViewSafe) {
	  _inheritsLoose(MarkerClusterer, _OverlayViewSafe);
	  function MarkerClusterer(_ref7) {
	    var _this2;
	    var map = _ref7.map,
	      _ref7$markers = _ref7.markers,
	      markers = _ref7$markers === void 0 ? [] : _ref7$markers,
	      _ref7$algorithm = _ref7.algorithm,
	      algorithm = _ref7$algorithm === void 0 ? new SuperClusterAlgorithm({}) : _ref7$algorithm,
	      _ref7$renderer = _ref7.renderer,
	      renderer = _ref7$renderer === void 0 ? new DefaultRenderer() : _ref7$renderer,
	      _ref7$onClusterClick = _ref7.onClusterClick,
	      onClusterClick = _ref7$onClusterClick === void 0 ? defaultOnClusterClickHandler : _ref7$onClusterClick;
	    _this2 = _OverlayViewSafe.call(this) || this;
	    _this2.markers = [].concat(markers);
	    _this2.clusters = [];
	    _this2.algorithm = algorithm;
	    _this2.renderer = renderer;
	    _this2.onClusterClick = onClusterClick;
	    if (map) {
	      _this2.setMap(map);
	    }
	    return _this2;
	  }
	  var _proto5 = MarkerClusterer.prototype;
	  _proto5.addMarker = function addMarker(marker, noDraw) {
	    if (this.markers.includes(marker)) {
	      return;
	    }
	    this.markers.push(marker);
	    if (!noDraw) {
	      this.render();
	    }
	  };
	  _proto5.addMarkers = function addMarkers(markers, noDraw) {
	    var _this3 = this;
	    markers.forEach(function (marker) {
	      _this3.addMarker(marker, true);
	    });
	    if (!noDraw) {
	      this.render();
	    }
	  };
	  _proto5.removeMarker = function removeMarker(marker, noDraw) {
	    var index = this.markers.indexOf(marker);
	    if (index === -1) {
	      // Marker is not in our list of markers, so do nothing:
	      return false;
	    }
	    marker.setMap(null);
	    this.markers.splice(index, 1); // Remove the marker from the list of managed markers

	    if (!noDraw) {
	      this.render();
	    }
	    return true;
	  };
	  _proto5.removeMarkers = function removeMarkers(markers, noDraw) {
	    var _this4 = this;
	    var removed = false;
	    markers.forEach(function (marker) {
	      removed = _this4.removeMarker(marker, true) || removed;
	    });
	    if (removed && !noDraw) {
	      this.render();
	    }
	    return removed;
	  };
	  _proto5.clearMarkers = function clearMarkers(noDraw) {
	    this.markers.length = 0;
	    if (!noDraw) {
	      this.render();
	    }
	  }
	  /**
	   * Recalculates and draws all the marker clusters.
	   */;
	  _proto5.render = function render() {
	    var map = this.getMap();
	    if (map instanceof google.maps.Map && this.getProjection()) {
	      google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_BEGIN, this);
	      var _this$algorithm$calcu = this.algorithm.calculate({
	          markers: this.markers,
	          map: map,
	          mapCanvasProjection: this.getProjection()
	        }),
	        clusters = _this$algorithm$calcu.clusters,
	        changed = _this$algorithm$calcu.changed; // allow algorithms to return flag on whether the clusters/markers have changed

	      if (changed || changed == undefined) {
	        // reset visibility of markers and clusters
	        this.reset(); // store new clusters

	        this.clusters = clusters;
	        this.renderClusters();
	      }
	      google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_END, this);
	    }
	  };
	  _proto5.onAdd = function onAdd() {
	    this.idleListener = this.getMap().addListener("idle", this.render.bind(this));
	    this.render();
	  };
	  _proto5.onRemove = function onRemove() {
	    google.maps.event.removeListener(this.idleListener);
	    this.reset();
	  };
	  _proto5.reset = function reset() {
	    this.markers.forEach(function (marker) {
	      return marker.setMap(null);
	    });
	    this.clusters.forEach(function (cluster) {
	      return cluster["delete"]();
	    });
	    this.clusters = [];
	  };
	  _proto5.renderClusters = function renderClusters() {
	    var _this5 = this;
	    // generate stats to pass to renderers
	    var stats = new ClusterStats(this.markers, this.clusters);
	    var map = this.getMap();
	    this.clusters.forEach(function (cluster) {
	      if (cluster.markers.length === 1) {
	        cluster.marker = cluster.markers[0];
	      } else {
	        cluster.marker = _this5.renderer.render(cluster, stats);
	        if (_this5.onClusterClick) {
	          cluster.marker.addListener("click", /* istanbul ignore next */
	          function (event) {
	            google.maps.event.trigger(_this5, MarkerClustererEvents.CLUSTER_CLICK, cluster);
	            _this5.onClusterClick(event, cluster, map);
	          });
	        }
	      }
	      cluster.marker.setMap(map);
	    });
	  };
	  return MarkerClusterer;
	}(OverlayViewSafe);

	var _excluded$6 = ["options"];

	//

	/**
	 * Cluster component
	 * @displayName GmapCluster
	 * @see [source code](/guide/cluster.html#source-code)
	 * @see [Official documentation](https://googlemaps.github.io/js-markerclusterer/modules.html)
	 * @see [Marker clusterer](https://developers.google.com/maps/documentation/javascript/marker-clustering#maps_marker_clustering-javascript)
	 */
	var script$2 = {
	  name: 'ClusterIcon',
	  mixins: [mapElementMixin],
	  provide: function provide() {
	    var _this = this;
	    // events to bind with toWay
	    var events = ['click', 'rightclick', 'dblclick', 'drag', 'dragstart', 'dragend', 'mouseup', 'mousedown', 'mouseover', 'mouseout'];

	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, clusterIconMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$6);
	      if (typeof MarkerClusterer === 'undefined') {
	        throw new Error('MarkerClusterer is not installed! require() it or include it from https://cdnjs.cloudflare.com/ajax/libs/js-marker-clusterer/1.0.0/markerclusterer.js');
	      }
	      var mapInstance = finalOptions.map,
	        markers = finalOptions.markers,
	        algorithm = finalOptions.algorithm,
	        onClusterClick = finalOptions.onClusterClick,
	        renderer = finalOptions.renderer;
	      _this.$clusterObject = new MarkerClusterer({
	        map: mapInstance,
	        markers: markers,
	        algorithm: algorithm,
	        onClusterClick: onClusterClick,
	        renderer: renderer
	      });
	      bindProps(_this, _this.$clusterObject, {});
	      bindEvents(_this, _this.$clusterObject, events);
	      Object.keys({}).forEach(function (prop) {
	        if ({}[prop].twoWay) {
	          _this.$on(prop.toLowerCase() + "_changed", _this.reinsertMarkers);
	        }
	      });
	      return _this.$clusterObject;
	    })["catch"](function (error) {
	      throw error;
	    });

	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$clusterPromise = promise;
	    return {
	      $clusterPromise: promise
	    };
	  },
	  props: {
	    /**
	     * An algorithm to cluster markers. Default is SuperClusterAlgorithm. Must provide a
	     * calculate method accepting AlgorithmInput and returning an array of Cluster.
	     * @values undefined
	     * @see [algorithm](https://googlemaps.github.io/js-markerclusterer/interfaces/MarkerClustererOptions.html#algorithm)
	     */
	    algorithm: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Function to run when the user clicks the cluster.
	     * @values undefined
	     * @see [onClusterClick](https://googlemaps.github.io/js-markerclusterer/interfaces/MarkerClustererOptions.html#onClusterClick)
	     */
	    onClusterClick: {
	      type: Function,
	      "default": undefined
	    },
	    /**
	     * An object that converts a Cluster into a `google.maps.Marker`. Default is DefaultRenderer.
	     * @values undefined
	     * @see [renderer](https://googlemaps.github.io/js-markerclusterer/interfaces/MarkerClustererOptions.html#renderer)
	     */
	    renderer: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Other options that you can pass to the MarkerClusterer
	     * @values undefined
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    var _this2 = this;
	    /* Performance optimization when destroying a large number of markers */
	    this.$children.forEach(function (marker) {
	      if (marker.$clusterObject === _this2.$clusterObject) {
	        marker.$clusterObject = null;
	      }
	    });
	    if (this.$clusterObject) {
	      this.$clusterObject.clearMarkers();
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$clusterObject && this.$clusterObject.setMap) {
	      this.$clusterObject.setMap(null);
	    }
	  },
	  updated: function updated() {
	    if (this.$clusterObject) {
	      this.$clusterObject.render();
	    }
	  },
	  methods: {
	    reinsertMarkers: function reinsertMarkers() {
	      var oldMarkers = [].concat(this.$clusterObject.markers);
	      this.$clusterObject.clearMarkers();
	      this.$clusterObject.addMarkers(oldMarkers);
	    }
	  }
	};

	/* script */
	var __vue_script__$2 = script$2;

	/* template */
	var __vue_render__$1 = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('div', [_vm._t("default")], 2);
	};
	var __vue_staticRenderFns__$1 = [];

	/* style */
	var __vue_inject_styles__$2 = undefined;
	/* scoped */
	var __vue_scope_id__$2 = undefined;
	/* module identifier */
	var __vue_module_identifier__$2 = undefined;
	/* functional template */
	var __vue_is_functional_template__$2 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$2 = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

	var _excluded$7 = ["options"];

	//

	/**
	 * DrawingManager component
	 * @displayName GmapDrawingManager
	 * @see [source code](/guide/drawing-manager.html#source-code)
	 * @see [Official documentation](https://developers.google.com/maps/documentation/javascript/drawinglayer)
	 * @see [Official reference](https://developers.google.com/maps/documentation/javascript/reference/drawing)
	 */
	var script$3 = {
	  name: 'DrawingManager',
	  mixins: [mapElementMixin],
	  provide: function provide() {
	    var _this = this;
	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, drawingManagerMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$7);
	      _this.drawingModes = Object.keys(finalOptions).reduce(function (modes, opt) {
	        var val = opt.split('Options');
	        if (val.length > 1) {
	          modes.push(val[0]);
	        }
	        return modes;
	      }, []);
	      var position = _this.position && google.maps.ControlPosition[_this.position] ? google.maps.ControlPosition[_this.position] : google.maps.ControlPosition.TOP_LEFT;
	      finalOptions.drawingMode = null;
	      finalOptions.drawingControl = !_this.$scopedSlots["default"];
	      finalOptions.drawingControlOptions = {
	        drawingModes: _this.drawingModes,
	        position: position
	      };

	      // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible
	      _this.$drawingManagerObject = new google.maps.drawing.DrawingManager(finalOptions);
	      bindProps(_this, _this.$drawingManagerObject, drawingManagerMappedProps);
	      _this.$drawingManagerObject.addListener('overlaycomplete', function (e) {
	        return _this.addShape(e);
	      });
	      _this.$map.addListener('click', _this.clearSelection);
	      if (_this && _this.finalShapes && _this.finalShapes.length) {
	        _this.drawAll();
	      }
	      return _this.$drawingManagerObject;
	    })["catch"](function (error) {
	      throw error;
	    });

	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$drawingManagerPromise = promise;
	    return {
	      $drawingManagerPromise: promise
	    };
	  },
	  props: {
	    /**
	     * The circle options
	     * @see [circleOptions interface](https://developers.google.com/maps/documentation/javascript/reference/polygon#CircleOptions)
	     */
	    circleOptions: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The marker options
	     * @see [markerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions)
	     */
	    markerOptions: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The polygon options
	     * @see [polygonOptions interface](https://developers.google.com/maps/documentation/javascript/reference/polygon#PolygonOptions)
	     */
	    polygonOptions: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The polyline options
	     * @see [polylineOptions interface](https://developers.google.com/maps/documentation/javascript/reference/polygon#PolylineOptions)
	     */
	    polylineOptions: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The rectangle options
	     * @see [rectangleOptions interface](https://developers.google.com/maps/documentation/javascript/reference/polygon#RectangleOptions)
	     */
	    rectangleOptions: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The position of the toolbar
	     * **Possible values**: `'TOP_CENTER', 'TOP_LEFT', 'TOP_RIGHT', 'LEFT_TOP', 'RIGHT_TOP', 'LEFT_CENTER',
	     * 'RIGHT_CENTER', 'LEFT_BOTTOM', 'RIGHT_BOTTOM', 'BOTTOM_CENTER', 'BOTTOM_LEFT', 'BOTTOM_RIGHT'`
	     */
	    position: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * An array of shapes that you can set to render in the map and saves on it the new shapes that you add.
	     */
	    shapes: {
	      type: Array,
	      required: true
	    }
	  },
	  data: function data() {
	    return {
	      selectedShape: null,
	      drawingModes: [],
	      options: {
	        drawingMode: null,
	        drawingControl: true,
	        drawingControlOptions: {}
	      },
	      finalShapes: []
	    };
	  },
	  watch: {
	    position: function position(_position) {
	      if (this.$drawingManagerObject) {
	        var drawingControlOptions = {
	          position: _position && google.maps.ControlPosition[_position] ? google.maps.ControlPosition[_position] : google.maps.ControlPosition.TOP_LEFT,
	          drawingModes: this.drawingModes
	        };
	        this.$drawingManagerObject.setOptions({
	          drawingControlOptions: drawingControlOptions
	        });
	      }
	    },
	    circleOptions: function circleOptions(_circleOptions) {
	      if (this.$drawingManagerObject) {
	        this.$drawingManagerObject.setOptions({
	          circleOptions: _circleOptions
	        });
	      }
	    },
	    markerOptions: function markerOptions(_markerOptions) {
	      if (this.$drawingManagerObject) {
	        this.$drawingManagerObject.setOptions({
	          markerOptions: _markerOptions
	        });
	      }
	    },
	    polygonOptions: function polygonOptions(_polygonOptions) {
	      if (this.$drawingManagerObject) {
	        this.$drawingManagerObject.setOptions({
	          polygonOptions: _polygonOptions
	        });
	      }
	    },
	    polylineOptions: function polylineOptions(_polylineOptions) {
	      if (this.$drawingManagerObject) {
	        this.$drawingManagerObject.setOptions({
	          polylineOptions: _polylineOptions
	        });
	      }
	    },
	    rectangleOptions: function rectangleOptions(_rectangleOptions) {
	      if (this.$drawingManagerObject) {
	        this.$drawingManagerObject.setOptions({
	          rectangleOptions: _rectangleOptions
	        });
	      }
	    }
	  },
	  mounted: function mounted() {
	    this.finalShapes = [].concat(this.shapes);
	  },
	  destroyed: function destroyed() {
	    this.clearAll();

	    // Note: not all Google Maps components support maps
	    if (this.$drawingManagerObject && this.$drawingManagerObject.setMap) {
	      this.$drawingManagerObject.setMap(null);
	    }
	  },
	  methods: {
	    /**
	     * The setDrawingMode method is binded into the default component slot
	     *
	     * @method setDrawingMode
	     * @param {string} mode - mode - Possible values 'marker', 'circle', 'polygon', 'polyline', 'rectangle', null
	     * @returns {void}
	     * @public
	     */
	    setDrawingMode: function setDrawingMode(mode) {
	      this.$drawingManagerObject.setDrawingMode(mode);
	    },
	    drawAll: function drawAll() {
	      var _this2 = this;
	      var shapeType = {
	        circle: google.maps.Circle,
	        marker: google.maps.Marker,
	        polygon: google.maps.Polygon,
	        polyline: google.maps.Polyline,
	        rectangle: google.maps.Rectangle
	      };
	      var self = this;
	      this.finalShapes.forEach(function (shape) {
	        var shapeDrawing = new shapeType[shape.type](shape.overlay);
	        shapeDrawing.setMap(_this2.$map);
	        shape.overlay = shapeDrawing;
	        google.maps.event.addListener(shapeDrawing, 'click', function () {
	          self.setSelection(shape);
	        });
	      });
	    },
	    clearAll: function clearAll() {
	      this.clearSelection();
	      this.finalShapes.forEach(function (shape) {
	        shape.overlay.setMap(null);
	      });
	    },
	    clearSelection: function clearSelection() {
	      if (this.selectedShape) {
	        this.selectedShape.overlay.set('fillColor', '#777');
	        this.selectedShape.overlay.set('strokeColor', '#999');
	        this.selectedShape.overlay.setEditable(false);
	        this.selectedShape.overlay.setDraggable(false);
	        this.selectedShape = null;
	      }
	    },
	    setSelection: function setSelection(shape) {
	      this.clearSelection();
	      this.selectedShape = shape;
	      shape.overlay.setEditable(true);
	      shape.overlay.setDraggable(true);
	      this.selectedShape.overlay.set('fillColor', '#555');
	      this.selectedShape.overlay.set('strokeColor', '#777');
	    },
	    /**
	     * The deleteSelection method is binded into the default component slot
	     *
	     * @method deleteSelection
	     * @param - It doesn't requires any parameter
	     * @returns {void}
	     * @public
	     */
	    deleteSelection: function deleteSelection() {
	      if (this.selectedShape) {
	        this.selectedShape.overlay.setMap(null);
	        var index = this.finalShapes.indexOf(this.selectedShape);
	        if (index > -1) {
	          this.finalShapes.splice(index, 1);
	        }
	      }
	    },
	    addShape: function addShape(shape) {
	      this.setDrawingMode(null);
	      this.finalShapes.push(shape);

	      /**
	       * update:shapes event
	       * @event update:shapes
	       * @property {array} place `this.finalShapes`
	       */
	      this.$emit('update:shapes', [].concat(this.finalShapes));
	      var self = this;
	      google.maps.event.addListener(shape.overlay, 'click', function () {
	        self.setSelection(shape);
	      });
	      google.maps.event.addListener(shape.overlay, 'rightclick', function () {
	        self.deleteSelection();
	      });
	      this.setSelection(shape);
	    }
	  }
	};

	/* script */
	var __vue_script__$3 = script$3;

	/* template */
	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('div', [_vm._t("default", null, {
	    "setDrawingMode": _vm.setDrawingMode,
	    "deleteSelection": _vm.deleteSelection
	  })], 2);
	};
	var __vue_staticRenderFns__$2 = [];

	/* style */
	var __vue_inject_styles__$3 = undefined;
	/* scoped */
	var __vue_scope_id__$3 = undefined;
	/* module identifier */
	var __vue_module_identifier__$3 = undefined;
	/* functional template */
	var __vue_is_functional_template__$3 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$3 = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

	var _excluded$8 = ["options"];

	/**
	 * HeatmapLayer component
	 * @displayName HeatmapLayer
	 * @see [source code](/guide/heatmap-layer.html#source-code)
	 * @see [Official documentation](https://developers.google.com/maps/documentation/javascript/heatmaplayer)
	 */
	var script$4 = {
	  name: 'HeatmapLayer',
	  mixins: [mapElementMixin],
	  render: function render() {
	    return '';
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = [];

	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: _this.$map
	      }, getPropsValues(_this, heatMapLayerMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$8);
	      _this.$heatmapLayerObject = new google.maps.visualization.HeatmapLayer(finalOptions);
	      bindProps(_this, _this.$heatmapLayerObject, heatMapLayerMappedProps);
	      bindEvents(_this, _this.$heatmapLayerObject, events);
	      return _this.$heatmapLayerObject;
	    })["catch"](function (error) {
	      throw error;
	    });

	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$heatmapLayerPromise = promise;
	    return {
	      $heatmapLayerPromise: promise
	    };
	  },
	  props: {
	    /**
	     * Extra options that you want to pass to the component
	     */
	    options: {
	      type: Object,
	      "default": function _default() {}
	    },
	    /**
	     * The heat map data, is an array of `new google.maps.LatLng`,
	     * @see [heatmap options](https://developers.google.com/maps/documentation/javascript/heatmaplayer#add-a-heatmap-layer)
	     * @example `[new google.maps.LatLng(37.782, -122.447)]`
	     */
	    data: {
	      type: Array,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$heatmapLayerObject && this.$heatmapLayerObject.setMap) {
	      this.$heatmapLayerObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$4 = script$4;

	/* template */

	/* style */
	var __vue_inject_styles__$4 = undefined;
	/* scoped */
	var __vue_scope_id__$4 = undefined;
	/* module identifier */
	var __vue_module_identifier__$4 = undefined;
	/* functional template */
	var __vue_is_functional_template__$4 = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$4 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

	var _excluded$9 = ["options", "position"];

	//

	/**
	 * InfoWindow component
	 * @displayName Info-Window
	 * @see [source code](/guide/info-window.html#source-code)
	 * @see [Official documentation](https://developers.google.com/maps/documentation/javascript/infowindows)
	 * @see [Official reference](https://developers.google.com/maps/documentation/javascript/reference/info-window)
	 */
	var script$5 = {
	  name: 'InfoWindow',
	  mixins: [mapElementMixin],
	  inject: {
	    $markerPromise: {
	      "default": null
	    }
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['domready', 'closeclick', 'content_changed'];

	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, infoWindowMappedProps));
	      var extraOptions = initialOptions.options,
	        position = initialOptions.position,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$9);
	      finalOptions.content = _this.$refs.flyaway;
	      if (_this.$markerPromise) {
	        _this.$markerPromise.then(function (markerObject) {
	          _this.$markerObject = markerObject;
	          return markerObject;
	        });
	      }
	      _this.$infoWindowObject = new google.maps.InfoWindow(finalOptions);
	      bindProps(_this, _this.$infoWindowObject, infoWindowMappedProps);
	      bindEvents(_this, _this.$infoWindowObject, events);

	      // TODO: This function names should be analyzed
	      /* eslint-disable no-underscore-dangle -- old style */
	      _this._openInfoWindow();
	      _this.$watch('opened', function () {
	        _this._openInfoWindow();
	      });
	      /* eslint-enable no-underscore-dangle */

	      return _this.$infoWindowObject;
	    })["catch"](function (error) {
	      throw error;
	    });

	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$infoWindowPromise = promise;
	    return {
	      $infoWindowPromise: promise
	    };
	  },
	  props: {
	    /**
	     * NOTE: This prop overrides the content of the default slot, use only one of them, not both at the same time
	     * Content to display in the InfoWindow. This can be an HTML element, a plain-text string, or a string containing HTML. The InfoWindow will be sized according to the content. To set an explicit size for the content, set content to be a HTML element with that size.
	     * @value undefined
	     * @see [InfoWindow content](https://developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindowOptions.content)
	     */
	    content: {
	      type: [String, Object],
	      "default": undefined
	    },
	    /**
	     * Determines if the info-window is open or not
	     */
	    opened: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * Contains the LatLng at which this info window is anchored.
	     * Note: An InfoWindow may be attached either to a Marker object
	     * (in which case its position is based on the marker's location)
	     * or on the map itself at a specified LatLng.
	     *
	     * The LatLng at which to display this InfoWindow. If the InfoWindow is opened with an anchor, the anchor's position will be used instead.
	     * @value undefined
	     * @type LatLng|LatLngLiteral
	     * @see [InfoWindow position](https://developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindowOptions.position)
	     */
	    position: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * All InfoWindows are displayed on the map in order of their zIndex, with higher values displaying in front of InfoWindows with lower values. By default, InfoWindows are displayed according to their latitude, with InfoWindows of lower latitudes appearing in front of InfoWindows at higher latitudes. InfoWindows are always displayed in front of markers.
	     * @value 0
	     * @see [InfoWindow position](https://developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindowOptions.zIndex)
	     */
	    zIndex: {
	      type: Number,
	      "default": 0
	    },
	    /**
	     * Extra options that you want to pass to the component
	     */
	    options: {
	      type: Object,
	      required: false,
	      "default": undefined
	    }
	  },
	  mounted: function mounted() {
	    var el = this.$refs.flyaway;
	    el.parentNode.removeChild(el);
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$infoWindowObject && this.$infoWindowObject.setMap) {
	      this.$infoWindowObject.setMap(null);
	    }
	  },
	  methods: {
	    // TODO: we need to analyze the following method name
	    // eslint-disable-next-line no-underscore-dangle -- old code
	    _openInfoWindow: function _openInfoWindow() {
	      if (this.opened) {
	        if (this.$markerObject !== null) {
	          this.$infoWindowObject.open(this.$map, this.$markerObject);
	        } else {
	          this.$infoWindowObject.open(this.$map);
	        }
	      } else {
	        this.$infoWindowObject.close();
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$5 = script$5;

	/* template */
	var __vue_render__$3 = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('div', [_c('div', {
	    ref: "flyaway"
	  }, [_vm._t("default")], 2)]);
	};
	var __vue_staticRenderFns__$3 = [];

	/* style */
	var __vue_inject_styles__$5 = undefined;
	/* scoped */
	var __vue_scope_id__$5 = undefined;
	/* module identifier */
	var __vue_module_identifier__$5 = undefined;
	/* functional template */
	var __vue_is_functional_template__$5 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$5 = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__$3,
	  staticRenderFns: __vue_staticRenderFns__$3
	}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

	var _excluded$a = ["options"];

	/**
	 * KmlLayer component
	 * @displayName Kml-Layer
	 * @see [source code](/guide/kml-layer.html#source-code)
	 * @see [Official documentation](https://developers.google.com/maps/documentation/javascript/kmllayer)
	 * @see [Official reference](https://developers.google.com/maps/documentation/javascript/reference/kml)
	 */
	var script$6 = {
	  name: 'KmlLayer',
	  mixins: [mapElementMixin],
	  render: function render() {
	    return '';
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['click', 'rightclick', 'dblclick', 'mouseup', 'mousedown', 'mouseover', 'mouseout'];

	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, kmlLayerMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$a);
	      _this.$kmlLayerObject = new google.maps.KmlLayer(finalOptions);
	      bindProps(_this, _this.$kmlLayerObject, kmlLayerMappedProps);
	      bindEvents(_this, _this.$kmlLayerObject, events);
	      return _this.$kmlLayerObject;
	    })["catch"](function (error) {
	      throw error;
	    });
	    this.$kmlLayerPromise = promise;
	    return {
	      $kmlLayerPromise: promise
	    };
	  },
	  props: {
	    /**
	     * If true, the layer receives mouse events. Default value is true.
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.clickable)
	     */
	    clickable: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * Specifies the Map on which to render the KmlLayer. You can hide a KmlLayer by setting this value to null within the setMap() method
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.map)
	     */
	    map: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * By default, the input map is centered and zoomed to the bounding box of the contents of the layer. If this option is set to true, the viewport is
	     * left unchanged, unless the map's center and zoom were never set.
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.preserveViewport)
	     */
	    preserveViewport: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Whether to render the screen overlays. Default true.
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.screenOverlays)
	     */
	    screenOverlays: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Suppress the rendering of info windows when layer features are clicked.
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.suppressInfoWindows)
	     */
	    suppressInfoWindows: {
	      type: Boolean,
	      "default": undefined
	    },
	    /**
	     * The URL of the KML document to display.
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.url)
	     */
	    url: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The z-index of the layer.
	     * @see [KmlLayerOptions interface](https://developers.google.com/maps/documentation/javascript/reference/kml#KmlLayerOptions.zIndex)
	     */
	    zIndex: {
	      type: Number,
	      "default": undefined
	    },
	    /**
	     * More options that you can pass to the component
	     * @value boolean
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$kmlLayerObject && this.$kmlLayerObject.setMap) {
	      this.$kmlLayerObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$6 = script$6;

	/* template */

	/* style */
	var __vue_inject_styles__$6 = undefined;
	/* scoped */
	var __vue_scope_id__$6 = undefined;
	/* module identifier */
	var __vue_module_identifier__$6 = undefined;
	/* functional template */
	var __vue_is_functional_template__$6 = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$6 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

	/* eslint-disable no-underscore-dangle -- old style, should be analyzed */

	/**
	 * @class MountableMixin
	 *
	 * Mixin for objects that are mounted by Google Maps Javascript API.
	 *
	 * These are objects that are sensitive to element resize  operations
	 * so it exposes a property which accepts a bus
	 * ## The mixin code:
	 * ```js
	  export default {
	    props: ['resizeBus'],

	    data() {
	      return {
	        _actualResizeBus: null,
	      };
	    },

	    created() {
	      if (typeof this.resizeBus === 'undefined') {
	        this.$data._actualResizeBus = this.$gmapDefaultResizeBus;
	      } else {
	        this.$data._actualResizeBus = this.resizeBus;
	      }
	    },

	    methods: {
	      _resizeCallback() {
	        this.resize();
	      },
	      _delayedResizeCallback() {
	        this.$nextTick(() => this._resizeCallback());
	      },
	    },

	    watch: {
	      resizeBus(newVal) {
	        this.$data._actualResizeBus = newVal;
	      },
	      '$data._actualResizeBus': function actualResizeBus(newVal, oldVal) {
	        if (oldVal) {
	          oldVal.$off('resize', this._delayedResizeCallback);
	        }
	        if (newVal) {
	          newVal.$on('resize', this._delayedResizeCallback);
	        }
	      },
	    },

	    destroyed() {
	      if (this.$data._actualResizeBus) {
	        this.$data._actualResizeBus.$off('resize', this._delayedResizeCallback);
	      }
	    },
	  };
	 * ```
	 * @property {Function|undefined} resizeBus Vue props to set your custom resize bus function, otherwise it takes the default `$gmapDefaultResizeBus`
	 * @property {Function|undefined} _actualResizeBus The current default resize bus function, **this should not be used outside of this mixin**
	 */
	var mountableMixin = {
	  props: ['resizeBus'],
	  data: function data() {
	    return {
	      _actualResizeBus: null
	    };
	  },
	  created: function created() {
	    if (typeof this.resizeBus === 'undefined') {
	      this.$data._actualResizeBus = this.$gmapDefaultResizeBus;
	    } else {
	      this.$data._actualResizeBus = this.resizeBus;
	    }
	  },
	  methods: {
	    _resizeCallback: function _resizeCallback() {
	      this.resize();
	    },
	    _delayedResizeCallback: function _delayedResizeCallback() {
	      var _this = this;
	      this.$nextTick(function () {
	        return _this._resizeCallback();
	      });
	    }
	  },
	  watch: {
	    resizeBus: function resizeBus(newVal) {
	      this.$data._actualResizeBus = newVal;
	    },
	    '$data._actualResizeBus': function $data_actualResizeBus(newVal, oldVal) {
	      if (oldVal) {
	        oldVal.$off('resize', this._delayedResizeCallback);
	      }
	      if (newVal) {
	        newVal.$on('resize', this._delayedResizeCallback);
	      }
	    }
	  },
	  destroyed: function destroyed() {
	    if (this.$data._actualResizeBus) {
	      this.$data._actualResizeBus.$off('resize', this._delayedResizeCallback);
	    }
	  }
	};

	var _excluded$b = ["options"];

	//

	/**
	 * Map component
	 * @displayName Map
	 * @see [source code](/guide/map.html#source-code)
	 * @see [Official documentation](https://developers.google.com/maps/documentation/javascript/basics)
	 * @see [Official reference](https://developers.google.com/maps/documentation/javascript/reference/map)
	 */
	var script$7 = {
	  name: 'MapLayer',
	  mixins: [mountableMixin],
	  provide: function provide() {
	    var _this = this;
	    this.$mapPromise = new Promise(function (resolve, reject) {
	      _this.$mapPromiseDeferred = {
	        resolve: resolve,
	        reject: reject
	      };
	    });
	    return {
	      $mapPromise: this.$mapPromise
	    };
	  },
	  props: {
	    /**
	     * The initial Map center.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
	     */
	    center: {
	      type: Object,
	      required: true
	    },
	    /**
	     * The initial Map zoom level. Valid values: Integers between zero, and up to the supported maximum zoom level.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
	     */
	    zoom: {
	      type: Number,
	      required: false,
	      "default": undefined
	    },
	    /**
	     * The heading for aerial imagery in degrees measured clockwise from cardinal direction North. Headings are snapped to the nearest available angle for which imagery is available.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
	     */
	    heading: {
	      type: Number,
	      "default": undefined
	    },
	    /**
	     * The initial Map mapTypeId. Defaults to ROADMAP.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
	     */
	    mapTypeId: {
	      type: String,
	      "default": 'roadmap'
	    },
	    /**
	     * For vector maps, sets the angle of incidence of the map. The allowed values are restricted depending on the zoom level of the map. For raster maps, controls the automatic switching behavior for the angle of incidence of the map. The only allowed values are 0 and 45. The value 0 causes the map to always use a 0° overhead view regardless of the zoom level and viewport. The value 45 causes the tilt angle to automatically switch to 45 whenever 45° imagery is available for the current zoom level and viewport, and switch back to 0 whenever 45° imagery is not available (this is the default behavior). 45° imagery is only available for satellite and hybrid map types, within some locations, and at some zoom levels. Note: getTilt returns the current tilt angle, not the value specified by this option. Because getTilt and this option refer to different things, do not bind() the tilt property; doing so may yield unpredictable effects.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions
	     */
	    tilt: {
	      type: Number,
	      "default": undefined
	    },
	    /**
	     * Extra options that you want pass to the component
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    }
	  },
	  data: function data() {
	    return {
	      recyclePrefix: '__gmc__'
	    };
	  },
	  computed: {
	    finalLat: function finalLat() {
	      return this.center && typeof this.center.lat === 'function' ? this.center.lat() : this.center.lat;
	    },
	    finalLng: function finalLng() {
	      return this.center && typeof this.center.lng === 'function' ? this.center.lng() : this.center.lng;
	    },
	    finalLatLng: function finalLatLng() {
	      return {
	        lat: this.finalLat,
	        lng: this.finalLng
	      };
	    }
	  },
	  watch: {
	    zoom: function zoom(_zoom) {
	      if (this.$mapObject) {
	        this.$mapObject.setZoom(_zoom);
	      }
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    var recycleKey = this.getRecycleKey();
	    if (window[recycleKey]) {
	      window[recycleKey].div = this.$mapObject.getDiv();
	    }
	  },
	  mounted: function mounted() {
	    var _this2 = this;
	    return this.$gmapApiPromiseLazy().then(function () {
	      var events = ['bounds_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'idle', 'mousemove', 'mouseout', 'mouseover', 'resize', 'rightclick', 'tilesloaded'];

	      // getting the DOM element where to create the map
	      var element = _this2.$refs['vue-map'];

	      // creating the map
	      var initialOptions = _extends({}, _this2.options, getPropsValues(_this2, mapMappedProps));

	      // don't use delete keyword in order to create a more predictable code for the engine
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$b);
	      var options = finalOptions;
	      var recycleKey = _this2.getRecycleKey();
	      if (_this2 && _this2.options && _this2.options.recycle && window[recycleKey]) {
	        element.appendChild(window[recycleKey].div);
	        _this2.$mapObject = window[recycleKey].map;
	        _this2.$mapObject.setOptions(options);
	      } else {
	        // console.warn('[gmap-vue] New google map created')
	        _this2.$mapObject = new google.maps.Map(element, options);
	        window[recycleKey] = {
	          map: _this2.$mapObject
	        };
	      }

	      // binding properties (two and one way)
	      bindProps(_this2, _this2.$mapObject, mapMappedProps);
	      // binding events
	      bindEvents(_this2, _this2.$mapObject, events);

	      // manually trigger center and zoom
	      twoWayBindingWrapper(function (increment, decrement, shouldUpdate) {
	        _this2.$mapObject.addListener('center_changed', function () {
	          if (shouldUpdate()) {
	            /**
	             * This event is fired when the map center property changes. It sends the position displayed at the center of the map. If the center or bounds have not been set then the result is undefined. (types: `LatLng|undefined`)
	             *
	             * @event center_changed
	             * @type {(LatLng|undefined)}
	             */
	            _this2.$emit('center_changed', _this2.$mapObject.getCenter());
	          }
	          decrement();
	        });
	        var updateCenter = function updateCenter() {
	          increment();
	          _this2.$mapObject.setCenter(_this2.finalLatLng);
	        };
	        watchPrimitiveProperties(_this2, ['finalLat', 'finalLng'], updateCenter);
	      });
	      _this2.$mapObject.addListener('zoom_changed', function () {
	        /**
	         * This event is fired when the map zoom property changes. It sends the zoom of the map. If the zoom has not been set then the result is undefined. (types: `number|undefined`)
	         *
	         * @event zoom_changed
	         * @type {(number|undefined)}
	         */
	        _this2.$emit('zoom_changed', _this2.$mapObject.getZoom());
	      });
	      _this2.$mapObject.addListener('bounds_changed', function () {
	        /**
	         * This event is fired when the viewport bounds have changed. It sends The lat/lng bounds of the current viewport.
	         *
	         * @event bounds_changed
	         * @type {LatLngBounds}
	         */
	        _this2.$emit('bounds_changed', _this2.$mapObject.getBounds());
	      });
	      _this2.$mapPromiseDeferred.resolve(_this2.$mapObject);
	      return _this2.$mapObject;
	    })["catch"](function (error) {
	      throw error;
	    });
	  },
	  methods: {
	    /**
	     * This method trigger the resize event of Google Maps
	     * @method resize
	     * @param {undefined}
	     * @returns {void}
	     * @public
	     */
	    resize: function resize() {
	      if (this.$mapObject) {
	        google.maps.event.trigger(this.$mapObject, 'resize');
	      }
	    },
	    /**
	     * Preserve the previous center when resize the map
	     * @method resizePreserveCenter
	     * @param {undefined}
	     * @returns {void}
	     * @public
	     */
	    resizePreserveCenter: function resizePreserveCenter() {
	      if (!this.$mapObject) {
	        return;
	      }
	      var oldCenter = this.$mapObject.getCenter();
	      google.maps.event.trigger(this.$mapObject, 'resize');
	      this.$mapObject.setCenter(oldCenter);
	    },
	    // Override mountableMixin::_resizeCallback
	    // because resizePreserveCenter is usually the
	    // expected behaviour
	    // TODO: analyze the following disabled rule
	    // eslint-disable-next-line no-underscore-dangle -- old code
	    _resizeCallback: function _resizeCallback() {
	      this.resizePreserveCenter();
	    },
	    /**
	     * Changes the center of the map by the given distance in pixels. If the distance is less than both the width and height of the map, the transition will be smoothly animated. Note that the map coordinate system increases from west to east (for x values) and north to south (for y values).
	     * @method panBy
	     * @param {number} x - Number of pixels to move the map in the x direction.
	     * @param {number} y - Number of pixels to move the map in the y direction.
	     * @returns {void}
	     * @public
	     */
	    panBy: function panBy() {
	      if (this.$mapObject) {
	        var _this$$mapObject;
	        (_this$$mapObject = this.$mapObject).panBy.apply(_this$$mapObject, arguments);
	      }
	    },
	    /**
	     * Changes the center of the map to the given LatLng. If the change is less than both the width and height of the map, the transition will be smoothly animated.
	     * @method panTo
	     * @param {(LatLng|LatLngLiteral)} latLng - The new center latitude/longitude of the map. (types `LatLng|LatLngLiteral`)
	     * @returns {void}
	     * @public
	     */
	    panTo: function panTo() {
	      if (this.$mapObject) {
	        var _this$$mapObject2;
	        (_this$$mapObject2 = this.$mapObject).panTo.apply(_this$$mapObject2, arguments);
	      }
	    },
	    /**
	     * Pans the map by the minimum amount necessary to contain the given LatLngBounds. It makes no guarantee where on the map the bounds will be, except that the map will be panned to show as much of the bounds as possible inside {currentMapSizeInPx} - {padding}. For both raster and vector maps, the map's zoom, tilt, and heading will not be changed.
	     * @method panToBounds
	     * @param {(LatLngBounds|LatLngBoundsLiteral)} latLngBounds - The bounds to pan the map to. (types: `LatLngBounds|LatLngBoundsLiteral`)
	     * @param {(number|Padding)} [padding] - optional Padding in pixels. A number value will yield the same padding on all 4 sides. The default value is 0. (types: `number|Padding`)
	     * @returns {void}
	     * @public
	     */
	    panToBounds: function panToBounds() {
	      if (this.$mapObject) {
	        var _this$$mapObject3;
	        (_this$$mapObject3 = this.$mapObject).panToBounds.apply(_this$$mapObject3, arguments);
	      }
	    },
	    /**
	     * Sets the viewport to contain the given bounds.
	    Note: When the map is set to display: none, the fitBounds function reads the map's size as 0x0, and therefore does not do anything. To change the viewport while the map is hidden, set the map to visibility: hidden, thereby ensuring the map div has an actual size. For vector maps, this method sets the map's tilt and heading to their default zero values.
	     * @method fitBounds
	     * @param {(LatLngBounds|LatLngBoundsLiteral)} bounds - Bounds to show. (types: `LatLngBounds|LatLngBoundsLiteral`)
	     * @param {(number|Padding)} [padding] - optional Padding in pixels. The bounds will be fit in the part of the map that remains after padding is removed. A number value will yield the same padding on all 4 sides. Supply 0 here to make a fitBounds idempotent on the result of getBounds. (types: `number|Padding`)
	     * @returns {void}
	     * @public
	     */
	    fitBounds: function fitBounds() {
	      if (this.$mapObject) {
	        var _this$$mapObject4;
	        (_this$$mapObject4 = this.$mapObject).fitBounds.apply(_this$$mapObject4, arguments);
	      }
	    },
	    /**
	     * Get the recycle key of the map
	     * @method getRecycleKey
	     * @param {undefined}
	     * @returns {void}
	     * @public
	     */
	    getRecycleKey: function getRecycleKey() {
	      return this && this.options && this.options.recycle ? this.recyclePrefix + this.options.recycle : this.recyclePrefix;
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$mapObject && this.$mapObject.setMap) {
	      this.$mapObject.setMap(null);
	    }
	  }
	};

	var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
	function createInjector(context) {
	  return function (id, style) {
	    return addStyle(id, style);
	  };
	}
	var HEAD;
	var styles = {};
	function addStyle(id, css) {
	  var group = isOldIE ? css.media || 'default' : id;
	  var style = styles[group] || (styles[group] = {
	    ids: new Set(),
	    styles: []
	  });
	  if (!style.ids.has(id)) {
	    style.ids.add(id);
	    var code = css.source;
	    if (css.map) {
	      // https://developer.chrome.com/devtools/docs/javascript-debugging
	      // this makes source maps inside style tags work properly in Chrome
	      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

	      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
	    }
	    if (!style.element) {
	      style.element = document.createElement('style');
	      style.element.type = 'text/css';
	      if (css.media) style.element.setAttribute('media', css.media);
	      if (HEAD === undefined) {
	        HEAD = document.head || document.getElementsByTagName('head')[0];
	      }
	      HEAD.appendChild(style.element);
	    }
	    if ('styleSheet' in style.element) {
	      style.styles.push(code);
	      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
	    } else {
	      var index = style.ids.size - 1;
	      var textNode = document.createTextNode(code);
	      var nodes = style.element.childNodes;
	      if (nodes[index]) style.element.removeChild(nodes[index]);
	      if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
	    }
	  }
	}

	/* script */
	var __vue_script__$7 = script$7;

	/* template */
	var __vue_render__$4 = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('div', {
	    staticClass: "vue-map-container"
	  }, [_c('div', {
	    ref: "vue-map",
	    staticClass: "vue-map"
	  }), _vm._v(" "), _c('div', {
	    staticClass: "vue-map-hidden"
	  }, [_vm._t("default")], 2), _vm._v(" "), _vm._t("visible")], 2);
	};
	var __vue_staticRenderFns__$4 = [];

	/* style */
	var __vue_inject_styles__$7 = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-58f81a38_0", {
	    source: ".vue-map-container{position:relative}.vue-map-container .vue-map{left:0;right:0;top:0;bottom:0;position:absolute}.vue-map-hidden{display:none}",
	    map: undefined,
	    media: undefined
	  });
	};
	/* scoped */
	var __vue_scope_id__$7 = undefined;
	/* module identifier */
	var __vue_module_identifier__$7 = undefined;
	/* functional template */
	var __vue_is_functional_template__$7 = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$7 = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__$4,
	  staticRenderFns: __vue_staticRenderFns__$4
	}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, createInjector, undefined, undefined);

	var _excluded$c = ["options"];

	/**
	 * Marker component
	 * @displayName Marker
	 * @see [source code](/guide/marker.html#source-code)
	 * @see [Official documentation](https://developers.google.com/maps/documentation/javascript/markers)
	 * @see [Official reference](https://developers.google.com/maps/documentation/javascript/reference/marker)
	 */
	var script$8 = {
	  name: 'MarkerIcon',
	  mixins: [mapElementMixin],
	  inject: {
	    $clusterPromise: {
	      "default": null
	    }
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['click', 'rightclick', 'dblclick', 'drag', 'dragstart', 'dragend', 'mouseup', 'mousedown', 'mouseover', 'mouseout'];
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, markerMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$c);
	      if (_this.$clusterPromise) {
	        finalOptions.map = null;
	      }
	      _this.$markerObject = new google.maps.Marker(finalOptions);
	      bindProps(_this, _this.$markerObject, markerMappedProps);
	      bindEvents(_this, _this.$markerObject, events);
	      _this.$markerObject.addListener('dragend', function () {
	        var newPosition = _this.$markerObject.getPosition();
	        /**
	         * An event to detect when a position changes
	         * @property {Object} position Object with lat and lng values, eg: { lat: 10.0, lng: 10.0 }
	         */
	        _this.$emit('update:position', {
	          lat: newPosition.lat(),
	          lng: newPosition.lng()
	        });
	      });
	      if (_this.$clusterPromise) {
	        _this.$clusterPromise.then(function (clusterObject) {
	          clusterObject.addMarker(_this.$markerObject);
	          _this.$clusterObject = clusterObject;
	        });
	      }
	      return _this.$markerObject;
	    })["catch"](function (error) {
	      throw error;
	    });
	    this.$markerPromise = promise;
	    return {
	      $markerPromise: promise
	    };
	  },
	  props: {
	    /**
	     * Which animation to play when marker is added to a map.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    animation: {
	      type: Number,
	      "default": undefined
	    },
	    /**
	     * This property was not found on the Googole Maps documentation, but it was defined in the previous version of this component.
	     * Any suggestion is welcome here.
	     */
	    attribution: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * If true, the marker receives mouse and touch events. Default value is true.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    clickable: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * Mouse cursor type to show on hover.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    cursor: {
	      type: String,
	      "default": undefined
	    },
	    /**
	     * If true, the marker can be dragged. Default value is false.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    draggable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Icon for the foreground. If a string is provided, it is treated as though it were an Icon with the string as url.
	     * Its type can be string|Icon|Symbol optional
	     * @see [Icon type](https://developers.google.com/maps/documentation/javascript/reference/marker#Icon)
	     * @see [Symbol type](https://developers.google.com/maps/documentation/javascript/reference/marker#Symbol)
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    icon: {
	      type: [String, Object],
	      "default": undefined
	    },
	    /**
	     * Adds a label to the marker. A marker label is a letter or number that appears inside a marker. The label can either be a string, or a MarkerLabel object. If provided and MarkerOptions.title is not provided, an accessibility text (e.g. for use with screen readers) will be added to the marker with the provided label's text. Please note that the label is currently only used for accessibility text for non-optimized markers.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    label: {
	      type: [String, Object],
	      "default": undefined
	    },
	    /**
	     * A number between 0.0, transparent, and 1.0, opaque.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    opacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * Extra options passed to this component.
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * This property was not found on the Googole Maps documentation, but it was defined in the previous version of this component.
	     * Any suggestion is welcome here.
	     */
	    place: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Marker position. The position is required to display the marker and can be provided with Marker.setPosition if not provided at marker construction.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    position: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Image map region definition used for drag/click.
	     * @see [MarkerShape type](https://developers.google.com/maps/documentation/javascript/reference/marker#MarkerShape)
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    shape: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Rollover text. If provided, an accessibility text (e.g. for use with screen readers) will be added to the marker with the provided value. Please note that the title is currently only used for accessibility text for non-optimized markers.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    title: {
	      type: String,
	      "default": undefined
	    },
	    /**
	     * If true, the marker is visible.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    visible: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * All markers are displayed on the map in order of their zIndex, with higher values displaying in front of markers with lower values. By default, markers are displayed according to their vertical position on screen, with lower markers appearing in front of markers further up the screen.
	     * @see https://developers.google.com/maps/documentation/javascript/reference/marker
	     */
	    zIndex: {
	      type: Number,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    if (!this.$markerObject) {
	      return;
	    }
	    if (this.$clusterObject) {
	      // Repaint will be performed in `updated()` of cluster
	      this.$clusterObject.removeMarker(this.$markerObject, true);
	    } else if (this.$markerObject && this.$markerObject.setMap) {
	      this.$markerObject.setMap(null);
	    }
	  },
	  render: function render(h) {
	    if (!this.$slots["default"] || this.$slots["default"].length === 0) {
	      return '';
	    }
	    if (this.$slots["default"].length === 1) {
	      // So that infowindows can have a marker parent
	      return this.$slots["default"][0];
	    }

	    /**
	     * @slot Default slot of the component.
	     */
	    return h('div', this.$slots["default"]);
	  }
	};

	/* script */
	var __vue_script__$8 = script$8;

	/* template */

	/* style */
	var __vue_inject_styles__$8 = undefined;
	/* scoped */
	var __vue_scope_id__$8 = undefined;
	/* module identifier */
	var __vue_module_identifier__$8 = undefined;
	/* functional template */
	var __vue_is_functional_template__$8 = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$8 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

	var _excluded$d = ["placeholder", "place", "defaultPlace", "className", "label", "selectFirstOnEnter"];

	//

	/**
	 * PlaceInput component
	 * @deprecated
	 * @displayName PlaceInput
	 * @see [source code](/guide/place-input.html#source-code)
	 * @see [Map Bounds](https://developers.google.com/maps/documentation/javascript/places-autocomplete#set-the-bounds-on-creation-of-the-autocomplete-object)
	 */
	var script$9 = {
	  name: 'PlaceInput',
	  props: {
	    /**
	     * Map bounds this is an LatLngBounds
	     * object builded with
	     * @value new google.maps.LatLngBounds(...)
	     * @see [Map Bounds](https://developers.google.com/maps/documentation/javascript/places-autocomplete#set-the-bounds-on-creation-of-the-autocomplete-object)
	     */
	    bounds: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * A default value for the html input
	     * @value string
	     */
	    defaultPlace: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * Restrict the search to a specific country
	     * @value `{[key: string]: string}`
	     * @see [componentRestrictions](https://developers.google.com/maps/documentation/javascript/places-autocomplete#restrict-the-search-to-a-specific-country)
	     */
	    componentRestrictions: {
	      type: Object,
	      "default": null
	    },
	    /**
	     * Map types this is an array of strings
	     * @value string[]
	     * @see [Map Bounds](https://developers.google.com/maps/documentation/javascript/places-autocomplete#set-the-bounds-on-creation-of-the-autocomplete-object)
	     */
	    types: {
	      type: Array,
	      "default": undefined
	    },
	    /**
	     * A placeholder for the html input
	     * @value string
	     */
	    placeholder: {
	      required: false,
	      type: String,
	      "default": undefined
	    },
	    /**
	     * A html class name for the html input
	     * @value string
	     */
	    className: {
	      required: false,
	      type: String,
	      "default": undefined
	    },
	    /**
	     * A label for the html input
	     * @value string
	     */
	    label: {
	      required: false,
	      type: String,
	      "default": null
	    },
	    /**
	     * If true the first element on the list will be selected
	     * when you press enter in the html input.
	     * @value boolean
	     */
	    selectFirstOnEnter: {
	      require: false,
	      type: Boolean,
	      "default": false
	    }
	  },
	  created: function created() {
	    window.console.warn('The PlaceInput class is deprecated! Please consider using the Autocomplete input instead, it will be removed in the next major release of this plugin.');
	  },
	  mounted: function mounted() {
	    var _this = this;
	    var input = this.$refs.input;

	    // Allow default place to be set
	    input.value = this.defaultPlace;
	    this.$watch('defaultPlace', function () {
	      input.value = _this.defaultPlace;
	    });
	    this.$gmapApiPromiseLazy().then(function () {
	      var options = getPropsValues(_this, placeInputMappedProps);
	      if (_this.selectFirstOnEnter) {
	        downArrowSimulator(_this.$refs.input);
	      }
	      if (typeof google.maps.places.Autocomplete !== 'function') {
	        throw new Error("google.maps.places.Autocomplete is undefined. Did you add 'places' to libraries when loading Google Maps?");
	      }
	      _this.$autoCompleter = new google.maps.places.Autocomplete(_this.$refs.input, options);
	      var rest = _objectWithoutPropertiesLoose(placeInputMappedProps, _excluded$d);
	      bindProps(_this, _this.$autoCompleter, rest);
	      _this.$autoCompleter.addListener('place_changed', function () {
	        /**
	         * Place change event
	         * @event place_changed
	         * @property {object} place `this.$autocomplete.getPlace()`
	         * @see [Get place information](https://developers.google.com/maps/documentation/javascript/places-autocomplete#get-place-information)
	         */
	        _this.$emit('place_changed', _this.$autoCompleter.getPlace());
	      });
	    });
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$autoCompleter && this.$autoCompleter.setMap) {
	      this.$autoCompleter.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$9 = script$9;

	/* template */
	var __vue_render__$5 = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('label', [_c('span', {
	    domProps: {
	      "textContent": _vm._s(_vm.label)
	    }
	  }), _vm._v(" "), _c('input', {
	    ref: "input",
	    "class": _vm.className,
	    attrs: {
	      "type": "text",
	      "placeholder": _vm.placeholder
	    }
	  })]);
	};
	var __vue_staticRenderFns__$5 = [];

	/* style */
	var __vue_inject_styles__$9 = undefined;
	/* scoped */
	var __vue_scope_id__$9 = undefined;
	/* module identifier */
	var __vue_module_identifier__$9 = undefined;
	/* functional template */
	var __vue_is_functional_template__$9 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$9 = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__$5,
	  staticRenderFns: __vue_staticRenderFns__$5
	}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

	var _excluded$e = ["options", "path", "paths"];

	/**
	 * Polygon component
	 * @displayName GmapPolygon
	 * @see [source code](/guide/polygon.html#source-code)
	 * @see [official docs](https://developers.google.com/maps/documentation/javascript/examples/polygon-arrays?hl=es)
	 * @see [official reference](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#Polygon)
	 */
	var script$a = {
	  name: 'PolygonShape',
	  mixins: [mapElementMixin],
	  render: function render() {
	    return '';
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];
	    var $polygonPromise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, polygonMappedProps));
	      var extraOptions = initialOptions.options,
	        optionPath = initialOptions.path,
	        optionPaths = initialOptions.paths,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$e);
	      _this.$polygonObject = new google.maps.Polygon(finalOptions);
	      bindProps(_this, _this.$polygonObject, polygonMappedProps);
	      bindEvents(_this, _this.$polygonObject, events);
	      var clearEvents = function clearEvents() {};

	      // Watch paths, on our own, because we do not want to set either when it is
	      // empty
	      _this.$watch('paths', function (paths) {
	        if (paths) {
	          clearEvents();
	          _this.$polygonObject.setPaths(paths);
	          var updatePaths = function updatePaths() {
	            /**
	             * An event to detect when a paths changes
	             * @property {array} paths `this.$polygonObject.getPaths()` |
	             */
	            _this.$emit('paths_changed', _this.$polygonObject.getPaths());
	          };
	          var eventListeners = [];
	          var mvcArray = _this.$polygonObject.getPaths();
	          for (var i = 0; i < mvcArray.getLength(); i += 1) {
	            var mvcPath = mvcArray.getAt(i);
	            eventListeners.push([mvcPath, mvcPath.addListener('insert_at', updatePaths)]);
	            eventListeners.push([mvcPath, mvcPath.addListener('remove_at', updatePaths)]);
	            eventListeners.push([mvcPath, mvcPath.addListener('set_at', updatePaths)]);
	          }
	          eventListeners.push([mvcArray, mvcArray.addListener('insert_at', updatePaths)]);
	          eventListeners.push([mvcArray, mvcArray.addListener('remove_at', updatePaths)]);
	          eventListeners.push([mvcArray, mvcArray.addListener('set_at', updatePaths)]);

	          // TODO: analyze, we change map to forEach because clearEvents is a void function and the returned array is not used
	          clearEvents = function clearEvents() {
	            eventListeners.forEach(function (_ref) {
	              var listenerHandle = _ref[1];
	              google.maps.event.removeListener(listenerHandle);
	            });
	          };
	        }
	      }, {
	        deep: _this.deepWatch,
	        immediate: true
	      });
	      _this.$watch('path', function (path) {
	        if (path) {
	          clearEvents();
	          _this.$polygonObject.setPaths(path);
	          var mvcPath = _this.$polygonObject.getPath();
	          var eventListeners = [];
	          var updatePaths = function updatePaths() {
	            /**
	             * ### path_changed (undefined)
	             *
	             * An event to detect when a path change
	             * @property {array} path `this.$polygonObject.getPath()`
	             */
	            _this.$emit('path_changed', _this.$polygonObject.getPath());
	          };
	          eventListeners.push([mvcPath, mvcPath.addListener('insert_at', updatePaths)]);
	          eventListeners.push([mvcPath, mvcPath.addListener('remove_at', updatePaths)]);
	          eventListeners.push([mvcPath, mvcPath.addListener('set_at', updatePaths)]);

	          // TODO: analyze, we change map to forEach because clearEvents is a void function and the returned array is not used
	          clearEvents = function clearEvents() {
	            eventListeners.forEach(function (_ref2) {
	              var listenerHandle = _ref2[1];
	              google.maps.event.removeListener(listenerHandle);
	            });
	          };
	        }
	      }, {
	        deep: _this.deepWatch,
	        immediate: true
	      });
	      return _this.$polygonObject;
	    })["catch"](function (error) {
	      throw error;
	    });
	    this.$polygonPromise = $polygonPromise;
	    return {
	      $polygonPromise: $polygonPromise
	    };
	  },
	  props: {
	    /**
	     * If set true the object will be deep watched
	     * @value boolean
	     */
	    deepWatch: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Indicates whether this Polygon handles mouse events. Defaults to true.
	     * @value true, false
	     * @see [Polygon draggable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.clickable)
	     */
	    clickable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Indicates if the polygon is draggable
	     * @value true, false
	     * @see [Polygon dragable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.draggable)
	     */
	    draggable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Indicates if the polygon is editable
	     * @value true, false
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.editable)
	     */
	    editable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * The fill color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.fillColor)
	     */
	    fillColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The fill opacity between 0.0 and 1.0
	     * @value 1
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.fillOpacity)
	     */
	    fillOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.strokeColor)
	     */
	    strokeColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The stroke opacity between 0.0 and 1.0.
	     * @value 1
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.strokeOpacity)
	     */
	    strokeOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke position. Defaults to CENTER.
	     * @value 1
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.strokePosition)
	     * @see [StrokePosition constant](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#StrokePosition)
	     */
	    strokePosition: {
	      type: Number,
	      "default": 0
	    },
	    /**
	     * The stroke width in pixels.
	     * @value 1
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.strokeWeight)
	     */
	    strokeWeight: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * Whether this polyline is visible on the map. Defaults to true.
	     * @value 1
	     * @see [Polygon editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.visible)
	     */
	    visible: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * More options that you can pass to the component
	     * @value boolean
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Indicates if the polygon is editable
	     * @value Array
	     * @see [Polygon path](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.path)
	     */
	    path: {
	      type: Array,
	      noBind: true,
	      "default": undefined
	    },
	    /**
	     * Indicates if the polygon is editable
	     * @value Array
	     * @see [Polygon paths](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolygonOptions.paths)
	     */
	    paths: {
	      type: Array,
	      noBind: true,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$polygonObject && this.$polygonObject.setMap) {
	      this.$polygonObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$a = script$a;

	/* template */

	/* style */
	var __vue_inject_styles__$a = undefined;
	/* scoped */
	var __vue_scope_id__$a = undefined;
	/* module identifier */
	var __vue_module_identifier__$a = undefined;
	/* functional template */
	var __vue_is_functional_template__$a = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$a = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

	var _excluded$f = ["options"];

	/**
	 * PolyLine component
	 * @displayName GmapPolyline
	 * @see [source code](/guide/polyline.html#source-code)
	 * @see [official docs](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#Polyline)
	 * @see [official reference](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#Polyline)
	 */
	var script$b = {
	  name: 'PolylineShape',
	  mixins: [mapElementMixin],
	  render: function render() {
	    return '';
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, polylineMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$f);
	      _this.$polylineObject = new google.maps.Polyline(finalOptions);
	      bindProps(_this, _this.$polylineObject, polylineMappedProps);
	      bindEvents(_this, _this.$polylineObject, events);
	      var clearEvents = function clearEvents() {};
	      _this.$watch('path', function (path) {
	        if (path) {
	          clearEvents();
	          _this.$polylineObject.setPath(path);
	          var mvcPath = _this.$polylineObject.getPath();
	          var eventListeners = [];
	          var updatePaths = function updatePaths() {
	            /**
	             * An event to detect when a path change
	             * @property {array} path `this.$polygonObject.getPath()`
	             */
	            _this.$emit('path_changed', _this.$polylineObject.getPath());
	          };
	          eventListeners.push([mvcPath, mvcPath.addListener('insert_at', updatePaths)]);
	          eventListeners.push([mvcPath, mvcPath.addListener('remove_at', updatePaths)]);
	          eventListeners.push([mvcPath, mvcPath.addListener('set_at', updatePaths)]);
	          clearEvents = function clearEvents() {
	            // TODO: analyze, we change map to forEach because clearEvents is a void function and the returned array is not used
	            eventListeners.forEach(function (_ref) {
	              var listenerHandle = _ref[1];
	              google.maps.event.removeListener(listenerHandle);
	            });
	          };
	        }
	      }, {
	        deep: _this.deepWatch,
	        immediate: true
	      });
	      return _this.$polylineObject;
	    })["catch"](function (error) {
	      throw error;
	    });

	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$polylinePromise = promise;
	    return {
	      $polylinePromise: promise
	    };
	  },
	  props: {
	    /**
	     * If set true the object will be deep watched
	     * @value boolean
	     */
	    deepWatch: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Indicates whether this Polygon handles mouse events. Defaults to true.
	     * @value true, false
	     * @see [Polyline draggable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.clickable)
	     */
	    clickable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * Indicates if the polyline is draggable
	     * @value true, false
	     * @see [Polyline draggable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.draggable)
	     */
	    draggable: {
	      type: Boolean
	    },
	    /**
	     * Indicates if the polygon is editable
	     * @value true, false
	     * @see [Polyline editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.editable)
	     */
	    editable: {
	      type: Boolean
	    },
	    /**
	     * The stroke color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Polyline editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.strokeColor)
	     */
	    strokeColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The stroke opacity between 0.0 and 1.0.
	     * @value 1
	     * @see [Polyline editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.strokeOpacity)
	     */
	    strokeOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke width in pixels.
	     * @value 1
	     * @see [Polyline editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.strokeWeight)
	     */
	    strokeWeight: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * Whether this polyline is visible on the map. Defaults to true.
	     * @value 1
	     * @see [Polyline editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.visible)
	     */
	    visible: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * More options that you can pass to the component
	     * @value boolean
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Indicates if the polygon is editable
	     * @value Array
	     * @see [Polyline path](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#PolylineOptions.path)
	     */
	    path: {
	      type: Array,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$polylineObject && this.$polylineObject.setMap) {
	      this.$polylineObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$b = script$b;

	/* template */

	/* style */
	var __vue_inject_styles__$b = undefined;
	/* scoped */
	var __vue_scope_id__$b = undefined;
	/* module identifier */
	var __vue_module_identifier__$b = undefined;
	/* functional template */
	var __vue_is_functional_template__$b = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$b = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

	var _excluded$g = ["options"];

	/**
	 * Rectangle component
	 * @displayName GmapRectangle
	 * @see [source code](/guide/rectangle.html#source-code)
	 * @see [official docs](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#Rectangle)
	 * @see [official reference](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#Rectangle)
	 */
	var script$c = {
	  name: 'RectangleShape',
	  mixins: [mapElementMixin],
	  render: function render() {
	    return '';
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];
	    var $rectanglePromise = this.$mapPromise.then(function (map) {
	      _this.$map = map;

	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues(_this, rectangleMappedProps));
	      var extraOptions = initialOptions.options,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$g);
	      _this.$rectangleObject = new google.maps.Rectangle(finalOptions);
	      bindProps(_this, _this.$rectangleObject, rectangleMappedProps);
	      bindEvents(_this, _this.$rectangleObject, events);
	      return _this.$rectangleObject;
	    })["catch"](function (error) {
	      throw error;
	    });
	    this.$rectanglePromise = $rectanglePromise;
	    return {
	      $rectanglePromise: $rectanglePromise
	    };
	  },
	  props: {
	    /**
	     * The bounds.
	     * @value object
	     * @type LatLngBounds|LatLngBoundsLiteral
	     * @see [Rectangle bounds](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.bounds)
	     */
	    bounds: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * Indicates whether this Polygon handles mouse events. Defaults to true.
	     * @value true, false
	     * @see [Rectangle draggable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.clickable)
	     */
	    clickable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * If set to true, the user can drag this rectangle over the map. Defaults to false.
	     * @value boolean
	     * @see [Rectangle draggable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.draggable)
	     */
	    draggable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * If set to true, the user can edit this rectangle by dragging the control points shown at the corners and on each edge. Defaults to false.
	     * @value boolean
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.editable)
	     */
	    editable: {
	      type: Boolean,
	      "default": false
	    },
	    /**
	     * The fill color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.fillColor)
	     */
	    fillColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The fill opacity between 0.0 and 1.0
	     * @value 1
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.fillOpacity)
	     */
	    fillOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke color. All CSS3 colors are supported except for extended named colors.
	     * @value '#000'
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.strokeColor)
	     */
	    strokeColor: {
	      type: String,
	      "default": ''
	    },
	    /**
	     * The stroke opacity between 0.0 and 1.0.
	     * @value 1
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.strokeOpacity)
	     */
	    strokeOpacity: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * The stroke position. Defaults to CENTER.
	     * @value 1
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.strokePosition)
	     * @see [StrokePosition constant](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#StrokePosition)
	     */
	    strokePosition: {
	      type: Number,
	      "default": 0
	    },
	    /**
	     * The stroke width in pixels.
	     * @value 1
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.strokeWeight)
	     */
	    strokeWeight: {
	      type: Number,
	      "default": 1
	    },
	    /**
	     * Whether this polyline is visible on the map. Defaults to true.
	     * @value 1
	     * @see [Rectangle editable](https://developers.google.com/maps/documentation/javascript/reference/polygon?hl=es#RectangleOptions.visible)
	     */
	    visible: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * More options that you can pass to the component
	     * @value boolean
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$rectangleObject && this.$rectangleObject.setMap) {
	      this.$rectangleObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$c = script$c;

	/* template */

	/* style */
	var __vue_inject_styles__$c = undefined;
	/* scoped */
	var __vue_scope_id__$c = undefined;
	/* module identifier */
	var __vue_module_identifier__$c = undefined;
	/* functional template */
	var __vue_is_functional_template__$c = undefined;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$c = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

	var _excluded$h = ["options"];

	//

	/**
	 * Street View Panorama component
	 * @displayName GmapStreetViewPanorama
	 * @see [source code](/guide/street-view-panorama.html#source-code)
	 * @see [official docs](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanorama)
	 */
	var script$d = {
	  name: 'StreetViewPanorama',
	  mixins: [mountableMixin],
	  provide: function provide() {
	    var _this = this;
	    this.$panoPromise = new Promise(function (resolve, reject) {
	      _this.$panoPromiseDeferred = {
	        resolve: resolve,
	        reject: reject
	      };
	    });
	    return {
	      $panoPromise: this.$panoPromise,
	      $mapPromise: this.$panoPromise // so that we can use it with markers
	    };
	  },

	  props: {
	    /**
	     * The zoom of the panorama, specified as a number. A zoom of 0 gives a 180 degrees Field of View.
	     * @value number
	     * @see [StreetViewPanorama zoom](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanoramaOptions.zoom)
	     */
	    zoom: {
	      type: Number,
	      "default": undefined
	    },
	    /**
	     * The camera orientation, specified as heading and pitch, for the panorama.
	     * @value object
	     * @type StreetViewPov
	     * @see [StreetViewPanorama pov](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanoramaOptions.pov)
	     */
	    pov: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The LatLng position of the Street View panorama.
	     * @value object
	     * @type LatLng|LatLngLiteral
	     * @see [StreetViewPanorama position](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanoramaOptions.position)
	     */
	    position: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * The panorama ID, which should be set when specifying a custom panorama.
	     * @value string
	     * @see [StreetViewPanorama pano](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanoramaOptions.pano)
	     */
	    pano: {
	      type: String,
	      "default": undefined
	    },
	    /**
	     * Whether motion tracking is on or off. Enabled by default when the motion tracking control is present, so that the POV (point of view) follows the orientation of the device. This is primarily applicable to mobile devices. If motionTracking is set to false while motionTrackingControl is enabled, the motion tracking control appears but tracking is off. The user can tap the motion tracking control to toggle this option.
	     * @value boolean
	     * @see [StreetViewPanorama motionTracking](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanoramaOptions.motionTracking)
	     */
	    motionTracking: {
	      type: Boolean
	    },
	    /**
	     * If true, the Street View panorama is visible on load.
	     * @value boolean
	     * @see [StreetViewPanorama visible](https://developers.google.com/maps/documentation/javascript/reference/street-view?hl=es#StreetViewPanoramaOptions.visible)
	     */
	    visible: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * More options that you can pass to the component
	     * @value boolean
	     */
	    options: {
	      type: Object,
	      "default": undefined
	    }
	  },
	  replace: false,
	  // necessary for css styles
	  computed: {
	    finalLat: function finalLat() {
	      return this.position && typeof this.position.lat === 'function' ? this.position.lat() : this.position.lat;
	    },
	    finalLng: function finalLng() {
	      return this.position && typeof this.position.lng === 'function' ? this.position.lng() : this.position.lng;
	    },
	    finalLatLng: function finalLatLng() {
	      return {
	        lat: this.finalLat,
	        lng: this.finalLng
	      };
	    }
	  },
	  watch: {
	    zoom: function zoom(_zoom) {
	      if (this.$panoObject) {
	        this.$panoObject.setZoom(_zoom);
	      }
	    }
	  },
	  mounted: function mounted() {
	    var _this2 = this;
	    var events = ['closeclick', 'status_changed'];
	    return this.$gmapApiPromiseLazy().then(function () {
	      // getting the DOM element where to create the map
	      var element = _this2.$refs['vue-street-view-pano'];

	      // creating the map
	      var options = _extends({}, _this2.options, getPropsValues(_this2, streetViewPanoramaMappedProps));
	      var extraOptions = options.options,
	        finalOptions = _objectWithoutPropertiesLoose(options, _excluded$h);
	      _this2.$panoObject = new google.maps.StreetViewPanorama(element, finalOptions);

	      // binding properties (two and one way)
	      bindProps(_this2, _this2.$panoObject, streetViewPanoramaMappedProps);
	      // binding events
	      bindEvents(_this2, _this2.$panoObject, events);

	      // manually trigger position
	      twoWayBindingWrapper(function (increment, decrement, shouldUpdate) {
	        // Panos take a while to load
	        increment();
	        _this2.$panoObject.addListener('position_changed', function () {
	          if (shouldUpdate()) {
	            _this2.$emit('position_changed', _this2.$panoObject.getPosition());
	          }
	          decrement();
	        });
	        var updateCenter = function updateCenter() {
	          increment();
	          _this2.$panoObject.setPosition(_this2.finalLatLng);
	        };
	        watchPrimitiveProperties(_this2, ['finalLat', 'finalLng'], updateCenter);
	      });
	      _this2.$panoPromiseDeferred.resolve(_this2.$panoObject);
	      return _this2.$panoPromise;
	    })["catch"](function (error) {
	      throw error;
	    });
	  },
	  methods: {
	    resize: function resize() {
	      if (this.$panoObject) {
	        google.maps.event.trigger(this.$panoObject, 'resize');
	      }
	    }
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$panoObject && this.$panoObject.setMap) {
	      this.$panoObject.setMap(null);
	    }
	  }
	};

	/* script */
	var __vue_script__$d = script$d;

	/* template */
	var __vue_render__$6 = function __vue_render__() {
	  var _vm = this;
	  var _h = _vm.$createElement;
	  var _c = _vm._self._c || _h;
	  return _c('div', {
	    staticClass: "vue-street-view-pano-container"
	  }, [_c('div', {
	    ref: "vue-street-view-pano",
	    staticClass: "vue-street-view-pano"
	  }), _vm._v(" "), _vm._t("default")], 2);
	};
	var __vue_staticRenderFns__$6 = [];

	/* style */
	var __vue_inject_styles__$d = function __vue_inject_styles__(inject) {
	  if (!inject) return;
	  inject("data-v-32786ad9_0", {
	    source: ".vue-street-view-pano-container{position:relative}.vue-street-view-pano-container .vue-street-view-pano{left:0;right:0;top:0;bottom:0;position:absolute}",
	    map: undefined,
	    media: undefined
	  });
	};
	/* scoped */
	var __vue_scope_id__$d = undefined;
	/* module identifier */
	var __vue_module_identifier__$d = undefined;
	/* functional template */
	var __vue_is_functional_template__$d = false;
	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$d = /*#__PURE__*/normalizeComponent({
	  render: __vue_render__$6,
	  staticRenderFns: __vue_staticRenderFns__$6
	}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, createInjector, undefined, undefined);

	/**
	 * This function allow to auto detect an external load of the Google Maps API
	 * or load it dynamically from our component.
	 *
	 * @param  {Function} resolveFn the function that indicates to the plugin that Google Maps is loaded
	 * @param  {Function} customCallback the custom callback to execute when the plugin load. This option will be removed on the next major release
	 */

	function createCallbackAndChecksIfMapIsLoaded(resolveFn, customCallback) {
	  var callbackExecuted = false;
	  window.GoogleMapsCallback = function () {
	    try {
	      resolveFn();
	      callbackExecuted = true; // TODO: this should be removed on the next major release

	      if (customCallback) {
	        customCallback();
	      }
	    } catch (error) {
	      window.console.error('Error executing the GoogleMapsCallback', error);
	    }
	  };
	  var timeoutId = setTimeout(function () {
	    var intervalId = setInterval(function () {
	      if (timeoutId) {
	        clearTimeout(timeoutId);
	        timeoutId = undefined;
	      }
	      if ((window && window.google && window.google.maps) != null && !callbackExecuted) {
	        window.GoogleMapsCallback();
	        callbackExecuted = true;
	      }
	      if (callbackExecuted) {
	        clearInterval(intervalId);
	        intervalId = undefined;
	      }
	    }, 500);
	  }, 1000);
	}
	/**
	 * This function is a factory of the promise lazy creator
	 * it helps you creating the function that will call the
	 * Google Maps API in an async way
	 *
	 * @param  {Function} googleMapsApiInitializer function that initialize the Google Maps API
	 * @param  {Object} GoogleMapsApi Vue instance that will help to know if the google API object is ready
	 * @returns {Function}
	 */

	function getPromiseLazyCreatorFn(googleMapsApiInitializer, GoogleMapsApi) {
	  /**
	   * The creator of the lazy promise
	   *
	   * @param  {Object|undefined} options=undefined configuration object to initialize the GmapVue plugin
	   * @param  {boolean} options.dynamicLoad=false load the Google Maps API dynamically, if you set this to `true` the plugin doesn't load the Google Maps API
	   * @param  {boolean} options.installComponents=true install all components
	   * @param  {boolean} options.autoBindAllEvents=false auto bind all Google Maps API events
	   * @param  {Object|undefined} options.load=undefined options to configure the Google Maps API
	   * @param  {string} options.load.key your Google Maps API key
	   * @param  {string} options.load.libraries=places the Google Maps libraries that you will use eg: 'places,drawing,visualization'
	   * @param  {string|undefined} options.load.v=undefined the Google Maps API version, default latest
	   * @param  {string|undefined} options.load.callback=GoogleMapsCallback This must be ignored if have another callback that you need to run when Google Maps API is ready please use the `customCallback` option.
	   * @param  {string|undefined} options.load.customCallback=undefined This option was added on v3.0.0 but will be removed in the next major release. If you already have an script tag that loads Google Maps API and you want to use it set you callback in the `customCallback` option and our `GoogleMapsCallback` callback will execute your custom callback at the end; it must attached to the `window` object, is the only requirement.
	   */
	  return function promiseLazyCreator(options) {
	    /**
	     * Things to do once the API is loaded
	     *
	     * @returns {Object} the Google Maps API object
	     */
	    function onMapsReady() {
	      GoogleMapsApi.isReady = true;
	      return window.google;
	    } // If library should load the API

	    if (options && options.load && options.load.key || options.dynamicLoad) {
	      return getLazyValue(function () {
	        // This will only be evaluated once
	        if (typeof window === 'undefined') {
	          // server side -- never resolve this promise
	          return new Promise(function () {}).then(onMapsReady);
	        }
	        return new Promise(function (resolve, reject) {
	          try {
	            createCallbackAndChecksIfMapIsLoaded(resolve, window[options && options.load && options.load.customCallback]);
	            if (!options.dynamicLoad) {
	              googleMapsApiInitializer(options.load, options.loadCn);
	            }
	          } catch (err) {
	            reject(err);
	          }
	        }).then(onMapsReady);
	      });
	    } // If library should not handle API, provide
	    // end-users with the global `GoogleMapsCallback: () => undefined`
	    // when the Google Maps API has been loaded

	    var promise = new Promise(function (resolve) {
	      if (typeof window === 'undefined') {
	        // Do nothing if run from server-side
	        return;
	      }
	      createCallbackAndChecksIfMapIsLoaded(resolve, window[options && options.load && options.load.customCallback]);
	    }).then(onMapsReady);
	    return getLazyValue(function () {
	      return promise;
	    });
	  };
	}

	/**
	 * This function returns the initializer function, it is exported
	 * in that way because we need to generate a closure to define a
	 * private property called `isApiSetUp` to detect if the Google Maps
	 * API was initializer in a previous execution.
	 * The function that it exports is the function that we use inside
	 * of promise-lazy file to initialize the Google Maps API if
	 * it is required.
	 *
	 * @returns {Function} The initializer function
	 */
	function createGoogleMapsAPIInitializer() {
	  var isApiSetUp = false;
	  /**
	   * The initializer function, it adds into the head of the page the Google Maps API script tag to loads the library
	   *
	   * @param {Object|undefined} options=undefined The configuration Object. (@see https://developers.google.com/maps/documentation/javascript/url-params)
	   *                         `libraries`.
	   * @param  {string} options.key Your Google Maps API key
	   * @param  {string} options.libraries=places The Google Maps libraries that you will use eg: 'places,drawing,visualization', can be given as an array too (@see https://developers.google.com/maps/documentation/javascript/libraries)
	   * @param  {string|undefined} options.v=undefined The Google Maps API version, default latest
	   * @param  {string|undefined} options.callback=GoogleMapsCallback This must be ignored if have another callback that you need to run when Google Maps API is ready please use the `customCallback` option.
	   * @param  {string|undefined} options.customCallback=undefined This option was added on v3.0.0 but will be removed in the next major release. If you already have an script tag that loads Google Maps API and you want to use it set you callback in the `customCallback` option and our `GoogleMapsCallback` callback will execute your custom callback at the end; it must attached to the `window` object, is the only requirement.
	   * @param {boolean} loadCn=false    Boolean. If set to true, the map will be loaded from google maps China
	   *                  (@see https://developers.google.com/maps/documentation/javascript/basics#GoogleMapsChina)
	   */

	  var googleMapsAPIInitializer = function googleMapsAPIInitializer(options, loadCn) {
	    /**
	     * Allow options to be an object.
	     * This is to support more esoteric means of loading Google Maps,
	     * such as Google for business
	     * https://developers.google.com/maps/documentation/javascript/get-api-key#premium-auth
	     */
	    if (_typeof$2(options) !== 'object') {
	      throw new Error('options should  be an object');
	    } // Do nothing if run from server-side

	    if (typeof document === 'undefined') {
	      return;
	    }
	    var finalOptions = _objectSpread2$1({}, options);
	    var libraries = finalOptions.libraries;
	    if (!isApiSetUp) {
	      isApiSetUp = true;
	      var baseUrl = typeof loadCn === 'boolean' && loadCn ? 'https://maps.google.cn' : 'https://maps.googleapis.com';
	      var googleMapScript = document.createElement('SCRIPT'); // libraries

	      if (Array.isArray(libraries)) {
	        finalOptions.libraries = libraries.join(',');
	      }
	      finalOptions.callback = 'GoogleMapsCallback';
	      var query = Object.keys(finalOptions).map(function (key) {
	        return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(finalOptions[key]));
	      }).join('&');
	      var url = "".concat(baseUrl, "/maps/api/js?").concat(query);
	      googleMapScript.setAttribute('src', url);
	      googleMapScript.setAttribute('async', '');
	      googleMapScript.setAttribute('defer', '');
	      document.head.appendChild(googleMapScript);
	    } else {
	      window.console.info('You already started the loading of google maps');
	    }
	  };
	  return googleMapsAPIInitializer;
	}
	var googleMapsApiInitializer = createGoogleMapsAPIInitializer();

	/**
	 * HACK: Cluster should be loaded conditionally
	 * However in the web version, it's not possible to write
	 * `import 'gmap-vue/src/components/cluster'`, so we need to
	 * import it anyway (but we don't have to register it)
	 * Therefore we use babel-plugin-transform-inline-environment-variables to
	 * set BUILD_DEV to truthy / falsy
	 */
	// const Cluster = ((s) => s.default || s)(
	//   require('./components/cluster-icon.vue')
	// );

	/**
	 * @var
	 * @type {Object|undefined}
	 *
	 * An independent Vue instance that helps us to know when the Google Maps API is loaded.
	 */

	var GoogleMapsApi; // TODO: analyze the possibility of use globalThis here
	/**
	 * Export all components and mixins
	 * @constant
	 * @type  {Object} components and mixins object
	 * @property  {Object}  HeatmapLayer - Vue component HeatmapLayer
	 * @property  {Object}  KmlLayer - Vue component KmlLayer
	 * @property  {Object}  Marker - Vue component Marker
	 * @property  {Object}  Polyline - Vue component Polyline
	 * @property  {Object}  Polygon - Vue component Polygon
	 * @property  {Object}  Circle - Vue component Circle
	 * @property  {Object}  Cluster - Vue component Cluster
	 * @property  {Object}  Rectangle - Vue component Rectangle
	 * @property  {Object}  DrawingManager - Vue component DrawingManager
	 * @property  {Object}  InfoWindow - Vue component InfoWindow
	 * @property  {Object}  MapLayer - Vue component MapLayer
	 * @property  {Object}  PlaceInput - Vue component PlaceInput
	 * @property  {Object}  Autocomplete - Vue component Autocomplete
	 * @property  {Object}  StreetViewPanorama - Vue component StreetViewPanorama
	 * @property  {Object}  MapElementMixin - Vue component MapElementMixin
	 * @property  {Object}  MountableMixin - Vue component MountableMixin
	 */

	var components = {
	  HeatmapLayer: __vue_component__$4,
	  KmlLayer: __vue_component__$6,
	  Marker: __vue_component__$8,
	  Polyline: __vue_component__$b,
	  Polygon: __vue_component__$a,
	  Circle: __vue_component__$1,
	  Cluster: __vue_component__$2,
	  Rectangle: __vue_component__$c,
	  DrawingManager: __vue_component__$3,
	  InfoWindow: __vue_component__$5,
	  MapLayer: __vue_component__$7,
	  PlaceInput: __vue_component__$9,
	  Autocomplete: __vue_component__,
	  StreetViewPanorama: __vue_component__$d,
	  MapElementMixin: mapElementMixin,
	  MountableMixin: mountableMixin
	};
	/**
	 * GmapVue install function
	 *
	 * @param  {Object} Vue the vue instance
	 * @param  {Object|undefined} options=undefined configuration object to initialize the GmapVue plugin
	 * @param  {boolean} options.dynamicLoad=false load the Google Maps API dynamically, if you set this to `true` the plugin doesn't load the Google Maps API
	 * @param  {boolean} options.installComponents=true install all components
	 * @param  {boolean} options.autoBindAllEvents=false auto bind all Google Maps API events
	 * @param  {Object|undefined} options.load=undefined options to configure the Google Maps API
	 * @param  {string} options.load.key your Google Maps API key
	 * @param  {string} options.load.libraries=places the Google Maps libraries that you will use eg: 'places,drawing,visualization'
	 * @param  {string|undefined} options.load.v=undefined the Google Maps API version, default latest
	 * @param  {string|undefined} options.load.callback=GoogleMapsCallback This must be ignored if have another callback that you need to run when Google Maps API is ready please use the `customCallback` option.
	 * @param  {string|undefined} options.load.customCallback=undefined This option was added on v3.0.0 but will be removed in the next major release. If you already have an script tag that loads Google Maps API and you want to use it set you callback in the `customCallback` option and our `GoogleMapsCallback` callback will execute your custom callback at the end; it must attached to the `window` object, is the only requirement.
	 */

	function gmapVuePluginInstallFn(Vue, options) {
	  // see defaults
	  var finalOptions = _objectSpread2$1({
	    dynamicLoad: false,
	    installComponents: true,
	    autoBindAllEvents: false,
	    load: {
	      libraries: 'places'
	    }
	  }, options);
	  /**
	   * Update the global `GoogleMapsApi`. This will allow
	   * components to use the `google` global reactively
	   * via:
	   *   import { getGoogleMapsAPI } from 'gmap-vue'
	   *   export default {  computed: { google: getGoogleMapsAPI }  }
	   */

	  GoogleMapsApi = new Vue({
	    data: {
	      isReady: false
	    }
	  });
	  var defaultResizeBus = new Vue();
	  /**
	   * Use a lazy to only load the API when
	   * a GMap component is loaded
	   *
	   * @constant
	   * @type {Function} the promise lazy creator function
	   */

	  var promiseLazyCreator = getPromiseLazyCreatorFn(googleMapsApiInitializer, GoogleMapsApi);
	  /**
	   * The gmapApiPromiseLazy function to can wait until Google Maps API is ready
	   *
	   * @constant
	   * @type {Function}
	   */

	  var gmapApiPromiseLazy = promiseLazyCreator(finalOptions);
	  /**
	   * Instance properties
	   *
	   * In every component you have a references to
	   * this.$gmapDefaultResizeBus - function to use the default resize bus
	   * this.$gmapApiPromiseLazy - function that you can use to wait until Google Maps API is ready
	   * this.$gmapOptions - object with the final options passed to Google Maps API to configure it
	   */

	  Vue.mixin({
	    created: function created() {
	      this.$gmapDefaultResizeBus = defaultResizeBus;
	      this.$gmapApiPromiseLazy = gmapApiPromiseLazy;
	      this.$gmapOptions = finalOptions;
	    }
	  });
	  /**
	   * Static properties
	   *
	   * These properties are the same references that you can find in the instance
	   * but they are static because they are attached to the main Vue object.
	   * Vue.$gmapDefaultResizeBus - function to use the default resize bus
	   * Vue.$gmapApiPromiseLazy - function that you can use to wait until Google Maps API is ready
	   * Vue.$gmapOptions - object with the final options passed to Google Maps API to configure it
	   */

	  Vue.$gmapDefaultResizeBus = defaultResizeBus;
	  Vue.$gmapApiPromiseLazy = gmapApiPromiseLazy;
	  Vue.$gmapOptions = finalOptions;
	  if (finalOptions.installComponents) {
	    Vue.component('GmapMap', __vue_component__$7);
	    Vue.component('GmapMarker', __vue_component__$8);
	    Vue.component('GmapInfoWindow', __vue_component__$5);
	    Vue.component('GmapHeatmapLayer', __vue_component__$4);
	    Vue.component('GmapKmlLayer', __vue_component__$6);
	    Vue.component('GmapPolyline', __vue_component__$b);
	    Vue.component('GmapPolygon', __vue_component__$a);
	    Vue.component('GmapCircle', __vue_component__$1);
	    Vue.component('GmapRectangle', __vue_component__$c);
	    Vue.component('GmapDrawingManager', __vue_component__$3);
	    Vue.component('GmapAutocomplete', __vue_component__);
	    Vue.component('GmapPlaceInput', __vue_component__$9);
	    Vue.component('GmapStreetViewPanorama', __vue_component__$d);
	  }
	}
	/**
	 * Export default of the default Vue object for plugins
	 * Export for ESM modules
	 *
	 * @property {Function} install function to install the plugin
	 * @see gmapVuePluginInstallFn
	 */

	var main = {
	  install: gmapVuePluginInstallFn
	};

	/**
	 * Copyright (c) 2011, Sun Ning.
	 *
	 * Permission is hereby granted, free of charge, to any person
	 * obtaining a copy of this software and associated documentation
	 * files (the "Software"), to deal in the Software without
	 * restriction, including without limitation the rights to use, copy,
	 * modify, merge, publish, distribute, sublicense, and/or sell copies
	 * of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 *
	 */

	var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
	var BASE32_CODES_DICT = {};
	for (var i = 0; i < BASE32_CODES.length; i++) {
	  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;
	}
	var ENCODE_AUTO = 'auto';
	var MIN_LAT = -90;
	var MAX_LAT = 90;
	var MIN_LON = -180;
	var MAX_LON = 180;
	/**
	 * Significant Figure Hash Length
	 *
	 * This is a quick and dirty lookup to figure out how long our hash
	 * should be in order to guarantee a certain amount of trailing
	 * significant figures. This was calculated by determining the error:
	 * 45/2^(n-1) where n is the number of bits for a latitude or
	 * longitude. Key is # of desired sig figs, value is minimum length of
	 * the geohash.
	 * @type Array
	 */
	//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10
	var SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];
	/**
	 * Encode
	 *
	 * Create a Geohash out of a latitude and longitude that is
	 * `numberOfChars` long.
	 *
	 * @param {Number|String} latitude
	 * @param {Number|String} longitude
	 * @param {Number} numberOfChars
	 * @returns {String}
	 */
	var encode$1 = function encode(latitude, longitude, numberOfChars) {
	  if (numberOfChars === ENCODE_AUTO) {
	    if (typeof latitude === 'number' || typeof longitude === 'number') {
	      throw new Error('string notation required for auto precision.');
	    }
	    var decSigFigsLat = latitude.split('.')[1].length;
	    var decSigFigsLong = longitude.split('.')[1].length;
	    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);
	    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];
	  } else if (numberOfChars === undefined) {
	    numberOfChars = 9;
	  }
	  var chars = [],
	    bits = 0,
	    bitsTotal = 0,
	    hash_value = 0,
	    maxLat = MAX_LAT,
	    minLat = MIN_LAT,
	    maxLon = MAX_LON,
	    minLon = MIN_LON,
	    mid;
	  while (chars.length < numberOfChars) {
	    if (bitsTotal % 2 === 0) {
	      mid = (maxLon + minLon) / 2;
	      if (longitude > mid) {
	        hash_value = (hash_value << 1) + 1;
	        minLon = mid;
	      } else {
	        hash_value = (hash_value << 1) + 0;
	        maxLon = mid;
	      }
	    } else {
	      mid = (maxLat + minLat) / 2;
	      if (latitude > mid) {
	        hash_value = (hash_value << 1) + 1;
	        minLat = mid;
	      } else {
	        hash_value = (hash_value << 1) + 0;
	        maxLat = mid;
	      }
	    }
	    bits++;
	    bitsTotal++;
	    if (bits === 5) {
	      var code = BASE32_CODES[hash_value];
	      chars.push(code);
	      bits = 0;
	      hash_value = 0;
	    }
	  }
	  return chars.join('');
	};

	/**
	 * Encode Integer
	 *
	 * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.
	 *
	 * @param {Number} latitude
	 * @param {Number} longitude
	 * @param {Number} bitDepth
	 * @returns {Number}
	 */
	var encode_int = function encode_int(latitude, longitude, bitDepth) {
	  bitDepth = bitDepth || 52;
	  var bitsTotal = 0,
	    maxLat = MAX_LAT,
	    minLat = MIN_LAT,
	    maxLon = MAX_LON,
	    minLon = MIN_LON,
	    mid,
	    combinedBits = 0;
	  while (bitsTotal < bitDepth) {
	    combinedBits *= 2;
	    if (bitsTotal % 2 === 0) {
	      mid = (maxLon + minLon) / 2;
	      if (longitude > mid) {
	        combinedBits += 1;
	        minLon = mid;
	      } else {
	        maxLon = mid;
	      }
	    } else {
	      mid = (maxLat + minLat) / 2;
	      if (latitude > mid) {
	        combinedBits += 1;
	        minLat = mid;
	      } else {
	        maxLat = mid;
	      }
	    }
	    bitsTotal++;
	  }
	  return combinedBits;
	};

	/**
	 * Decode Bounding Box
	 *
	 * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]
	 * @param {String} hash_string
	 * @returns {Array}
	 */
	var decode_bbox = function decode_bbox(hash_string) {
	  var isLon = true,
	    maxLat = MAX_LAT,
	    minLat = MIN_LAT,
	    maxLon = MAX_LON,
	    minLon = MIN_LON,
	    mid;
	  var hashValue = 0;
	  for (var i = 0, l = hash_string.length; i < l; i++) {
	    var code = hash_string[i].toLowerCase();
	    hashValue = BASE32_CODES_DICT[code];
	    for (var bits = 4; bits >= 0; bits--) {
	      var bit = hashValue >> bits & 1;
	      if (isLon) {
	        mid = (maxLon + minLon) / 2;
	        if (bit === 1) {
	          minLon = mid;
	        } else {
	          maxLon = mid;
	        }
	      } else {
	        mid = (maxLat + minLat) / 2;
	        if (bit === 1) {
	          minLat = mid;
	        } else {
	          maxLat = mid;
	        }
	      }
	      isLon = !isLon;
	    }
	  }
	  return [minLat, minLon, maxLat, maxLon];
	};

	/**
	 * Decode Bounding Box Integer
	 *
	 * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]
	 * @param {Number} hashInt
	 * @param {Number} bitDepth
	 * @returns {Array}
	 */
	var decode_bbox_int = function decode_bbox_int(hashInt, bitDepth) {
	  bitDepth = bitDepth || 52;
	  var maxLat = MAX_LAT,
	    minLat = MIN_LAT,
	    maxLon = MAX_LON,
	    minLon = MIN_LON;
	  var latBit = 0,
	    lonBit = 0;
	  var step = bitDepth / 2;
	  for (var i = 0; i < step; i++) {
	    lonBit = get_bit(hashInt, (step - i) * 2 - 1);
	    latBit = get_bit(hashInt, (step - i) * 2 - 2);
	    if (latBit === 0) {
	      maxLat = (maxLat + minLat) / 2;
	    } else {
	      minLat = (maxLat + minLat) / 2;
	    }
	    if (lonBit === 0) {
	      maxLon = (maxLon + minLon) / 2;
	    } else {
	      minLon = (maxLon + minLon) / 2;
	    }
	  }
	  return [minLat, minLon, maxLat, maxLon];
	};
	function get_bit(bits, position) {
	  return bits / Math.pow(2, position) & 0x01;
	}

	/**
	 * Decode
	 *
	 * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,
	 * `longitude` and `error`.
	 * @param {String} hashString
	 * @returns {Object}
	 */
	var decode$1 = function decode(hashString) {
	  var bbox = decode_bbox(hashString);
	  var lat = (bbox[0] + bbox[2]) / 2;
	  var lon = (bbox[1] + bbox[3]) / 2;
	  var latErr = bbox[2] - lat;
	  var lonErr = bbox[3] - lon;
	  return {
	    latitude: lat,
	    longitude: lon,
	    error: {
	      latitude: latErr,
	      longitude: lonErr
	    }
	  };
	};

	/**
	 * Decode Integer
	 *
	 * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,
	 * `longitude` and `error`.
	 * @param {Number} hash_int
	 * @param {Number} bitDepth
	 * @returns {Object}
	 */
	var decode_int = function decode_int(hash_int, bitDepth) {
	  var bbox = decode_bbox_int(hash_int, bitDepth);
	  var lat = (bbox[0] + bbox[2]) / 2;
	  var lon = (bbox[1] + bbox[3]) / 2;
	  var latErr = bbox[2] - lat;
	  var lonErr = bbox[3] - lon;
	  return {
	    latitude: lat,
	    longitude: lon,
	    error: {
	      latitude: latErr,
	      longitude: lonErr
	    }
	  };
	};

	/**
	 * Neighbor
	 *
	 * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.
	 * direction [lat, lon], i.e.
	 * [1,0] - north
	 * [1,1] - northeast
	 * ...
	 * @param {String} hashString
	 * @param {Array} Direction as a 2D normalized vector.
	 * @returns {String}
	 */
	var neighbor = function neighbor(hashString, direction) {
	  var lonLat = decode$1(hashString);
	  var neighborLat = lonLat.latitude + direction[0] * lonLat.error.latitude * 2;
	  var neighborLon = lonLat.longitude + direction[1] * lonLat.error.longitude * 2;
	  neighborLon = ensure_valid_lon(neighborLon);
	  neighborLat = ensure_valid_lat(neighborLat);
	  return encode$1(neighborLat, neighborLon, hashString.length);
	};

	/**
	 * Neighbor Integer
	 *
	 * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.
	 * direction [lat, lon], i.e.
	 * [1,0] - north
	 * [1,1] - northeast
	 * ...
	 * @param {String} hash_string
	 * @returns {Array}
	*/
	var neighbor_int = function neighbor_int(hash_int, direction, bitDepth) {
	  bitDepth = bitDepth || 52;
	  var lonlat = decode_int(hash_int, bitDepth);
	  var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;
	  var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;
	  neighbor_lon = ensure_valid_lon(neighbor_lon);
	  neighbor_lat = ensure_valid_lat(neighbor_lat);
	  return encode_int(neighbor_lat, neighbor_lon, bitDepth);
	};

	/**
	 * Neighbors
	 *
	 * Returns all neighbors' hashstrings clockwise from north around to northwest
	 * 7 0 1
	 * 6 x 2
	 * 5 4 3
	 * @param {String} hash_string
	 * @returns {encoded neighborHashList|Array}
	 */
	var neighbors = function neighbors(hash_string) {
	  var hashstringLength = hash_string.length;
	  var lonlat = decode$1(hash_string);
	  var lat = lonlat.latitude;
	  var lon = lonlat.longitude;
	  var latErr = lonlat.error.latitude * 2;
	  var lonErr = lonlat.error.longitude * 2;
	  var neighbor_lat, neighbor_lon;
	  var neighborHashList = [encodeNeighbor(1, 0), encodeNeighbor(1, 1), encodeNeighbor(0, 1), encodeNeighbor(-1, 1), encodeNeighbor(-1, 0), encodeNeighbor(-1, -1), encodeNeighbor(0, -1), encodeNeighbor(1, -1)];
	  function encodeNeighbor(neighborLatDir, neighborLonDir) {
	    neighbor_lat = lat + neighborLatDir * latErr;
	    neighbor_lon = lon + neighborLonDir * lonErr;
	    neighbor_lon = ensure_valid_lon(neighbor_lon);
	    neighbor_lat = ensure_valid_lat(neighbor_lat);
	    return encode$1(neighbor_lat, neighbor_lon, hashstringLength);
	  }
	  return neighborHashList;
	};

	/**
	 * Neighbors Integer
	 *
	 * Returns all neighbors' hash integers clockwise from north around to northwest
	 * 7 0 1
	 * 6 x 2
	 * 5 4 3
	 * @param {Number} hash_int
	 * @param {Number} bitDepth
	 * @returns {encode_int'd neighborHashIntList|Array}
	 */
	var neighbors_int = function neighbors_int(hash_int, bitDepth) {
	  bitDepth = bitDepth || 52;
	  var lonlat = decode_int(hash_int, bitDepth);
	  var lat = lonlat.latitude;
	  var lon = lonlat.longitude;
	  var latErr = lonlat.error.latitude * 2;
	  var lonErr = lonlat.error.longitude * 2;
	  var neighbor_lat, neighbor_lon;
	  var neighborHashIntList = [encodeNeighbor_int(1, 0), encodeNeighbor_int(1, 1), encodeNeighbor_int(0, 1), encodeNeighbor_int(-1, 1), encodeNeighbor_int(-1, 0), encodeNeighbor_int(-1, -1), encodeNeighbor_int(0, -1), encodeNeighbor_int(1, -1)];
	  function encodeNeighbor_int(neighborLatDir, neighborLonDir) {
	    neighbor_lat = lat + neighborLatDir * latErr;
	    neighbor_lon = lon + neighborLonDir * lonErr;
	    neighbor_lon = ensure_valid_lon(neighbor_lon);
	    neighbor_lat = ensure_valid_lat(neighbor_lat);
	    return encode_int(neighbor_lat, neighbor_lon, bitDepth);
	  }
	  return neighborHashIntList;
	};

	/**
	 * Bounding Boxes
	 *
	 * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars
	 * @param {Number} minLat
	 * @param {Number} minLon
	 * @param {Number} maxLat
	 * @param {Number} maxLon
	 * @param {Number} numberOfChars
	 * @returns {bboxes.hashList|Array}
	 */
	var bboxes = function bboxes(minLat, minLon, maxLat, maxLon, numberOfChars) {
	  numberOfChars = numberOfChars || 9;
	  var hashSouthWest = encode$1(minLat, minLon, numberOfChars);
	  var hashNorthEast = encode$1(maxLat, maxLon, numberOfChars);
	  var latLon = decode$1(hashSouthWest);
	  var perLat = latLon.error.latitude * 2;
	  var perLon = latLon.error.longitude * 2;
	  var boxSouthWest = decode_bbox(hashSouthWest);
	  var boxNorthEast = decode_bbox(hashNorthEast);
	  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);
	  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);
	  var hashList = [];
	  for (var lat = 0; lat <= latStep; lat++) {
	    for (var lon = 0; lon <= lonStep; lon++) {
	      hashList.push(neighbor(hashSouthWest, [lat, lon]));
	    }
	  }
	  return hashList;
	};

	/**
	 * Bounding Boxes Integer
	 *
	 * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth
	 * @param {Number} minLat
	 * @param {Number} minLon
	 * @param {Number} maxLat
	 * @param {Number} maxLon
	 * @param {Number} bitDepth
	 * @returns {bboxes_int.hashList|Array}
	 */
	var bboxes_int = function bboxes_int(minLat, minLon, maxLat, maxLon, bitDepth) {
	  bitDepth = bitDepth || 52;
	  var hashSouthWest = encode_int(minLat, minLon, bitDepth);
	  var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);
	  var latlon = decode_int(hashSouthWest, bitDepth);
	  var perLat = latlon.error.latitude * 2;
	  var perLon = latlon.error.longitude * 2;
	  var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);
	  var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);
	  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);
	  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);
	  var hashList = [];
	  for (var lat = 0; lat <= latStep; lat++) {
	    for (var lon = 0; lon <= lonStep; lon++) {
	      hashList.push(neighbor_int(hashSouthWest, [lat, lon], bitDepth));
	    }
	  }
	  return hashList;
	};
	function ensure_valid_lon(lon) {
	  if (lon > MAX_LON) return MIN_LON + lon % MAX_LON;
	  if (lon < MIN_LON) return MAX_LON + lon % MAX_LON;
	  return lon;
	}
	function ensure_valid_lat(lat) {
	  if (lat > MAX_LAT) return MAX_LAT;
	  if (lat < MIN_LAT) return MIN_LAT;
	  return lat;
	}
	var geohash = {
	  'ENCODE_AUTO': ENCODE_AUTO,
	  'encode': encode$1,
	  'encode_uint64': encode_int,
	  // keeping for backwards compatibility, will deprecate
	  'encode_int': encode_int,
	  'decode': decode$1,
	  'decode_int': decode_int,
	  'decode_uint64': decode_int,
	  // keeping for backwards compatibility, will deprecate
	  'decode_bbox': decode_bbox,
	  'decode_bbox_uint64': decode_bbox_int,
	  // keeping for backwards compatibility, will deprecate
	  'decode_bbox_int': decode_bbox_int,
	  'neighbor': neighbor,
	  'neighbor_int': neighbor_int,
	  'neighbors': neighbors,
	  'neighbors_int': neighbors_int,
	  'bboxes': bboxes,
	  'bboxes_int': bboxes_int
	};
	var main$1 = geohash;

	var setStreaming = lib_5.setStreaming,
	  setQueryOptions$c = lib_5.setQueryOptions,
	  updateQuery$d = lib_5.updateQuery,
	  loadMore$1 = lib_5.loadMore,
	  setValue$3 = lib_5.setValue,
	  updateComponentProps$3 = lib_5.updateComponentProps,
	  setDefaultQuery$8 = lib_5.setDefaultQuery,
	  recordResultClick$1 = lib_5.recordResultClick,
	  setMapData = lib_5.setMapData;
	var isEqual$h = lib_8.isEqual,
	  getQueryOptions$5 = lib_8.getQueryOptions,
	  getClassName$h = lib_8.getClassName,
	  parseHits$2 = lib_8.parseHits,
	  getOptionsFromQuery$4 = lib_8.getOptionsFromQuery,
	  getResultStats$4 = lib_8.getResultStats;

	// default map center
	var MAP_CENTER = {
	  lat: 37.7749,
	  lng: 122.4194
	};
	var style = {
	  width: '100%',
	  height: '100vh',
	  position: 'relative'
	};
	function getPrecision(a) {
	  if (isNaN(a)) return 0; // eslint-disable-line
	  var e = 1;
	  var p = 0;
	  while (Math.round(a * e) / e !== a) {
	    e *= 10;
	    p += 1;
	  }
	  return p;
	}
	function withDistinctLat(loc, count) {
	  var length = getPrecision(loc.lat);
	  var noiseFactor = length >= 6 ? 4 : length - 2;
	  // eslint-disable-next-line
	  var suffix = 1 / Math.pow(10, noiseFactor) * count;
	  var location = _extends({}, loc, {
	    lat: parseFloat((loc.lat + suffix).toFixed(length))
	  });
	  return location;
	}
	function getLocationObject(location) {
	  var resultType = Array.isArray(location) ? 'array' : typeof location;
	  switch (resultType) {
	    case 'string':
	      {
	        if (location.indexOf(',') > -1) {
	          var locationSplit = location.split(',');
	          return {
	            lat: parseFloat(locationSplit[0]),
	            lng: parseFloat(locationSplit[1])
	          };
	        }
	        var locationDecode = main$1.decode(location);
	        return {
	          lat: locationDecode.latitude,
	          lng: locationDecode.longitude
	        };
	      }
	    case 'array':
	      {
	        return {
	          lat: location[1],
	          lng: location[0]
	        };
	      }
	    default:
	      {
	        return location;
	      }
	  }
	}
	var ReactiveMap = {
	  name: 'ReactiveMap',
	  props: {
	    className: types.string,
	    componentId: types.stringRequired,
	    dataField: types.stringRequired,
	    react: types.react,
	    size: types.number,
	    sortBy: types.sortBy,
	    URLParams: VueTypes.bool,
	    autoCenter: VueTypes.bool,
	    getMapRef: VueTypes.func.isRequired,
	    getMapPromise: VueTypes.func,
	    center: types.location,
	    defaultCenter: types.location,
	    defaultPin: types.string,
	    defaultZoom: VueTypes.number.def(13),
	    defaultQuery: types.func,
	    innerClass: types.style,
	    loader: types.title,
	    render: types.func,
	    renderItem: types.func,
	    renderError: types.title,
	    pages: VueTypes.number.def(5),
	    currentPage: VueTypes.number.def(0),
	    pagination: VueTypes.bool,
	    showMarkers: VueTypes.bool,
	    defaultSearchAsMove: VueTypes.bool,
	    showSearchAsMove: VueTypes.bool,
	    defaultRadius: types.number,
	    unit: types.string,
	    autoClosePopover: VueTypes.bool,
	    renderMap: VueTypes.func.isRequired,
	    renderPopover: VueTypes.func,
	    calculateMarkers: VueTypes.func,
	    searchAsMoveLabel: VueTypes.string.def('Search as I move the map')
	  },
	  preserveCenter: false,
	  data: function data() {
	    var props = this.$props;
	    var currentPageState = 0;
	    if (props.currentPage) {
	      currentPageState = Math.max(props.currentPage - 1, 0);
	    }
	    this.__state = {
	      from: currentPageState * props.size,
	      zoom: props.defaultZoom,
	      searchAsMove: props.defaultSearchAsMove,
	      currentPageState: currentPageState,
	      mapBoxBounds: null,
	      markersData: null
	    };
	    return this.__state;
	  },
	  computed: {
	    totalPages: function totalPages() {
	      return Math.ceil(this.total / this.$props.size) || 0;
	    },
	    stats: function stats() {
	      var _this$getAllData = this.getAllData(),
	        resultsToRender = _this$getAllData.resultsToRender;
	      return _extends({}, getResultStats$4(this), {
	        currentPage: this.currentPageState,
	        displayedResults: resultsToRender.length
	      });
	    },
	    hasCustomRender: function hasCustomRender() {
	      return hasCustomRenderer(this);
	    }
	  },
	  watch: {
	    defaultZoom: function defaultZoom(newVal) {
	      this.zoom = newVal;
	    },
	    currentPage: function currentPage(newVal, oldVal) {
	      if (oldVal !== newVal && newVal > 0 && newVal <= this.totalPages) {
	        this.setPage(newVal - 1);
	      }
	    },
	    defaultQuery: function defaultQuery(newVal, oldVal) {
	      var _this = this;
	      if (!isQueryIdentical(newVal, oldVal, null, this.$props)) {
	        this.getMapPromise().then(function () {
	          var options = getQueryOptions$5(_this.$props);
	          options.from = 0;
	          _this.$defaultQuery = newVal(null, _this.$props);
	          // Update default query to include the geo bounding box query
	          _this.setDefaultQueryForRSAPI();
	          if (_this.$defaultQuery) {
	            var _ref = _this.$defaultQuery || {},
	              sort = _ref.sort,
	              query = _ref.query;
	            if (sort) {
	              options.sort = _this.$defaultQuery.sort;
	            }
	            var queryOptions = getOptionsFromQuery$4(_this.$defaultQuery);
	            if (queryOptions) {
	              options = _extends({}, options, getOptionsFromQuery$4(_this.$defaultQuery));
	            }
	            // Update calculated default query in store
	            _this.setQueryOptions(_this.$props.componentId, options, false);
	            var persistMapQuery = true;
	            var forceExecute = true;
	            var meta = {
	              mapBoxBounds: _this.mapBoxBounds
	            };
	            _this.setMapData(_this.componentId, query, persistMapQuery, forceExecute, meta);
	            _this.currentPageState = 0;
	            _this.from = 0;
	          }
	        });
	      }
	    },
	    promotedResults: function promotedResults(newVal, oldVal) {
	      if (!isEqual$h(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    hidden: function hidden(newVal, oldVal) {
	      if (!isEqual$h(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    time: function time(newVal, oldVal) {
	      if (!isEqual$h(newVal, oldVal)) {
	        this.$emit('data', this.getData());
	      }
	    },
	    hits: function hits(newVal, oldVal) {
	      this.$emit('data', this.getData());
	      if (this.pagination) {
	        // called when page is changed
	        if (this.isLoading && (oldVal || newVal)) {
	          this.$emit('page-change', this.currentPageState + 1, this.totalPages);
	        }
	      }
	    },
	    rawData: function rawData(newVal, oldVal) {
	      var _this2 = this;
	      if (!isEqual$h(newVal, oldVal)) {
	        var promotedResults = this.promotedResults,
	          hits = this.hits;
	        var results = parseHits$2(hits) || [];
	        var parsedPromotedResults = parseHits$2(promotedResults) || [];
	        var filteredResults = results;
	        if (parsedPromotedResults.length) {
	          var ids = parsedPromotedResults.map(function (item) {
	            return item._id;
	          }).filter(Boolean);
	          if (ids) {
	            filteredResults = filteredResults.filter(function (item) {
	              return !ids.includes(item._id);
	            });
	          }
	          filteredResults = [].concat(parsedPromotedResults, filteredResults);
	        }
	        filteredResults = filteredResults.filter(function (item) {
	          return !!item[_this2.dataField];
	        }).map(function (item) {
	          var _extends2;
	          return _extends({}, item, (_extends2 = {}, _extends2[_this2.dataField] = getLocationObject(item[_this2.dataField]), _extends2));
	        });
	        this.filteredResults = this.addNoise(filteredResults);
	        if (this.calculateMarkers) {
	          this.markersData = this.calculateMarkers({
	            data: this.filteredResults,
	            rawData: this.rawData
	          }) || [];
	        }
	        this.$emit('data', this.getData());
	      }
	    },
	    center: function center(newVal, oldVal) {
	      if (!isEqual$h(newVal, oldVal)) {
	        var persistMapQuery = !!this.center;
	        // we need to forceExecute the query because the center has changed
	        var forceExecute = true;
	        var geoQuery = this.getGeoQuery(this.$props);
	        // Update default query for RS API
	        this.setDefaultQueryForRSAPI();
	        var meta = {
	          mapBoxBounds: this.mapBoxBounds
	        };
	        this.setMapData(this.componentId, geoQuery, persistMapQuery, forceExecute, meta);
	      }
	    }
	  },
	  methods: {
	    parseLocation: function parseLocation(location) {
	      if (Array.isArray(location)) {
	        return {
	          lat: Number(location[0]),
	          lng: Number(location[1])
	        };
	      }
	      return {
	        lat: location ? Number(location.lat) : this.defaultCenter.lat,
	        lng: location ? Number(location.lon === undefined ? location.lng : location.lon) : this.defaultCenter.lng
	      };
	    },
	    getDefaultCenter: function getDefaultCenter() {
	      if (this.defaultCenter) return this.parseLocation(this.defaultCenter);
	      return this.parseLocation(MAP_CENTER);
	    },
	    addNoise: function addNoise(hits) {
	      var _this3 = this;
	      var hitMap = {};
	      var updatedHits = [];
	      hits.forEach(function (item) {
	        var updatedItem = _extends({}, item);
	        var location = _this3.parseLocation(item[_this3.dataField]);
	        var key = JSON.stringify(location);
	        var count = hitMap[key] || 0;
	        updatedItem[_this3.dataField] = count ? withDistinctLat(location, count) : location;
	        updatedHits = [].concat(updatedHits, [updatedItem]);
	        hitMap[key] = count + 1;
	      });
	      return updatedHits;
	    },
	    getPosition: function getPosition(result) {
	      if (result) {
	        return this.parseLocation(result[this.dataField]);
	      }
	      return null;
	    },
	    getHitsCenter: function getHitsCenter(hits) {
	      var _this4 = this;
	      var data = hits.map(function (hit) {
	        return hit[_this4.dataField];
	      });
	      if (data.length) {
	        var numCoords = data.length;
	        var X = 0.0;
	        var Y = 0.0;
	        var Z = 0.0;
	        data.forEach(function (location) {
	          if (location) {
	            var _lat = 0.0;
	            var _lng = 0.0;
	            var locationObj = getLocationObject(location);
	            _lat = locationObj.lat * Math.PI / 180;
	            _lng = (locationObj.lng !== undefined ? locationObj.lng : locationObj.lon) * Math.PI / 180;
	            var a = Math.cos(_lat) * Math.cos(_lng);
	            var b = Math.cos(_lat) * Math.sin(_lng);
	            var c = Math.sin(_lat);
	            X += a;
	            Y += b;
	            Z += c;
	          }
	        });
	        X /= numCoords;
	        Y /= numCoords;
	        Z /= numCoords;
	        var lng = Math.atan2(Y, X);
	        // eslint-disable-next-line
	        var hyp = Math.sqrt(X * X + Y * Y);
	        var lat = Math.atan2(Z, hyp);
	        var newX = lat * 180 / Math.PI;
	        var newY = lng * 180 / Math.PI;
	        return {
	          lat: newX,
	          lng: newY
	        };
	      }
	      return false;
	    },
	    getCenter: function getCenter(hits) {
	      var _this5 = this;
	      if (this.center) {
	        return this.parseLocation(this.center);
	      }
	      var mapRef = this.getMapRef();
	      if (mapRef && typeof mapRef.getCenter === 'function' && this.$options.preserveCenter) {
	        var currentCenter = mapRef.getCenter();
	        setTimeout(function () {
	          _this5.$options.preserveCenter = false;
	        }, 100);
	        return this.parseLocation({
	          lat: currentCenter.lat(),
	          lng: currentCenter.lng()
	        });
	      }
	      if (hits && hits.length) {
	        if (this.autoCenter) {
	          return this.getHitsCenter(hits) || this.getDefaultCenter();
	        }
	        return hits[0] && hits[0][this.dataField] ? this.getPosition(hits[0]) : this.getDefaultCenter();
	      }
	      return this.getDefaultCenter();
	    },
	    handleZoomChange: function handleZoomChange(zoom) {
	      if (zoom) {
	        var prevZoom = this.zoom;
	        if (this.searchAsMove) {
	          this.zoom = zoom;
	          this.$options.preserveCenter = true;
	          this.setGeoQuery(true);
	        } else {
	          this.zoom = zoom;
	        }
	        if (prevZoom !== zoom) {
	          this.$emit('zoom-changed', zoom);
	        }
	      }
	    },
	    handleOnDragEnd: function handleOnDragEnd() {
	      if (this.searchAsMove) {
	        this.$options.preserveCenter = true;
	        this.setGeoQuery(true);
	      }
	      this.$emit('drag-end');
	    },
	    handlePreserveCenter: function handlePreserveCenter(preserveCenter) {
	      this.$options.preserveCenter = preserveCenter;
	    },
	    handleOnIdle: function handleOnIdle() {
	      // only make the geo_bounding query if we have hits data
	      if (this.hits && this.hits.length && this.searchAsMove) {
	        // always execute geo-bounds query when center is set
	        // to improve the specificity of search results
	        var executeUpdate = !!this.center;
	        this.setGeoQuery(executeUpdate);
	      }
	      this.$emit('idle');
	    },
	    setGeoQuery: function setGeoQuery(executeUpdate) {
	      if (executeUpdate === void 0) {
	        executeUpdate = false;
	      }
	      // execute a new query on the initial mount
	      // or whenever searchAsMove is true and the map is dragged
	      if (executeUpdate || !this.skipBoundingBox && !this.mapBoxBounds) {
	        this.$defaultQuery = this.getGeoQuery();
	        if (this.$defaultQuery) {
	          var persistMapQuery = !!this.center;
	          var forceExecute = this.searchAsMove;
	          var meta = {
	            mapBoxBounds: this.mapBoxBounds
	          };
	          this.setMapData(this.componentId, this.$defaultQuery, persistMapQuery, forceExecute, meta);
	        }
	      }
	      this.skipBoundingBox = false;
	    },
	    getMapParams: function getMapParams() {
	      var _this$getData = this.getData(),
	        data = _this$getData.data;
	      var showMarkers = this.showMarkers,
	        defaultPin = this.defaultPin,
	        renderPopover = this.renderPopover,
	        autoClosePopover = this.autoClosePopover,
	        renderItem = this.renderItem;
	      return {
	        resultsToRender: data,
	        center: this.getCenter(data),
	        getPosition: this.getPosition,
	        zoom: this.zoom,
	        renderItem: renderItem,
	        showMarkers: showMarkers,
	        defaultPin: defaultPin,
	        renderPopover: renderPopover,
	        autoClosePopover: autoClosePopover,
	        renderSearchAsMove: this.renderSearchAsMove,
	        handlePreserveCenter: this.handlePreserveCenter,
	        preserveCenter: this.$options.preserveCenter,
	        handleOnDragEnd: this.handleOnDragEnd,
	        handleOnIdle: this.handleOnIdle,
	        handleZoomChange: this.handleZoomChange
	      };
	    },
	    getAllData: function getAllData() {
	      var size = this.size,
	        promotedResults = this.promotedResults,
	        customData = this.customData,
	        currentPage = this.currentPage,
	        hits = this.hits;
	      var results = parseHits$2(hits) || [];
	      var parsedPromotedResults = parseHits$2(promotedResults) || [];
	      var base = currentPage * size;
	      var resultsToRender = this.filteredResults || [];
	      if (this.markersData) {
	        resultsToRender = this.markersData;
	      }
	      return {
	        results: results,
	        resultsToRender: resultsToRender,
	        customData: customData || {},
	        promotedResults: parsedPromotedResults,
	        loadMore: this.loadMore,
	        base: base,
	        triggerClickAnalytics: this.triggerClickAnalytics
	      };
	    },
	    getData: function getData() {
	      var _this$getAllData2 = this.getAllData(),
	        promotedResults = _this$getAllData2.promotedResults,
	        aggregationData = _this$getAllData2.aggregationData,
	        customData = _this$getAllData2.customData,
	        resultsToRender = _this$getAllData2.resultsToRender;
	      return {
	        data: this.withClickIds(resultsToRender),
	        aggregationData: this.withClickIds(aggregationData || []),
	        promotedData: this.withClickIds(promotedResults),
	        rawData: this.rawData,
	        resultStats: this.stats,
	        customData: customData
	      };
	    },
	    getComponent: function getComponent$1() {
	      var error = this.error,
	        isLoading = this.isLoading;
	      var data = _extends({
	        error: error,
	        loading: isLoading,
	        loadMore: this.loadMore,
	        triggerClickAnalytics: this.triggerClickAnalytics,
	        setPage: this.setPage
	      }, this.getData());
	      return getComponent(data, this);
	    },
	    setPage: function setPage(page) {
	      // pageClick will be called every time a pagination button is clicked
	      if (page !== this.currentPageState) {
	        this.$emit('pageClick', page + 1);
	        this.$emit('page-click', page + 1);
	        var value = this.size * page;
	        var options = getQueryOptions$5(this.$props);
	        options.from = this.$data.from;
	        this.from = value;
	        this.currentPageState = page;
	        this.loadMoreAction(this.componentId, _extends({}, options, {
	          from: value
	        }), false);
	        if (this.URLParams) {
	          this.setPageURL(this.componentId, page + 1, this.componentId, false, true);
	        }
	      }
	    },
	    setDefaultQueryForRSAPI: function setDefaultQueryForRSAPI() {
	      if (this.defaultQuery && typeof this.defaultQuery === 'function') {
	        var defaultQuery = this.defaultQuery();
	        this.setDefaultQuery(this.componentId, defaultQuery);
	      }
	    },
	    getArrPosition: function getArrPosition(location) {
	      return {
	        lat: location.lat,
	        lon: location.lon || location.lng
	      };
	    },
	    getGeoQuery: function getGeoQuery(props) {
	      if (props === void 0) {
	        props = this.$props;
	      }
	      this.$defaultQuery = props.defaultQuery ? props.defaultQuery() : null;
	      var mapRef = this.getMapRef();
	      var mapBounds = mapRef && typeof mapRef.getBounds === 'function' ? mapRef.getBounds() : false;
	      var north;
	      var south;
	      var east;
	      var west;
	      if (mapBounds) {
	        var _geo_bounding_box;
	        north = mapBounds.getNorthEast().lat();
	        south = mapBounds.getSouthWest().lat();
	        east = mapBounds.getNorthEast().lng();
	        west = mapBounds.getSouthWest().lng();
	        var boundingBoxCoordinates = {
	          top_left: [west, north],
	          bottom_right: [east, south]
	        };
	        this.mapBoxBounds = boundingBoxCoordinates;
	        var geoQuery = {
	          geo_bounding_box: (_geo_bounding_box = {}, _geo_bounding_box[this.dataField] = boundingBoxCoordinates, _geo_bounding_box)
	        };
	        if (this.$defaultQuery) {
	          var _ref2 = this.$defaultQuery || {},
	            query = _ref2.query;
	          if (query) {
	            // adds defaultQuery's query to geo-query
	            // to generate a map query

	            return {
	              must: [geoQuery, query]
	            };
	          }
	        }
	        return geoQuery;
	      }

	      // return the defaultQuery (if set) or null when map query not available
	      return this.$defaultQuery ? this.$defaultQuery.query : null;
	    },
	    getGeoDistanceQuery: function getGeoDistanceQuery() {
	      var center = this.center || this.defaultCenter;
	      if (center && this.defaultRadius) {
	        var _geo_distance;
	        // skips geo bounding box query on initial load
	        this.skipBoundingBox = true;
	        return {
	          geo_distance: (_geo_distance = {
	            distance: "" + this.defaultRadius + this.unit
	          }, _geo_distance[this.dataField] = this.getArrPosition(center), _geo_distance)
	        };
	      }
	      return null;
	    },
	    loadMore: function loadMore() {
	      if (this.hits && !this.pagination && this.total !== this.hits.length) {
	        var value = this.from + this.size;
	        var options = getQueryOptions$5(this.$props);
	        this.from = value;
	        this.loadMoreAction(this.componentId, _extends({}, options, {
	          from: value
	        }), true);
	      }
	    },
	    triggerClickAnalytics: function triggerClickAnalytics(searchPosition, documentId) {
	      var docId = documentId;
	      if (!docId) {
	        var _this$getData2 = this.getData(),
	          data = _this$getData2.data;
	        var hitData = data.find(function (hit) {
	          return hit._click_id === searchPosition;
	        });
	        if (hitData && hitData._id) {
	          docId = hitData._id;
	        }
	      }
	      this.recordResultClick(searchPosition, docId);
	    },
	    withClickIds: function withClickIds(results) {
	      var _this$getAllData3 = this.getAllData(),
	        base = _this$getAllData3.base;
	      return results.map(function (result, index) {
	        return _extends({}, result, {
	          _click_id: base + index
	        });
	      });
	    },
	    toggleSearchAsMove: function toggleSearchAsMove() {
	      this.searchAsMove = !this.searchAsMove;
	      this.$emit('search-as-move', this.searchAsMove);
	    },
	    renderErrorComponent: function renderErrorComponent() {
	      var renderError = this.$scopedSlots.renderError || this.$props.renderError;
	      if (renderError && this.error && !this.isLoading) {
	        return isFunction$1(renderError) ? renderError(this.error) : renderError;
	      }
	      return null;
	    },
	    renderSearchAsMove: function renderSearchAsMove() {
	      var h = this.$createElement;
	      if (this.showSearchAsMove) {
	        return h("div", {
	          "style": {
	            position: 'absolute',
	            bottom: '30px',
	            left: '10px',
	            width: '240px',
	            backgroundColor: '#fff',
	            padding: '8px 10px',
	            boxShadow: 'rgba(0,0,0,0.3) 0px 1px 4px -1px',
	            borderRadius: 2,
	            zIndex: 10000
	          },
	          "attrs": {
	            "className": getClassName$h(this.innerClass, 'checkboxContainer') || null
	          }
	        }, [h(Checkbox, {
	          "attrs": {
	            "type": "checkbox",
	            "id": this.$props.componentId + "-searchasmove",
	            "checked": this.searchAsMove,
	            "show": true
	          },
	          "class": getClassName$h(this.$props.innerClass, 'checkbox'),
	          "on": {
	            "click": this.toggleSearchAsMove
	          }
	        }), h("label", {
	          "attrs": {
	            "className": getClassName$h(this.innerClass, 'label') || null,
	            "for": this.$props.componentId + "-searchasmove"
	          }
	        }, [this.searchAsMoveLabel])]);
	      }
	      return null;
	    },
	    renderPagination: function renderPagination() {
	      var h = this.$createElement;
	      return h(Pagination, {
	        "attrs": {
	          "pages": this.pages,
	          "totalPages": this.totalPages,
	          "currentPage": this.currentPageState,
	          "setPage": this.setPage,
	          "innerClass": this.innerClass
	        }
	      });
	    }
	  },
	  created: function created() {
	    if (this.defaultPage >= 0) {
	      this.currentPageState = this.defaultPage;
	      this.from = this.currentPageState * this.$props.size;
	    }
	    this.internalComponent = this.$props.componentId + "__internal";
	    this.updateComponentProps(this.componentId, {
	      from: this.from
	    }, constants_1$1.reactiveMap);
	    this.updateComponentProps(this.internalComponent, {
	      from: this.from
	    }, constants_1$1.reactiveMap);
	    this.setDefaultQueryForRSAPI();
	  },
	  mounted: function mounted() {
	    var _this6 = this;
	    this.getMapPromise().then(function () {
	      if (_this6.defaultPage < 0 && _this6.currentPage > 0) {
	        if (_this6.$props.URLParams) {
	          _this6.setPageURL(_this6.$props.componentId, _this6.currentPage, _this6.$props.componentId, false, true);
	        }
	      }
	      var options = getQueryOptions$5(_this6.$props);
	      options.from = _this6.$data.from;
	      if (_this6.$props.sortBy) {
	        var _ref3;
	        options.sort = [(_ref3 = {}, _ref3[_this6.$props.dataField] = {
	          order: _this6.$props.sortBy
	        }, _ref3)];
	      }
	      _this6.$defaultQuery = null;
	      if (_this6.$props.defaultQuery) {
	        _this6.$defaultQuery = _this6.$props.defaultQuery();
	        // Update default query for RS API
	        _this6.setDefaultQueryForRSAPI();
	        if (_this6.$defaultQuery) {
	          options = _extends({}, options, getOptionsFromQuery$4(_this6.$defaultQuery));

	          // Override sort query with defaultQuery's sort if defined
	          if (_this6.$defaultQuery.sort) {
	            options.sort = _this6.$defaultQuery.sort;
	          }
	          // since we want defaultQuery to be executed anytime
	          // map component's query is being executed
	          var persistMapQuery = true;
	          // no need to forceExecute because setReact() will capture the main query
	          // and execute the defaultQuery along with it
	          var forceExecute = false;
	          var meta = {
	            mapBoxBounds: _this6.mapBoxBounds
	          };
	          if (_this6.$defaultQuery) {
	            _this6.setMapData(_this6.componentId, _this6.$defaultQuery.query, persistMapQuery, forceExecute, meta);
	            _this6.setQueryOptions(_this6.componentId, options);
	          }
	        }
	      } else {
	        // only apply geo-distance when defaultQuery prop is not set
	        var query = _this6.getGeoDistanceQuery();
	        if (query) {
	          // - only persist the map query if center prop is set
	          // - ideally, persist the map query if you want to keep executing it
	          //   whenever there is a change (due to subscription) in the component query
	          var _persistMapQuery = !!_this6.center;

	          // - forceExecute will make sure that the component query + Map query gets executed
	          //   irrespective of the changes in the component query
	          // - forceExecute will only come into play when searchAsMove is true
	          // - kindly note that forceExecute may result in one additional network request
	          //   since it bypasses the gatekeeping
	          var _forceExecute = _this6.searchAsMove;
	          // Set meta for `distance` and `coordinates` in selected value
	          var center = _this6.center || _this6.defaultCenter;
	          var coordinatesObject = _this6.getArrPosition(center);
	          var _meta = {
	            distance: _this6.defaultRadius,
	            coordinates: coordinatesObject.lat + ", " + coordinatesObject.lon
	          };
	          _this6.setMapData(_this6.componentId, query, _persistMapQuery, _forceExecute, _meta);
	        }
	        _this6.setQueryOptions(_this6.componentId, options);
	      }
	    });
	  },
	  render: function render() {
	    var h = arguments[0];
	    var loader = this.$scopedSlots.loader || this.$props.loader;
	    return h("div", {
	      "style": _extends({}, style, this.$props.style),
	      "class": this.$props.className
	    }, [this.renderErrorComponent(), this.isLoading && loader, this.hasCustomRender ? this.getComponent() : null, this.renderMap(this.getMapParams()), this.pagination ? this.renderPagination() : null]);
	  }
	};
	var mapStateToProps$i = function mapStateToProps(state, props) {
	  return {
	    defaultPage: state.selectedValues[props.componentId] && state.selectedValues[props.componentId].value - 1 || -1,
	    error: state.error[props.componentId],
	    isLoading: state.isLoading[props.componentId],
	    hits: state.hits[props.componentId] && state.hits[props.componentId].hits,
	    promotedResults: state.promotedResults[props.componentId],
	    customData: state.customData[props.componentId],
	    total: state.hits[props.componentId] && state.hits[props.componentId].total,
	    time: state.hits[props.componentId] && state.hits[props.componentId].time,
	    rawData: state.rawData[props.componentId],
	    hidden: state.hits[props.componentId] && state.hits[props.componentId].hidden
	  };
	};
	var mapDispatchToProps$4 = {
	  loadMoreAction: loadMore$1,
	  setPageURL: setValue$3,
	  setQueryOptions: setQueryOptions$c,
	  setStreaming: setStreaming,
	  updateQuery: updateQuery$d,
	  updateComponentProps: updateComponentProps$3,
	  setDefaultQuery: setDefaultQuery$8,
	  recordResultClick: recordResultClick$1,
	  setMapData: setMapData
	};
	var RMConnected = PreferencesConsumer(ComponentWrapper$1(connect(mapStateToProps$i, mapDispatchToProps$4)(ReactiveMap), {
	  componentType: constants_1$1.reactiveMap,
	  internalComponent: true
	}));
	ReactiveMap.install = function (Vue) {
	  Vue.component(ReactiveMap.name, RMConnected);
	};
	// Add componentType for SSR
	ReactiveMap.componentType = constants_1$1.reactiveMap;

	var infoWindowMappedProps$1 = {
	  content: {
	    type: Object,
	    twoWay: true
	  },
	  options: {
	    type: Object,
	    required: false,
	    "default": function _default() {
	      return {};
	    }
	  },
	  position: {
	    type: Object,
	    twoWay: true
	  },
	  zIndex: {
	    type: Number,
	    twoWay: true
	  }
	};
	/**
	 * This function helps you to bind events from Google Maps API to Vue events
	 *
	 * @param  {Object} vueInst the Vue instance
	 * @param  {Object} googleMapsInst the Google Maps instance
	 * @param  {string[]} events an array of string with all events that you want to bind
	 * @returns {void}
	 */
	function bindEvents$1(vueInst, googleMapsInst, events) {
	  events.forEach(function (eventName) {
	    if (vueInst.$gmapOptions.autoBindAllEvents || vueInst.$listeners[eventName]) {
	      googleMapsInst.addListener(eventName, function (ev) {
	        vueInst.$emit(eventName, ev);
	      });
	    }
	  });
	}

	/**
	 * Function that helps you to capitalize the first letter on a word
	 *
	 * @param  {string} text the text that you want to capitalize
	 * @returns {string}
	 */
	function capitalizeFirstLetter$1(text) {
	  return text.charAt(0).toUpperCase() + text.slice(1);
	}

	/**
	 * Function that helps you to get all non nullable props from a component
	 *
	 * @param  {Object} vueInst the Vue component instance
	 * @param  {Object} props the props object
	 * @returns {Object}
	 */
	function getPropsValues$1(vueInst, props) {
	  return Object.keys(props).reduce(function (acc, prop) {
	    if (vueInst[prop] !== undefined) {
	      acc[prop] = vueInst[prop];
	    }
	    return acc;
	  }, {});
	}

	/**
	 * Watch the individual properties of a PoD object, instead of the object
	 * per se. This is different from a deep watch where both the reference
	 * and the individual values are watched.
	 *
	 * In effect, it throttles the multiple $watch to execute at most once per tick.
	 *
	 * @param  {Object} vueInst the component instance
	 * @param  {string[]} propertiesToTrack string array with all properties that you want to track
	 * @param  {Function} handler function to be fired when the prop change
	 * @param  {boolean} immediate=false
	 * @returns {void}
	 */
	function watchPrimitiveProperties$1(vueInst, propertiesToTrack, handler, immediate) {
	  if (immediate === void 0) {
	    immediate = false;
	  }
	  var isHandled = false;

	  /**
	   * Function in charge to execute the handler function if it was not fired
	   *
	   * @returns void
	   */
	  function requestHandle() {
	    if (!isHandled) {
	      isHandled = true;
	      vueInst.$nextTick(function () {
	        isHandled = false;
	        handler();
	      });
	    }
	  }
	  propertiesToTrack.forEach(function (prop) {
	    vueInst.$watch(prop, requestHandle, {
	      immediate: immediate
	    });
	  });
	}

	/**
	 * Binds the properties defined in props to the google maps instance.
	 * If the prop is an Object type, and we wish to track the properties
	 * of the object (e.g. the lat and lng of a LatLng), then we do a deep
	 * watch. For deep watch, we also prevent the _changed event from being
	 * emitted if the data source was external.
	 *
	 * @param  {Object} vueInst the component instance
	 * @param  {Object} googleMapsInst the Google Maps instance
	 * @param  {Object} props object with the component props tha should be synched with the Google Maps instances props
	 * @returns {void}
	 */
	function bindProps$1(vueInst, googleMapsInst, props) {
	  Object.keys(props).forEach(function (attribute) {
	    var _props$attribute = props[attribute],
	      twoWay = _props$attribute.twoWay,
	      type = _props$attribute.type,
	      trackProperties = _props$attribute.trackProperties,
	      noBind = _props$attribute.noBind;
	    if (!noBind) {
	      var setMethodName = "set" + capitalizeFirstLetter$1(attribute);
	      var getMethodName = "get" + capitalizeFirstLetter$1(attribute);
	      var eventName = attribute.toLowerCase() + "_changed";
	      var initialValue = vueInst[attribute];
	      if (typeof googleMapsInst[setMethodName] === 'undefined') {
	        throw new Error( // TODO: Analyze all disabled rules in the file
	        // eslint-disable-next-line no-underscore-dangle -- old code should be analyzed
	        setMethodName + " is not a method of (the Maps object corresponding to) " + vueInst.$options._componentTag);
	      }

	      // We need to avoid an endless
	      // propChanged -> event emitted -> propChanged -> event emitted loop
	      // although this may really be the user's responsibility
	      if (type !== Object || !trackProperties) {
	        // Track the object deeply
	        vueInst.$watch(attribute, function () {
	          var attributeValue = vueInst[attribute];
	          googleMapsInst[setMethodName](attributeValue);
	        }, {
	          immediate: typeof initialValue !== 'undefined',
	          deep: type === Object
	        });
	      } else {
	        watchPrimitiveProperties$1(vueInst, trackProperties.map(function (prop) {
	          return attribute + "." + prop;
	        }), function () {
	          googleMapsInst[setMethodName](vueInst[attribute]);
	        }, vueInst[attribute] !== undefined);
	      }
	      if (twoWay && (vueInst.$gmapOptions.autoBindAllEvents || vueInst.$listeners[eventName])) {
	        googleMapsInst.addListener(eventName, function () {
	          vueInst.$emit(eventName, googleMapsInst[getMethodName]());
	        });
	      }
	    }
	  });
	}

	var _excluded$i = ["options", "position"];
	var InfoWindowClusterManager = {
	  name: 'InfoWindowClusterManager',
	  inject: {
	    $markerPromise: {
	      "default": null
	    },
	    $mapPromise: {}
	  },
	  provide: function provide() {
	    var _this = this;
	    var events = ['domready', 'closeclick', 'content_changed'];
	    // Infowindow needs this to be immediately available
	    var promise = this.$mapPromise.then(function (map) {
	      _this.$map = map;
	      // Initialize the maps with the given options
	      var initialOptions = _extends({}, _this.options, {
	        map: map
	      }, getPropsValues$1(_this, infoWindowMappedProps$1));
	      var extraOptions = initialOptions.options,
	        position = initialOptions.position,
	        finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$i);
	      finalOptions.content = _this.$refs.flyaway;
	      if (_this.$markerPromise) {
	        _this.$markerPromise.then(function (markerObject) {
	          _this.$markerObject = markerObject;
	          // eslint-disable-next-line
	          _this.$infoWindowObject = new google.maps.InfoWindow(finalOptions);
	          bindProps$1(_this, _this.$infoWindowObject, infoWindowMappedProps$1);
	          bindEvents$1(_this, _this.$infoWindowObject, events);
	          // TODO: This function names should be analyzed
	          /* eslint-disable no-underscore-dangle -- old style */
	          _this._openInfoWindow();
	          _this.$watch('opened', function () {
	            _this._openInfoWindow();
	          });
	          /* eslint-enable no-underscore-dangle */
	          return _this.$infoWindowObject;
	        });
	      }
	    })["catch"](function (error) {
	      throw error;
	    });
	    // TODO: analyze the efects of only returns the instance and remove completely the promise
	    this.$infoWindowPromise = promise;
	    return {
	      $infoWindowPromise: promise
	    };
	  },
	  props: {
	    /**
	     * NOTE: This prop overrides the content of the default slot, use only one of them, not both at the same time
	     * Content to display in the InfoWindow. This can be an HTML element, a plain-text string, or a string containing HTML. The InfoWindow will be sized according to the content. To set an explicit size for the content, set content to be a HTML element with that size.
	     * @value undefined
	     * @see [InfoWindow content](https://developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindowOptions.content)
	     */
	    content: {
	      type: [String, Object],
	      "default": undefined
	    },
	    /**
	     * Determines if the info-window is open or not
	     */
	    opened: {
	      type: Boolean,
	      "default": true
	    },
	    /**
	     * Contains the LatLng at which this info window is anchored.
	     * Note: An InfoWindow may be attached either to a Marker object
	     * (in which case its position is based on the marker's location)
	     * or on the map itself at a specified LatLng.
	     *
	     * The LatLng at which to display this InfoWindow. If the InfoWindow is opened with an anchor, the anchor's position will be used instead.
	     * @value undefined
	     * @type LatLng|LatLngLiteral
	     * @see [InfoWindow position](https://developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindowOptions.position)
	     */
	    position: {
	      type: Object,
	      "default": undefined
	    },
	    /**
	     * All InfoWindows are displayed on the map in order of their zIndex, with higher values displaying in front of InfoWindows with lower values. By default, InfoWindows are displayed according to their latitude, with InfoWindows of lower latitudes appearing in front of InfoWindows at higher latitudes. InfoWindows are always displayed in front of markers.
	     * @value 0
	     * @see [InfoWindow position](https://developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindowOptions.zIndex)
	     */
	    zIndex: {
	      type: Number,
	      "default": 0
	    },
	    /**
	     * Extra options that you want to pass to the component
	     */
	    options: {
	      type: Object,
	      required: false,
	      "default": undefined
	    }
	  },
	  mounted: function mounted() {
	    var el = this.$refs.flyaway;
	    el.parentNode.removeChild(el);
	  },
	  destroyed: function destroyed() {
	    // Note: not all Google Maps components support maps
	    if (this.$infoWindowObject && this.$infoWindowObject.setMap) {
	      this.$infoWindowObject.setMap(null);
	    }
	  },
	  methods: {
	    // TODO: we need to analyze the following method name
	    // eslint-disable-next-line no-underscore-dangle -- old code
	    _openInfoWindow: function _openInfoWindow() {
	      if (this.opened) {
	        if (this.$markerObject !== null) {
	          this.$infoWindowObject.open(this.$map, this.$markerObject);
	        } else {
	          this.$infoWindowObject.open(this.$map);
	        }
	      } else {
	        this.$infoWindowObject.close();
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    return h("div", [h("div", {
	      "ref": "flyaway"
	    }, [this.$scopedSlots["default"]()])]);
	  }
	};

	var InfoWindowWrapper = {
	  name: 'InfoWindowWrapperClusterManager',
	  props: {
	    id: VueTypes.string,
	    renderPopover: VueTypes.func,
	    infoWindowProps: VueTypes.object,
	    events: VueTypes.object,
	    marker: VueTypes.Object
	  },
	  data: function data() {
	    return {
	      infoWindowRef: null
	    };
	  },
	  provide: function provide() {
	    return {
	      $markerPromise: Promise.resolve(this.marker)
	    };
	  },
	  mounted: function mounted() {
	    this.infoWindowRef = this.$refs[this.id + "-Info-Window"];
	  },
	  methods: {
	    handleClose: function handleClose() {
	      this.infoWindowRef.$infoWindowObject.close();
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var renderPopover = this.renderPopover,
	      events = this.events;
	    return h(InfoWindowClusterManager, {
	      "ref": this.id + "-Info-Window",
	      "props": _extends({}, this.infoWindowProps),
	      "on": _extends({}, events)
	    }, [h("div", [renderPopover(this.handleClose)])]);
	  }
	};

	var _excluded$j = ["options"];
	var isEqual$i = lib_8.isEqual;
	var recordResultClick$2 = lib_5.recordResultClick;
	var ClusterMarkers = {
	  name: 'ClusterMarkers',
	  props: {
	    markers: VueTypes.array,
	    getPosition: VueTypes.func,
	    defaultPin: VueTypes.string,
	    renderItem: VueTypes.func,
	    markerProps: VueTypes.object,
	    handlePreserveCenter: VueTypes.func.isRequired,
	    autoClosePopover: VueTypes.bool,
	    renderPopover: VueTypes.func,
	    highlightMarkerOnHover: VueTypes.bool
	  },
	  inject: {
	    $clusterPromise: {
	      "default": null
	    },
	    $mapPromise: {}
	  },
	  data: function data() {
	    return {
	      openMarkers: {}
	    };
	  },
	  mounted: function mounted() {
	    this.buildMarkers(this.markers);
	  },
	  destroy: function destroy() {
	    // Remove active markers
	    this.buildMarkers([]);
	  },
	  watch: {
	    markers: function markers(newVal, oldVal) {
	      if (!isEqual$i(oldVal, newVal)) {
	        this.buildMarkers(newVal);
	      }
	    }
	  },
	  methods: {
	    triggerAnalytics: function triggerAnalytics(clickPosition, markerId) {
	      this.recordResultClick(clickPosition, markerId);
	    },
	    setOpenMarkers: function setOpenMarkers(openMarkers) {
	      this.openMarkers = openMarkers;
	    },
	    closeMarker: function closeMarker(marker) {
	      var _this$$props = this.$props,
	        autoClosePopover = _this$$props.autoClosePopover,
	        handlePreserveCenter = _this$$props.handlePreserveCenter;
	      var id = marker.metaData && marker.metaData._id;
	      var _this$openMarkers = this.openMarkers,
	        del = _this$openMarkers[id],
	        activeMarkers = _objectWithoutPropertiesLoose(_this$openMarkers, [id].map(_toPropertyKey));
	      var newOpenMarkers = autoClosePopover ? {} : activeMarkers;
	      this.setOpenMarkers(newOpenMarkers);
	      handlePreserveCenter(true);
	      this.$emit('close-marker-popover', marker);
	    },
	    openMarker: function openMarker(marker, index) {
	      var _ref, _extends2;
	      var autoClosePopover = this.autoClosePopover,
	        handlePreserveCenter = this.handlePreserveCenter;
	      var id = marker.metaData && marker.metaData._id;
	      var newOpenMarkers = autoClosePopover ? (_ref = {}, _ref[id] = marker, _ref) : _extends({}, this.openMarkers, (_extends2 = {}, _extends2[id] = marker, _extends2));
	      this.setOpenMarkers(newOpenMarkers);
	      handlePreserveCenter(true);
	      this.triggerAnalytics(id, index);
	      this.$emit('open-marker-popover', marker);
	    },
	    removeMarkers: function removeMarkers() {
	      if (this.$clusterObject) {
	        // Remove old markers
	        this.$clusterObject.clearMarkers(true);
	        this.$markers = [];
	      }
	    },
	    buildMarkers: function buildMarkers(markersToRender) {
	      var _this = this;
	      this.$mapPromise.then(function (map) {
	        if (_this.$clusterPromise) {
	          _this.$clusterPromise.then(function (clusterObject) {
	            // Detect changed markers
	            var markersToAdd = [];
	            var markersToRemove = [];
	            // A map of marker id to active status, `true` means marker is active
	            // `false` means marker is stale and should be removed
	            var oldMarkersIdMap = {};
	            (_this.$markers || []).forEach(function (marker) {
	              if (marker.metaData && marker.metaData._id) {
	                // mark all old markers as stale
	                oldMarkersIdMap[marker.metaData._id] = false;
	              }
	            });
	            // build map markers
	            markersToRender.forEach(function (marker, index) {
	              // Avoid if a marker is already rendered
	              if (marker._id && oldMarkersIdMap[marker._id] !== undefined) {
	                // Set old marker as active
	                oldMarkersIdMap[marker._id] = true;
	              } else {
	                // Initialize the maps with the given options
	                var initialOptions = _extends({}, _this.markerProps, {
	                  metaData: marker,
	                  map: map,
	                  position: _this.getPosition(marker)
	                });
	                if (_this.renderItem) {
	                  var data = _this.renderItem(marker);
	                  if ('label' in data) {
	                    initialOptions.label = data.label;
	                  }
	                  if ('icon' in data) {
	                    initialOptions.icon = data.icon;
	                  }
	                } else if (_this.defaultPin) {
	                  initialOptions.icon = {
	                    url: _this.defaultPin
	                  };
	                }
	                var extraOptions = initialOptions.options,
	                  finalOptions = _objectWithoutPropertiesLoose(initialOptions, _excluded$j);
	                if (_this.$clusterPromise) {
	                  finalOptions.map = null;
	                }
	                // eslint-disable-next-line
	                var markerObject = new google.maps.Marker(finalOptions);
	                markerObject.addListener('click', function () {
	                  _this.openMarker(markerObject, index);
	                });
	                markersToAdd.push(markerObject);
	              }
	            });
	            // Current active markers
	            var currentMarkers = [];
	            markersToAdd.forEach(function (marker) {
	              currentMarkers.push(marker);
	            });
	            (_this.$markers || []).forEach(function (marker) {
	              if (marker.metaData && marker.metaData._id) {
	                // if maker is not active then add to remove list
	                if (!oldMarkersIdMap[marker.metaData._id]) {
	                  markersToRemove.push(marker);
	                } else {
	                  currentMarkers.push(marker);
	                }
	              }
	            });
	            // Remove old markers
	            clusterObject.removeMarkers(markersToRemove);
	            // Add inital markers at once
	            clusterObject.addMarkers(markersToAdd);
	            _this.$clusterObject = clusterObject;
	            _this.$map = map;
	            _this.$markers = currentMarkers;
	          });
	        }
	      })["catch"](function (error) {
	        throw error;
	      });
	    }
	  },
	  render: function render() {
	    var _this2 = this;
	    var h = arguments[0];
	    if (!this.renderPopover) {
	      return null;
	    }
	    return h("div", [Object.keys(this.openMarkers).map(function (markerId) {
	      var marker = _this2.openMarkers[markerId];
	      var item = marker.metaData;
	      return h(InfoWindowWrapper, {
	        "key": markerId + "-InfoWindow",
	        "attrs": {
	          "id": markerId,
	          "renderPopover": function renderPopover(_handleClose) {
	            return _this2.renderPopover({
	              item: item,
	              handleClose: function handleClose() {
	                _handleClose();
	                _this2.closeMarker(item);
	              }
	            });
	          },
	          "marker": marker,
	          "infoWindowProps": {
	            zIndex: 500
	          },
	          "events": {
	            closeclick: function closeclick() {
	              return _this2.closeMarker(marker);
	            }
	          }
	        }
	      });
	    })]);
	  }
	};
	var mapDispatchToProps$5 = {
	  recordResultClick: recordResultClick$2
	};
	var ClusterManager = connect(function () {
	  return null;
	}, mapDispatchToProps$5)(ClusterMarkers);

	var InfoWindow = components.InfoWindow;
	var InfoWindowWrapper$1 = {
	  name: 'InfoWindowWrapper',
	  props: {
	    id: VueTypes.string,
	    renderPopover: VueTypes.func,
	    infoWindowProps: VueTypes.object,
	    events: VueTypes.object
	  },
	  data: function data() {
	    return {
	      infoWindowRef: null
	    };
	  },
	  mounted: function mounted() {
	    this.infoWindowRef = this.$refs[this.id + "-Info-Window"];
	  },
	  methods: {
	    handleClose: function handleClose() {
	      this.infoWindowRef.$infoWindowObject.close();
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    var renderPopover = this.renderPopover,
	      events = this.events;
	    return h(InfoWindow, {
	      "ref": this.id + "-Info-Window",
	      "props": _extends({}, this.infoWindowProps),
	      "on": _extends({}, events)
	    }, [h("div", [renderPopover(this.handleClose)])]);
	  }
	};

	var MapElementMixin = components.MapElementMixin;

	// Note: This file has been taken from https://github.com/eregnier/vue2-gmap-custom-marker/blob/master/gmap-custom-marker.vue
	var MarkerWithLabel = {
	  name: 'MarkerWithLabel',
	  props: {
	    metaData: {
	      type: Object,
	      "default": undefined
	    },
	    marker: {
	      type: Object,
	      "default": undefined
	    },
	    offsetX: {
	      type: Number,
	      "default": 0
	    },
	    offsetY: {
	      type: Number,
	      "default": 0
	    },
	    alignment: {
	      type: String,
	      "default": 'top'
	    },
	    zIndex: {
	      type: Number,
	      "default": 50
	    },
	    cssPosition: {
	      type: Boolean,
	      "default": false
	    },
	    renderMarker: VueTypes.func.isRequired,
	    handleMouseOver: VueTypes.func,
	    handleFocus: VueTypes.func,
	    handleMouseOut: VueTypes.func,
	    handleBlur: VueTypes.func,
	    handleClick: VueTypes.func
	  },
	  data: function data() {
	    return {
	      opacity: 0.01
	    };
	  },
	  mixins: [MapElementMixin],
	  inject: {
	    $clusterPromise: {
	      "default": null
	    }
	  },
	  computed: {
	    lat: function lat() {
	      return parseFloat(Number.isNaN(this.marker.lat) ? this.marker.latitude : this.marker.lat);
	    },
	    lng: function lng() {
	      return parseFloat(Number.isNaN(this.marker.lng) ? this.marker.longitude : this.marker.lng);
	    },
	    latLng: function latLng() {
	      if (this.marker instanceof window.google.maps.LatLng) {
	        return this.marker;
	      }
	      return new window.google.maps.LatLng(this.lat, this.lng);
	    }
	  },
	  watch: {
	    marker: function marker() {
	      var _this = this;
	      this.$mapPromise.then(function () {
	        return _this.$overlay.setPosition();
	      });
	    },
	    zIndex: function zIndex() {
	      if (this.$overlay) {
	        this.$overlay.repaint();
	      }
	    }
	  },
	  beforeCreate: function beforeCreate(options) {
	    if (this.$clusterPromise) {
	      // eslint-disable-next-line
	      options.map = null;
	    }
	    return this.$clusterPromise;
	  },
	  destroyed: function destroyed() {
	    if (this.$clusterObject) {
	      this.$clusterObject.removeMarker(this.$overlay, true);
	    } else if (this.$overlay) {
	      this.$overlay.setMap(null);
	      this.$overlay = undefined;
	    }
	  },
	  provide: function provide() {
	    var _this2 = this;
	    var self = this;
	    return this.$mapPromise.then(function (map) {
	      var Overlay = /*#__PURE__*/function (_window$google$maps$O) {
	        _inheritsLoose(Overlay, _window$google$maps$O);
	        function Overlay(map2) {
	          var _this3;
	          _this3 = _window$google$maps$O.call(this) || this;
	          _this3.metaData = self.metaData;
	          _this3.setMap(map2);
	          _this3.draw = function () {
	            return _this3.repaint();
	          };
	          _this3.setPosition = function () {
	            return _this3.repaint();
	          };
	          _this3.getVisible = function () {
	            return true;
	          };
	          return _this3;
	        }
	        var _proto = Overlay.prototype;
	        _proto.repaint = function repaint() {
	          var div = self.$el;
	          var projection = this.getProjection();
	          if (projection && div) {
	            var posPixel = projection.fromLatLngToDivPixel(self.latLng);
	            var x;
	            var y;
	            switch (self.alignment) {
	              case 'top':
	                x = posPixel.x - div.offsetWidth / 2;
	                y = posPixel.y - div.offsetHeight;
	                break;
	              case 'bottom':
	                x = posPixel.x - div.offsetWidth / 2;
	                y = posPixel.y;
	                break;
	              case 'left':
	                x = posPixel.x - div.offsetWidth;
	                y = posPixel.y - div.offsetHeight / 2;
	                break;
	              case 'right':
	                x = posPixel.x;
	                y = posPixel.y - div.offsetHeight / 2;
	                break;
	              case 'center':
	                x = posPixel.x - div.offsetWidth / 2;
	                y = posPixel.y - div.offsetHeight / 2;
	                break;
	              case 'topleft':
	              case 'lefttop':
	                x = posPixel.x - div.offsetWidth;
	                y = posPixel.y - div.offsetHeight;
	                break;
	              case 'topright':
	              case 'righttop':
	                x = posPixel.x;
	                y = posPixel.y - div.offsetHeight;
	                break;
	              case 'bottomleft':
	              case 'leftop':
	                x = posPixel.x - div.offsetWidth;
	                y = posPixel.y;
	                break;
	              case 'bottomright':
	              case 'rightbottom':
	                x = posPixel.x;
	                y = posPixel.y;
	                break;
	              default:
	                throw new Error('Invalid alignment type of custom marker!');
	            }
	            if (self.cssPosition) {
	              div.style.transform = "translate(" + (x + self.offsetX) + "px, " + (y + self.offsetY) + "px)";
	            } else {
	              div.style.left = x + self.offsetX + "px";
	              div.style.top = y + self.offsetY + "px";
	            }
	            div.style['z-index'] = self.zIndex;
	          }
	        };
	        _proto.onAdd = function onAdd() {
	          if (this.$clusterObject) {
	            this.$clusterObject.removeMarker(this.$overlay, true);
	          } else if (this.$overlay) {
	            this.$overlay.setMap(null);
	            this.$overlay = undefined;
	          }
	          var div = self.$el;
	          var panes = this.getPanes();
	          div.style.position = 'absolute';
	          div.style.display = 'inline-block';
	          div.style.zIndex = self.zIndex;
	          panes.overlayLayer.appendChild(div);
	          panes.overlayMouseTarget.appendChild(div);
	          this.getDraggable = function () {
	            return false;
	          };
	          this.getPosition = function () {
	            return new window.google.maps.LatLng(self.lat, self.lng);
	          };
	          self.afterCreate(this);
	        }
	        // eslint-disable-next-line
	        ;
	        _proto.onRemove = function onRemove() {
	          if (self.$el) {
	            var ua = window.navigator.userAgent;
	            var msie = ua.indexOf('MSIE ');
	            // eslint-disable-next-line
	            if (msie > 0 || !!ua.match(/Trident.*rv\:11\./)) {
	              self.$el.parentNode.removeChild(self.$el);
	            } else {
	              self.$el.remove();
	            }
	          }
	        };
	        return Overlay;
	      }(window.google.maps.OverlayView);
	      _this2.$overlay = new Overlay(map);
	      setTimeout(function () {
	        if (_this2.$overlay) {
	          _this2.$overlay.repaint();
	          _this2.opacity = 1;
	        }
	      }, 100);
	    });
	  },
	  methods: {
	    afterCreate: function afterCreate(inst) {
	      var _this4 = this;
	      if (this.$clusterPromise && !this.isMarkerAdded) {
	        this.$clusterPromise.then(function (co) {
	          co.addMarker(inst);
	          _this4.$clusterObject = co;
	          _this4.isMarkerAdded = true;
	        });
	      }
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    return h("div", {
	      "style": {
	        opacity: this.opacity
	      },
	      "on": {
	        "mouseover": this.handleMouseOver,
	        "mouseout": this.handleMouseOut,
	        "click": this.handleClick
	      }
	    }, [this.renderMarker()]);
	  }
	};

	var _templateObject$q, _templateObject2$c, _templateObject3$8;
	var MapPin = index$1('div')(_templateObject$q || (_templateObject$q = _taggedTemplateLiteralLoose(["\n\theight: 24px;\n\twidth: auto;\n\tbackground-color: #fff;\n\tborder-radius: 2px;\n\tcolor: #222;\n\tbox-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.15);\n\tpadding: 3px 6px;\n\tfont-size: 15px;\n"])));
	var MapPinArrow = index$1('div')(_templateObject2$c || (_templateObject2$c = _taggedTemplateLiteralLoose(["\n\tborder-color: rgba(0, 0, 0, 0.2);\n\tborder-style: solid;\n\tborder-width: 0 1px 1px 0;\n\tmargin-left: -6px;\n\tbackground-color: #fff;\n\tmargin-top: -6px;\n\twidth: 12px;\n\theight: 12px;\n\t-webkit-transform: rotate(45deg);\n\t-ms-transform: rotate(45deg);\n\ttransform: rotate(45deg);\n"])));
	var mapPinWrapper = css(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteralLoose(["\n\t&:hover,\n\t&:focus {\n\t\tz-index: 200;\n\t}\n"])));

	var Marker = components.Marker;
	var recordResultClick$3 = lib_5.recordResultClick;
	var GoogleMapMarker = {
	  name: 'GoogleMapMarker',
	  props: {
	    index: VueTypes.number,
	    marker: VueTypes.object.isRequired,
	    getPosition: VueTypes.func.isRequired,
	    defaultPin: VueTypes.string,
	    renderItem: VueTypes.func,
	    setOpenMarkers: VueTypes.func.isRequired,
	    handlePreserveCenter: VueTypes.func.isRequired,
	    autoClosePopover: VueTypes.bool,
	    openMarkers: VueTypes.object,
	    renderPopover: VueTypes.func,
	    highlightMarkerOnHover: VueTypes.bool
	  },
	  data: function data() {
	    return {
	      zIndex: 0,
	      markerIcon: null
	    };
	  },
	  methods: {
	    setIcon: function setIcon(icon) {
	      this.markerIcon = icon;
	    },
	    increaseMarkerZIndex: function increaseMarkerZIndex() {
	      var handlePreserveCenter = this.$props.handlePreserveCenter;
	      if (this.highlightMarkerOnHover) {
	        this.zIndex += 1;
	      }
	      handlePreserveCenter(true);
	    },
	    removeMarkerZIndex: function removeMarkerZIndex() {
	      var handlePreserveCenter = this.$props.handlePreserveCenter;
	      if (this.highlightMarkerOnHover) {
	        this.zIndex -= 1;
	      }
	      handlePreserveCenter(true);
	    },
	    openMarker: function openMarker() {
	      var _ref, _extends2;
	      var _this$$props = this.$props,
	        handleOpenMarkers = _this$$props.setOpenMarkers,
	        openMarkers = _this$$props.openMarkers,
	        marker = _this$$props.marker,
	        autoClosePopover = _this$$props.autoClosePopover,
	        handlePreserveCenter = _this$$props.handlePreserveCenter;
	      var id = marker._id;
	      var newOpenMarkers = autoClosePopover ? (_ref = {}, _ref[id] = true, _ref) : _extends({}, openMarkers, (_extends2 = {}, _extends2[id] = true, _extends2));
	      handleOpenMarkers(newOpenMarkers);
	      handlePreserveCenter(true);
	      this.triggerAnalytics();
	      marker.setIcon = this.setIcon;
	      this.$emit('open-marker-popover', marker);
	    },
	    closeMarker: function closeMarker() {
	      var _this$$props2 = this.$props,
	        handleOpenMarkers = _this$$props2.setOpenMarkers,
	        marker = _this$$props2.marker,
	        autoClosePopover = _this$$props2.autoClosePopover,
	        handlePreserveCenter = _this$$props2.handlePreserveCenter,
	        openMarkers = _this$$props2.openMarkers;
	      var id = marker._id;
	      var del = openMarkers[id],
	        activeMarkers = _objectWithoutPropertiesLoose(openMarkers, [id].map(_toPropertyKey));
	      var newOpenMarkers = autoClosePopover ? {} : activeMarkers;
	      handleOpenMarkers(newOpenMarkers);
	      handlePreserveCenter(true);
	      marker.setIcon = this.setIcon;
	      this.$emit('close-marker-popover', marker);
	    },
	    triggerAnalytics: function triggerAnalytics() {
	      this.recordResultClick(this.index, this.marker._id);
	    },
	    renderPopoverClick: function renderPopoverClick(item) {
	      var _this = this;
	      var h = this.$createElement;
	      var additionalProps = {};
	      var _this$$props3 = this.$props,
	        getPosition = _this$$props3.getPosition,
	        _renderPopover = _this$$props3.renderPopover,
	        openMarkers = _this$$props3.openMarkers;
	      additionalProps = {
	        position: getPosition(item),
	        defaultOptions: {
	          pixelOffset: new window.google.maps.Size(0, -30)
	        }
	      };
	      if (item._id in openMarkers) {
	        return h(InfoWindowWrapper$1, {
	          "key": item._id + "-InfoWindow",
	          "attrs": {
	            "id": item._id,
	            "renderPopover": function renderPopover(_handleClose) {
	              return _renderPopover({
	                item: item,
	                handleClose: function handleClose() {
	                  _handleClose();
	                  _this.closeMarker();
	                }
	              });
	            },
	            "infoWindowProps": {
	              zIndex: 500,
	              position: additionalProps.position,
	              options: additionalProps.defaultOptions
	            },
	            "events": {
	              closeclick: function closeclick() {
	                return _this.closeMarker();
	              }
	            }
	          }
	        });
	      }
	      return null;
	    }
	  },
	  render: function render() {
	    var _this2 = this;
	    var h = arguments[0];
	    var _this$$props4 = this.$props,
	      getPosition = _this$$props4.getPosition,
	      renderItem = _this$$props4.renderItem,
	      defaultPin = _this$$props4.defaultPin,
	      renderPopover = _this$$props4.renderPopover,
	      customMarkerProps = _this$$props4.markerProps,
	      marker = _this$$props4.marker;
	    var markerProps = {};
	    if (this.zIndex) {
	      markerProps.zIndex = window.google.maps.Marker.MAX_ZINDEX + this.zIndex;
	    }
	    if (renderItem) {
	      marker.setIcon = this.setIcon;
	      var data = renderItem(marker);
	      if ('label' in data) {
	        return h(MarkerWithLabel, {
	          "key": marker._id,
	          "attrs": {
	            "metaData": marker,
	            "marker": getPosition(marker),
	            "labelAnchor": new window.google.maps.Point(0, 30),
	            "handleMouseOver": this.increaseMarkerZIndex,
	            "handleMouseOut": this.removeMarkerZIndex,
	            "handleClick": this.openMarker,
	            "zIndex": markerProps.zIndex,
	            "renderMarker": function renderMarker() {
	              return h("div", {
	                "attrs": {
	                  "css": mapPinWrapper
	                }
	              }, [h(MapPin, [data.label]), h(MapPinArrow), renderPopover ? _this2.renderPopoverClick(marker, true) : null]);
	            }
	          },
	          "props": _extends({}, customMarkerProps)
	        });
	      }
	      if ('icon' in data) {
	        markerProps.icon = data.icon;
	      } else {
	        return h(MarkerWithLabel, {
	          "key": marker._id,
	          "attrs": {
	            "metaData": marker,
	            "marker": getPosition(marker),
	            "handleClick": this.openMarker,
	            "handleMouseOver": this.increaseMarkerZIndex,
	            "handleMouseOut": this.removeMarkerZIndex,
	            "zIndex": markerProps.zIndex,
	            "renderMarker": function renderMarker() {
	              return h("div", {
	                "attrs": {
	                  "css": mapPinWrapper
	                }
	              }, [typeof data.custom === 'function' ? data.custom(marker) : data.custom, renderPopover ? _this2.renderPopoverClick(marker, true) : null]);
	            }
	          },
	          "props": _extends({}, customMarkerProps)
	        });
	      }
	    } else if (defaultPin) {
	      markerProps.icon = {
	        url: defaultPin
	      };
	    }
	    return h(Marker, {
	      "key": marker._id,
	      "attrs": {
	        "zIndex": markerProps.zIndex,
	        "position": getPosition(marker),
	        "options": {
	          metaData: marker
	        },
	        "icon": this.markerIcon || markerProps.icon
	      },
	      "on": {
	        "click": function click() {
	          return _this2.openMarker();
	        },
	        "mouseover": this.increaseMarkerZIndex,
	        "mouseout": this.removeMarkerZIndex
	      },
	      "props": _extends({}, customMarkerProps)
	    }, [renderPopover ? this.renderPopoverClick(marker) : null]);
	  }
	};
	var mapDispatchToProps$6 = {
	  recordResultClick: recordResultClick$3
	};
	var GoogleMapMarker$1 = connect(function () {
	  return null;
	}, mapDispatchToProps$6)(GoogleMapMarker);

	var Cluster$1 = components.Cluster;
	var GoogleMapMarkers = {
	  name: 'GoogleMapMarkers',
	  props: {
	    resultsToRender: VueTypes.array,
	    getPosition: VueTypes.func,
	    renderItem: VueTypes.func,
	    renderClusterPopover: VueTypes.func,
	    defaultPin: VueTypes.string,
	    autoClosePopover: VueTypes.bool,
	    handlePreserveCenter: VueTypes.func,
	    renderPopover: VueTypes.func,
	    markerProps: VueTypes.object,
	    clusterProps: VueTypes.object,
	    showMarkerClusters: VueTypes.bool,
	    highlightMarkerOnHover: VueTypes.bool
	  },
	  data: function data() {
	    return {
	      openMarkers: {},
	      clickedCluster: null,
	      clusterMarkers: []
	    };
	  },
	  methods: {
	    setOpenMarkers: function setOpenMarkers(openMarkers) {
	      this.openMarkers = openMarkers;
	    },
	    getAdditionalProps: function getAdditionalProps() {
	      return {
	        position: {
	          lat: this.clickedCluster.getCenter().lat(),
	          lng: this.clickedCluster.getCenter().lng()
	        },
	        defaultOptions: {
	          pixelOffset: new window.google.maps.Size(0, -30)
	        }
	      };
	    },
	    closeMarker: function closeMarker() {
	      this.clickedCluster = null;
	      this.clusterMarkers = [];
	      this.$emit('close-cluster-popover');
	    }
	  },
	  render: function render() {
	    var _this = this;
	    var h = arguments[0];
	    var resultsToRender = this.$props.resultsToRender;
	    var openMarkers = this.openMarkers;
	    var markerProps = {
	      openMarkers: openMarkers,
	      setMarkerOnTop: this.setMarkerOnTop,
	      setOpenMarkers: this.setOpenMarkers,
	      getPosition: this.getPosition,
	      renderItem: this.renderItem,
	      defaultPin: this.defaultPin,
	      autoClosePopover: this.autoClosePopover,
	      handlePreserveCenter: this.handlePreserveCenter,
	      renderPopover: this.renderPopover,
	      markerProps: this.markerProps,
	      showMarkerClusters: this.showMarkerClusters,
	      highlightMarkerOnHover: this.highlightMarkerOnHover
	    };
	    if (this.showMarkerClusters) {
	      return h("div", [h(Cluster$1, {
	        "props": _extends({}, this.clusterProps),
	        "on": {
	          "click": function click(cluster) {
	            var markers = cluster.markers.map(function (i) {
	              return i.metaData;
	            });
	            _this.clickedCluster = cluster;
	            _this.clusterMarkers = markers;
	            _this.$emit('open-cluster-popover', _this.clusterMarkers);
	          }
	        },
	        "ref": "clusterRef"
	      }, [h(ClusterManager, {
	        "attrs": {
	          "getPosition": markerProps.getPosition,
	          "markers": resultsToRender,
	          "defaultPin": markerProps.defaultPin,
	          "renderItem": markerProps.renderItem,
	          "markerProps": markerProps.markerProps,
	          "handlePreserveCenter": markerProps.handlePreserveCenter,
	          "autoClosePopover": markerProps.autoClosePopover,
	          "renderPopover": markerProps.renderPopover,
	          "highlightMarkerOnHover": markerProps.highlightMarkerOnHover
	        },
	        "on": _extends({}, this.$listeners)
	      })]), this.clickedCluster && this.renderClusterPopover ? h(InfoWindowWrapper$1, {
	        "attrs": {
	          "id": "cluster",
	          "infoWindowProps": {
	            zIndex: 500,
	            position: this.getAdditionalProps().position,
	            options: this.getAdditionalProps().defaultOptions
	          },
	          "renderPopover": function renderPopover(_handleClose) {
	            return _this.renderClusterPopover({
	              markers: _this.clusterMarkers,
	              cluster: _this.clickedCluster,
	              handleClose: function handleClose() {
	                _handleClose();
	                _this.closeMarker();
	              }
	            });
	          },
	          "events": {
	            closeclick: this.closeMarker
	          }
	        }
	      }) : null]);
	    }
	    return h("div", [resultsToRender.map(function (marker, index) {
	      return h(GoogleMapMarker$1, {
	        "attrs": {
	          "index": index,
	          "marker": marker
	        },
	        "props": _extends({}, markerProps),
	        "on": _extends({}, _this.$listeners)
	      });
	    })]);
	  }
	};

	var Map = components.MapLayer;
	var ReactiveGoogleMap = {
	  name: 'ReactiveGoogleMap',
	  props: {
	    className: types.string,
	    componentId: types.stringRequired,
	    dataField: types.stringRequired,
	    defaultQuery: VueTypes.func,
	    loader: types.title,
	    defaultZoom: VueTypes.number.def(13),
	    react: types.react,
	    size: types.number,
	    sortBy: types.sortBy,
	    URLParams: VueTypes.bool,
	    mapProps: VueTypes.object,
	    showMarkers: VueTypes.bool.def(true),
	    showMarkerClusters: VueTypes.bool.def(false),
	    searchAsMove: VueTypes.bool.def(false),
	    searchAsMoveLabel: VueTypes.string,
	    markerProps: VueTypes.object,
	    clusterProps: VueTypes.object,
	    renderItem: VueTypes.func,
	    showSearchAsMove: VueTypes.bool.def(true),
	    autoClosePopover: VueTypes.bool,
	    pagination: VueTypes.bool,
	    defaultPin: VueTypes.string,
	    autoCenter: VueTypes.bool,
	    defaultCenter: types.location,
	    center: types.location,
	    defaultRadius: types.number,
	    unit: types.string,
	    pages: VueTypes.number.def(5),
	    calculateMarkers: VueTypes.func,
	    highlightMarkerOnHover: VueTypes.bool.def(true)
	  },
	  created: function created() {
	    var _this = this;
	    this.mapRefPromiseResolve = null;
	    this.mapRefPromiseRejecter = null;
	    this.mapRefPromise = new Promise(function (resolve, reject) {
	      _this.mapRefPromiseResolver = resolve;
	      _this.mapRefPromiseRejecter = reject;
	    });
	  },
	  methods: {
	    renderMap: function renderMap(_ref) {
	      var _this2 = this;
	      var resultsToRender = _ref.resultsToRender,
	        center = _ref.center,
	        zoom = _ref.zoom,
	        handleZoomChange = _ref.handleZoomChange,
	        handleOnDragEnd = _ref.handleOnDragEnd,
	        handleOnIdle = _ref.handleOnIdle,
	        renderSearchAsMove = _ref.renderSearchAsMove,
	        handlePreserveCenter = _ref.handlePreserveCenter,
	        getPosition = _ref.getPosition,
	        autoClosePopover = _ref.autoClosePopover,
	        defaultPin = _ref.defaultPin;
	      var h = this.$createElement;
	      var style = {
	        width: '100%',
	        height: '100%',
	        position: 'relative'
	      };
	      return h("div", {
	        "style": style
	      }, [h(Map, {
	        "ref": "mapRef",
	        "attrs": {
	          "map-type-id": "terrain",
	          "options": {
	            zoomControl: true
	          },
	          "center": center,
	          "zoom": zoom
	        },
	        "style": {
	          height: '100%'
	        },
	        "props": _extends({}, this.mapProps),
	        "on": {
	          "zoom_changed": handleZoomChange,
	          "dragend": handleOnDragEnd,
	          "idle": handleOnIdle
	        }
	      }, [this.showMarkers ? h(GoogleMapMarkers, {
	        "attrs": {
	          "resultsToRender": resultsToRender,
	          "getPosition": getPosition,
	          "markerProps": this.markerProps,
	          "clusterProps": this.clusterProps,
	          "handlePreserveCenter": handlePreserveCenter,
	          "highlightMarkerOnHover": this.highlightMarkerOnHover,
	          "renderItem": this.$scopedSlots.renderItem ? function () {
	            return {
	              custom: _this2.$scopedSlots.renderItem
	            };
	          } : this.renderItem,
	          "defaultPin": defaultPin,
	          "autoClosePopover": autoClosePopover,
	          "renderPopover": this.$scopedSlots.renderPopover,
	          "renderClusterPopover": this.$scopedSlots.renderClusterPopover,
	          "showMarkerClusters": this.showMarkerClusters
	        },
	        "on": _extends({}, this.$listeners)
	      }) : null]), renderSearchAsMove()]);
	    },
	    getMapRef: function getMapRef() {
	      return this.mapRef;
	    },
	    getMapRefPromise: function getMapRefPromise() {
	      return this.mapRefPromise;
	    },
	    removeMarkers: function removeMarkers() {
	      var clusterManagerInstance;
	      var currentInstance = this;
	      while (currentInstance) {
	        if (currentInstance && currentInstance.$options && currentInstance.$options.name === 'connect-ClusterMarkers') {
	          clusterManagerInstance = currentInstance;
	          currentInstance = null;
	        } else if (currentInstance.$children) {
	          var _currentInstance$$chi = currentInstance.$children;
	          currentInstance = _currentInstance$$chi[0];
	        } else {
	          currentInstance = null;
	        }
	      }
	      if (clusterManagerInstance && clusterManagerInstance.removeMarkers) {
	        clusterManagerInstance.removeMarkers();
	      }
	    }
	  },
	  mounted: function mounted() {
	    var _this3 = this;
	    if (this.$refs.mapRef) {
	      this.$refs.mapRef.$mapPromise.then(function (map) {
	        _this3.mapRef = map;
	        _this3.mapRefPromiseResolver(_this3.mapRef);
	      })["catch"](this.mapRefPromiseRejecter);
	    }
	  },
	  render: function render() {
	    var h = arguments[0];
	    return h(RMConnected, helper$1([{
	      "attrs": {
	        "getMapRef": this.getMapRef,
	        "getMapPromise": this.getMapRefPromise,
	        "renderMap": this.renderMap,
	        "componentId": this.componentId,
	        "className": this.className,
	        "dataField": this.dataField,
	        "defaultZoom": this.defaultZoom,
	        "react": this.react,
	        "size": this.size,
	        "sortBy": this.sortBy,
	        "pagination": this.pagination,
	        "uRLParams": this.URLParams,
	        "defaultSearchAsMove": this.searchAsMove,
	        "showSearchAsMove": this.showSearchAsMove,
	        "searchAsMoveLabel": this.searchAsMoveLabel,
	        "showMarkers": this.showMarkers,
	        "markerProps": this.markerProps,
	        "autoClosePopover": this.autoClosePopover,
	        "defaultPin": this.defaultPin,
	        "defaultQuery": this.defaultQuery,
	        "autoCenter": this.autoCenter,
	        "defaultCenter": this.defaultCenter,
	        "defaultRadius": this.defaultRadius,
	        "unit": this.unit,
	        "pages": this.pages,
	        "center": this.center,
	        "loader": this.loader,
	        "calculateMarkers": this.calculateMarkers
	      }
	    }, {
	      scopedSlots: this.$scopedSlots,
	      on: this.$listeners
	    }]));
	  }
	};
	ReactiveGoogleMap.install = function (Vue, options) {
	  Vue.component(ReactiveGoogleMap.name, ReactiveGoogleMap);
	  if (!options || !options.key) {
	    console.error('ReactiveSearch: map key is required to use ReactiveGoogleMap component');
	  }
	  Vue.use(main, {
	    load: {
	      key: options.key,
	      libraries: 'places'
	    },
	    installComponents: false
	  });
	};

	// Add componentType for SSR
	ReactiveGoogleMap.componentType = constants_1$1.reactiveMap;

	var _excluded$k = ["aggs", "size"],
	  _excluded2 = ["query"],
	  _excluded3 = ["query"];
	var _componentTypeToDefau;
	var X_SEARCH_CLIENT$1 = 'ReactiveSearch Vue';
	var componentsWithoutFilters = [constants_1$1.numberBox, constants_1$1.ratingsFilter];
	var resultComponents = [constants_1$1.reactiveList, constants_1$1.reactiveMap];
	var componentTypeToDefaultValue = (_componentTypeToDefau = {}, _componentTypeToDefau[constants_1$1.singleList] = '', _componentTypeToDefau[constants_1$1.multiList] = [], _componentTypeToDefau[constants_1$1.singleDataList] = '', _componentTypeToDefau[constants_1$1.singleDropdownList] = '', _componentTypeToDefau[constants_1$1.multiDataList] = [], _componentTypeToDefau[constants_1$1.multiDropdownList] = [], _componentTypeToDefau[constants_1$1.tagCloud] = '', _componentTypeToDefau[constants_1$1.toggleButton] = '', _componentTypeToDefau[constants_1$1.singleDropdownRange] = '', _componentTypeToDefau[constants_1$1.multiDropdownRange] = [], _componentTypeToDefau[constants_1$1.singleRange] = '', _componentTypeToDefau[constants_1$1.multiRange] = [], _componentTypeToDefau);
	function getValue(state, id, defaultValue, componentType) {
	  if (state && state[id]) {
	    try {
	      // parsing for next.js - since it uses extra set of quotes to wrap params
	      var parsedValue = JSON.parse(state[id]);
	      return {
	        value: parsedValue,
	        reference: 'URL'
	      };
	    } catch (error) {
	      // using react-dom-server for ssr
	      return {
	        value: state[id],
	        reference: 'URL'
	      };
	    }
	  }
	  return {
	    value: defaultValue || componentTypeToDefaultValue[componentType] || null,
	    reference: 'DEFAULT'
	  };
	}
	function parseValue(value, component) {
	  if (component.source && component.source.parseValue) {
	    return component.source.parseValue(value, component);
	  }
	  return value;
	}

	// Returns query DSL with query property and other options
	function getDefaultQuery(component, value) {
	  // get custom or default query of sensor components
	  var currentValue = parseValue(value, component);
	  // get default query of result components
	  if (component.defaultQuery) {
	    var defaultQuery = component.defaultQuery(currentValue, component);
	    return _extends({
	      query: helper_22(defaultQuery)
	    }, helper_23(defaultQuery));
	  }
	  return component.source.defaultQuery ? {
	    query: component.source.defaultQuery(currentValue, component)
	  } : {};
	}
	// Only results the query part
	function getCustomQuery(component, value) {
	  // get custom or default query of sensor components
	  var currentValue = parseValue(value, component);
	  if (component.customQuery) {
	    var customQuery = component.customQuery(currentValue, component);
	    return _extends({
	      query: helper_22(customQuery)
	    }, helper_23(customQuery));
	  }
	  return component.source.defaultQuery ? {
	    query: component.source.defaultQuery(currentValue, component)
	  } : null;
	}
	function initReactivesearch(componentCollection, searchState, settings) {
	  return new Promise(function (resolve, reject) {
	    var credentials = settings.url && settings.url.trim() !== '' && !settings.credentials ? null : settings.credentials;
	    var enableTelemetry = settings.appbaseConfig && settings.appbaseConfig.enableTelemetry !== undefined ? settings.appbaseConfig.enableTelemetry : true;
	    var headers = _extends({}, settings.enableAppbase && _extends({
	      'X-Search-Client': X_SEARCH_CLIENT$1
	    }, enableTelemetry === false && {
	      'X-Enable-Telemetry': false
	    }), settings.headers, settings.enableAppbase && settings.endpoint && settings.endpoint.headers ? settings.endpoint.headers : {});
	    var url = settings.url && settings.url.trim() !== '' ? settings.url : 'https://scalr.api.appbase.io';
	    var transformRequest = settings.transformRequest || null;
	    if (settings.enableAppbase && settings.endpoint) {
	      if (settings.endpoint.url) {
	        // eslint-disable-next-line prefer-destructuring
	        url = settings.endpoint.url;
	      }
	      transformRequest = function transformRequest(request) {
	        var modifiedRequest = helper_1(request, settings.endpoint);
	        if (settings.transformRequest) {
	          return settings.transformRequest(modifiedRequest);
	        }
	        return modifiedRequest;
	      };
	    }
	    var config = {
	      url: url,
	      app: settings.app,
	      credentials: credentials,
	      transformRequest: transformRequest,
	      type: settings.type ? settings.type : '*',
	      transformResponse: settings.transformResponse || null,
	      graphQLUrl: settings.graphQLUrl || '',
	      headers: headers,
	      analyticsConfig: settings.appbaseConfig || null,
	      enableAppbase: settings.enableAppbase,
	      endpoint: settings.endpoint
	    };
	    var appbaseRef = appbasejs(config);
	    if (config.transformRequest) {
	      appbaseRef.transformRequest = config.transformRequest;
	    }
	    if (config.transformResponse) {
	      appbaseRef.transformResponse = config.transformResponse;
	    }
	    var components = [];
	    var selectedValues = {};
	    var internalValues = {};
	    var queryList = {};
	    var queryLog = {};
	    var queryOptions = {};
	    var dependencyTree = {};
	    var finalQuery = [];
	    var appbaseQuery = {}; // Use object to prevent duplicate query added by react prop
	    var orderOfQueries = [];
	    var hits = {};
	    var aggregations = {};
	    var compositeAggregations = {};
	    var state = {};
	    var customQueries = {};
	    var defaultQueries = {};
	    var componentProps = {};
	    componentCollection.forEach(function (component) {
	      var componentType = component.source.componentType;
	      components = [].concat(components, [component.componentId]);
	      // Set component props
	      var compProps = {};
	      Object.keys(component).forEach(function (key) {
	        if (constants_3$1.includes(key)) {
	          compProps[key] = component[key];
	        }
	      });
	      var isInternalComponentPresent = false;
	      if (component.source.hasInternalComponent) {
	        isInternalComponentPresent = component.source.hasInternalComponent(component);
	      }
	      var isResultComponent = resultComponents.includes(componentType);
	      var internalComponent = component.componentId + "__internal";
	      var label = component.filterLabel || component.componentId;
	      var _getValue = getValue(searchState, component.componentId, component.value || component.defaultValue, componentType),
	        value = _getValue.value,
	        reference = _getValue.reference;
	      // [1] set selected values
	      var showFilter = component.showFilter !== undefined ? component.showFilter : true;
	      if (componentsWithoutFilters.includes(componentType)) {
	        showFilter = false;
	      }
	      selectedValues = valueReducer(selectedValues, {
	        type: 'SET_VALUE',
	        component: component.componentId,
	        label: label,
	        value: value,
	        reference: reference,
	        showFilter: showFilter,
	        URLParams: component.URLParams || false
	      });
	      // Set custom and default queries
	      if (component.customQuery && typeof component.customQuery === 'function') {
	        customQueries[component.componentId] = component.customQuery(value, compProps);
	      }
	      if (component.defaultQuery && typeof component.defaultQuery === 'function') {
	        defaultQueries[component.componentId] = component.defaultQuery(value, compProps);
	      }
	      var componentQueryOptions = {};
	      // [2] set query options - main component query (valid for result components)
	      if (component && component.source.generateQueryOptions) {
	        componentQueryOptions = _extends({}, componentQueryOptions, component.source.generateQueryOptions(component));
	      }
	      var highlightQuery = {};
	      if (component.source.highlightQuery) {
	        highlightQuery = component.source.highlightQuery(component);
	      }
	      if (componentQueryOptions && Object.keys(componentQueryOptions).length || highlightQuery && Object.keys(highlightQuery).length) {
	        // eslint-disable-next-line
	        var _ref = componentQueryOptions || {},
	          aggs = _ref.aggs,
	          size = _ref.size,
	          otherQueryOptions = _objectWithoutPropertiesLoose(_ref, _excluded$k);
	        if (aggs && Object.keys(aggs).length) {
	          isInternalComponentPresent = true;
	          componentQueryOptions = _extends({}, componentQueryOptions, {
	            aggs: aggs,
	            size: typeof size === 'undefined' ? 100 : size
	          });
	        }

	        // sort, highlight, size, from - query should be applied on the main component
	        if (otherQueryOptions && Object.keys(otherQueryOptions).length || highlightQuery && Object.keys(highlightQuery).length) {
	          if (!otherQueryOptions) otherQueryOptions = {};
	          if (!highlightQuery) highlightQuery = {};
	          var mainQueryOptions = _extends({}, otherQueryOptions, highlightQuery, {
	            size: size
	          });
	          if (isInternalComponentPresent) {
	            mainQueryOptions = _extends({}, otherQueryOptions, highlightQuery);
	          }
	          if (isResultComponent) {
	            var currentPage = component.currentPage ? component.currentPage - 1 : 0;
	            if (selectedValues[component.componentId] && selectedValues[component.componentId].value) {
	              currentPage = selectedValues[component.componentId].value - 1 || 0;
	            }
	            var resultSize = component.size || 10;
	            var from = currentPage * resultSize;
	            // Update props for RS API
	            compProps.from = from;
	            mainQueryOptions = _extends({}, mainQueryOptions, highlightQuery, {
	              size: resultSize,
	              from: from
	            });
	          }
	          componentQueryOptions = _extends({}, componentQueryOptions, mainQueryOptions);
	        }
	      }
	      // [3] set dependency tree
	      if (component.react || isInternalComponentPresent || isResultComponent) {
	        var react = component.react;
	        if (isInternalComponentPresent || isResultComponent) {
	          react = helper_38(react, internalComponent);
	        }
	        dependencyTree = dependencyTreeReducer(dependencyTree, {
	          type: 'WATCH_COMPONENT',
	          component: component.componentId,
	          react: react
	        });
	      }
	      // [4] set query list
	      // Do not set default query for suggestions
	      if (isInternalComponentPresent && !transform_8(component.componentType)) {
	        var _ref2 = getDefaultQuery(component, value) || {},
	          defaultQuery = _ref2.query,
	          defaultQueryOptions = _objectWithoutPropertiesLoose(_ref2, _excluded2);
	        queryList = queryReducer(queryList, {
	          type: 'SET_QUERY',
	          component: internalComponent,
	          query: defaultQuery
	        });
	        queryOptions = queryOptionsReducer(queryOptions, {
	          type: 'SET_QUERY_OPTIONS',
	          component: internalComponent,
	          options: _extends({}, componentQueryOptions, defaultQueryOptions)
	        });
	      }
	      var _ref3 = getCustomQuery(component, value) || {},
	        query = _ref3.query,
	        options = _objectWithoutPropertiesLoose(_ref3, _excluded3);
	      var customQuery = query;
	      // set custom query for main component
	      queryList = queryReducer(queryList, {
	        type: 'SET_QUERY',
	        component: component.componentId,
	        query: customQuery
	      });
	      queryOptions = queryOptionsReducer(queryOptions, {
	        type: 'SET_QUERY_OPTIONS',
	        component: component.componentId,
	        options: _extends({}, options)
	      });
	      // Set component type in component props
	      compProps.componentType = componentType;
	      componentProps[component.componentId] = compProps;
	    });
	    state = {
	      components: components,
	      dependencyTree: dependencyTree,
	      queryList: queryList,
	      queryOptions: queryOptions,
	      selectedValues: selectedValues,
	      internalValues: internalValues,
	      props: componentProps,
	      customQueries: customQueries,
	      defaultQueries: defaultQueries
	    };
	    // [5] Generate finalQuery for search
	    componentCollection.forEach(function (component) {
	      // eslint-disable-next-line
	      var _buildQuery = helper_37(component.componentId, dependencyTree, queryList, queryOptions),
	        queryObj = _buildQuery.queryObj,
	        options = _buildQuery.options;
	      var componentQueryOptions = options;
	      var validOptions = ['aggs', 'from', 'sort'];
	      // check if query or componentQueryOptions are valid - non-empty
	      if (queryObj && !!Object.keys(queryObj).length || componentQueryOptions && Object.keys(componentQueryOptions).some(function (item) {
	        return validOptions.includes(item);
	      })) {
	        var _extends2;
	        if (!queryObj || queryObj && !Object.keys(queryObj).length) {
	          queryObj = {
	            match_all: {}
	          };
	        }
	        orderOfQueries = [].concat(orderOfQueries, [component.componentId]);
	        var currentQuery = _extends({
	          query: _extends({}, queryObj)
	        }, componentQueryOptions, queryOptions[component.componentId]);
	        queryLog = _extends({}, queryLog, (_extends2 = {}, _extends2[component.componentId] = currentQuery, _extends2));
	        if (settings.enableAppbase) {
	          var query = transform_5(component.componentId, transform_3(state, component.componentId, queryOptions && Object.keys(queryOptions[component.componentId]).length ? {
	            from: queryOptions[component.componentId].from
	          } : null));
	          if (query) {
	            var _extends3;
	            // Apply dependent queries
	            appbaseQuery = _extends({}, appbaseQuery, (_extends3 = {}, _extends3[component.componentId] = query, _extends3), transform_2(state, component.componentId, orderOfQueries));
	          }
	        } else {
	          var preference = config && config.analyticsConfig && config.analyticsConfig.userId ? config.analyticsConfig.userId + "_" + component : component;
	          finalQuery = [].concat(finalQuery, [{
	            preference: preference
	          }, currentQuery]);
	        }
	      }
	    });
	    state.queryLog = queryLog;
	    var handleTransformResponse = function handleTransformResponse(res, component) {
	      if (config.transformResponse && typeof config.transformResponse === 'function') {
	        return config.transformResponse(res, component);
	      }
	      return new Promise(function (resolveTransformResponse) {
	        return resolveTransformResponse(res);
	      });
	    };
	    var handleResponse = function handleResponse(res) {
	      var allPromises = orderOfQueries.map(function (component, index) {
	        return new Promise(function (responseResolve, responseReject) {
	          handleTransformResponse(res.responses[index], component).then(function (response) {
	            var _extends5;
	            if (response.aggregations) {
	              var _extends4;
	              aggregations = _extends({}, aggregations, (_extends4 = {}, _extends4[component] = response.aggregations, _extends4));
	              compositeAggregations = compositeAggsReducer(compositeAggregations, {
	                type: constants_10,
	                aggregations: response.aggregations,
	                append: false
	              });
	            }
	            hits = _extends({}, hits, (_extends5 = {}, _extends5[component] = {
	              hits: response.hits.hits,
	              total: typeof response.hits.total === 'object' ? response.hits.total.value : response.hits.total,
	              time: response.took
	            }, _extends5));
	            responseResolve();
	          })["catch"](function (err) {
	            return responseReject(err);
	          });
	        });
	      });
	      Promise.all(allPromises).then(function () {
	        state = _extends({}, state, {
	          hits: hits,
	          aggregations: aggregations
	        });
	        resolve(state);
	      });
	    };
	    var handleRSResponse = function handleRSResponse(res) {
	      var promotedResults = {};
	      var rawData = {};
	      var customData = {};
	      var settingsResponse = {};
	      var allPromises = orderOfQueries.map(function (component) {
	        return new Promise(function (responseResolve, responseReject) {
	          handleTransformResponse(res[component], component).then(function (response) {
	            if (response) {
	              var _extends7;
	              if (response.promoted) {
	                promotedResults[component] = response.promoted.map(function (promoted) {
	                  return _extends({}, promoted.doc, {
	                    _position: promoted.position
	                  });
	                });
	              }
	              rawData[component] = response;
	              // Update custom data
	              if (response.customData) {
	                customData[component] = response.customData;
	              }

	              // Update settings
	              if (response.settings) {
	                settingsResponse[component] = response.settings;
	              }
	              if (response.aggregations) {
	                var _extends6;
	                aggregations = _extends({}, aggregations, (_extends6 = {}, _extends6[component] = response.aggregations, _extends6));
	              }
	              var hitsObj = response.hits ? response.hits : response[component].hits;
	              hits = _extends({}, hits, (_extends7 = {}, _extends7[component] = {
	                hits: hitsObj.hits,
	                total: typeof hitsObj.total === 'object' ? hitsObj.total.value : hitsObj.total,
	                time: response.took
	              }, _extends7));
	              responseResolve();
	            }
	          })["catch"](function (err) {
	            return responseReject(err);
	          });
	        });
	      });
	      Promise.all(allPromises).then(function () {
	        state = _extends({}, state, {
	          hits: hits,
	          aggregations: aggregations,
	          compositeAggregations: compositeAggregations,
	          promotedResults: promotedResults,
	          settings: settingsResponse,
	          customData: customData,
	          rawData: rawData
	        });
	        resolve(state);
	      });
	    };
	    if (config.graphQLUrl) {
	      var handleTransformRequest = function handleTransformRequest(res) {
	        if (config.transformRequest && typeof config.transformRequest === 'function') {
	          var transformRequestPromise = config.transformRequest(res);
	          return transformRequestPromise instanceof Promise ? transformRequestPromise : Promise.resolve(transformRequestPromise);
	        }
	        return Promise.resolve(res);
	      };
	      handleTransformRequest(finalQuery).then(function (requestQuery) {
	        fetchGraphQL(config.graphQLUrl, config.url, config.credentials, config.app, requestQuery).then(function (res) {
	          handleResponse(res);
	        })["catch"](function (err) {
	          return reject(err);
	        });
	      })["catch"](function (err) {
	        return reject(err);
	      });
	    } else if (settings.enableAppbase && Object.keys(appbaseQuery).length) {
	      finalQuery = Object.keys(appbaseQuery).map(function (c) {
	        return appbaseQuery[c];
	      });
	      // Call RS API
	      var rsAPISettings = {};
	      if (config.analyticsConfig) {
	        rsAPISettings.recordAnalytics = utils_2(config.analyticsConfig.recordAnalytics) ? config.analyticsConfig.recordAnalytics : undefined;
	        rsAPISettings.userId = utils_2(config.analyticsConfig.userId) ? config.analyticsConfig.userId : undefined;
	        rsAPISettings.enableQueryRules = utils_2(config.analyticsConfig.enableQueryRules) ? config.analyticsConfig.enableQueryRules : undefined;
	        rsAPISettings.customEvents = utils_2(config.analyticsConfig.customEvents) ? config.analyticsConfig.customEvents : undefined;
	      }
	      appbaseRef.reactiveSearchv3(finalQuery, rsAPISettings).then(function (res) {
	        handleRSResponse(res);
	      })["catch"](function (err) {
	        return reject(err);
	      });
	    } else {
	      appbaseRef.msearch({
	        type: config.type === '*' ? '' : config.type,
	        body: finalQuery
	      }).then(function (res) {
	        handleResponse(res);
	      })["catch"](function (err) {
	        return reject(err);
	      });
	    }
	  });
	}

	var version = "1.33.12";

	var components$1 = [RLConnected, ResultCard, ResultList, ReactiveBase, DSConnected, SBConnected, ListConnected, ListConnected$1, RangeConnected$1, RangeConnected$2, RangeConnected$3, RangeConnected, RcConnected, RcConnected$1, RcConnected$2, TBConnected, ListConnected$2, ListConnected$3, StateProviderConnected, RangeConnected$4];
	function install (Vue) {
	  components$1.map(function (component) {
	    Vue.use(component);
	    return null;
	  });
	}

	// Add polyfills to support in IE
	if (typeof window !== 'undefined' && window.Vue) {
	  install(window.Vue);
	}
	var index$4 = {
	  version: version,
	  install: install
	};

	exports.DataSearch = DSConnected;
	exports.DynamicRangeSlider = RangeConnected;
	exports.MultiDropdownList = ListConnected$3;
	exports.MultiList = ListConnected$1;
	exports.MultiRange = RangeConnected$2;
	exports.RangeInput = RangeConnected$4;
	exports.RangeSlider = RangeConnected$3;
	exports.ReactiveBase = ReactiveBase;
	exports.ReactiveComponent = RcConnected;
	exports.ReactiveComponentPrivate = RcConnected$1;
	exports.ReactiveGoogleMap = ReactiveGoogleMap;
	exports.ReactiveList = RLConnected;
	exports.ResultCard = ResultCard;
	exports.ResultList = ResultList;
	exports.SearchBox = SBConnected;
	exports.SelectedFilters = RcConnected$2;
	exports.SingleDropdownList = ListConnected$2;
	exports.SingleList = ListConnected;
	exports.SingleRange = RangeConnected$1;
	exports.StateProvider = StateProviderConnected;
	exports.ToggleButton = TBConnected;
	exports.componentTypes = constants_1$1;
	exports.default = index$4;
	exports.initReactivesearch = initReactivesearch;
	exports.install = install;
	exports.version = version;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=reactivesearch-vue.umd.js.map
